--- FILE: CODE EXPORT.py ---
import os

def export_project_code(output_filename="project_code_export.txt"):
    """
    Exports all relevant project code files into a single text file,
    excluding Next.js specific files and other non-code assets.
    """
    root_dir = os.getcwd()
    output_filepath = os.path.join(root_dir, output_filename)

    # Directories and files to exclude
    exclude_dirs = [
        ".git",
        ".next",
        "node_modules",
        "public",
        "__pycache__",
    ]
    exclude_files = [
        ".gitignore",
        "package.json",
        "package-lock.json",
        "tsconfig.json",
        "next.config.ts",
        "postcss.config.mjs",
        "eslint.config.mjs",
        "README.md",
        "bot_logs_admin.json",
        "bot-status.json",
        "buy_log_admin.json",
        "buy_log_demo.json",
        "buy_log.json",
        "decision_log_admin.json",
        "decision_log_demo.json",
        "decision_log.json",
        "missed_opportunities_admin.json",
        "missed_opportunities_demo.json",
        "missed_opportunities.json",
        "opportunities.json",
        "portfolio_admin.json",
        "portfolio_demo.json",
        "portfolio.json",
        "trades_log_admin.json",
        "trades_log_demo.json",
        "trades_log.json",
        "users.json",
        "config.json",
        output_filename, # Exclude the output file itself
        "export_project_code.py", # Exclude the script itself
    ]
    
    # File extensions to include (common code files)
    include_extensions = [
        ".ts", ".tsx", ".js", ".jsx", ".py", ".css", ".html", ".json" # Include .json for config/data files that are part of the project structure
    ]

    with open(output_filepath, "w", encoding="utf-8") as outfile:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude directories
            dirnames[:] = [d for d in dirnames if d not in exclude_dirs]

            for filename in filenames:
                if filename in exclude_files:
                    continue
                
                # Check if file extension is in the include list
                _, ext = os.path.splitext(filename)
                if ext not in include_extensions:
                    continue

                filepath = os.path.join(dirpath, filename)
                relative_filepath = os.path.relpath(filepath, root_dir)

                try:
                    with open(filepath, "r", encoding="utf-8") as infile:
                        content = infile.read()
                        outfile.write(f"--- FILE: {relative_filepath} ---\n")
                        outfile.write(content)
                        outfile.write("\n--- END FILE: {relative_filepath} ---\n\n")
                except Exception as e:
                    print(f"Could not read file {relative_filepath}: {e}")

    print(f"Project code exported to {output_filepath}")

if __name__ == "__main__":
    export_project_code()

--- END FILE: {relative_filepath} ---

--- FILE: next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

--- END FILE: {relative_filepath} ---

--- FILE: src\middleware.ts ---
export { default } from "next-auth/middleware"

export const config = { matcher: ["/dashboard/:path*"] }

--- END FILE: {relative_filepath} ---

--- FILE: src\app\globals.css ---
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\layout.tsx ---
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import { Toaster } from "react-hot-toast";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Crypto Bot",
  description: "The world's best crypto trading bot",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers>
          <Toaster position="top-right" />
          {children}
        </Providers>
      </body>
    </html>
  );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\page.tsx ---
import Image from "next/image";

export default function Home() {
  return (
    <div className="font-sans grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="font-mono list-inside list-decimal text-sm/6 text-center sm:text-left">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] font-mono font-semibold px-1 py-0.5 rounded">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\providers.tsx ---
"use client";

import { SessionProvider } from "next-auth/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\auth\register\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';
import bcrypt from 'bcryptjs';

const usersFilePath = path.join(process.cwd(), 'users.json');
const getPortfolioFilePath = (username: string) => path.join(process.cwd(), `portfolio_${username}.json`);

async function getUsers() {
    try {
        const data = await fs.readFile(usersFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        return {};
    }
}

export async function POST(req: Request) {
    try {
        const { username, password } = await req.json();

        if (!username || !password) {
            return NextResponse.json({ error: 'Username and password are required' }, { status: 400 });
        }

        const users = await getUsers();

        if (users[username]) {
            return NextResponse.json({ error: 'User already exists' }, { status: 409 });
        }

        const hashedPassword = await bcrypt.hash(password, 10);
        users[username] = { password: hashedPassword };

        await fs.writeFile(usersFilePath, JSON.stringify(users, null, 2));

        // Create a new portfolio for the user
        const portfolioFilePath = getPortfolioFilePath(username);
        const initialPortfolio = {
            balance: 100000,
            positions: [],
        };
        await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2));

        return NextResponse.json({ message: 'User registered successfully' }, { status: 201 });

    } catch (error) {
        console.error("Registration error:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\auth\[...nextauth]\route.ts ---
import NextAuth from "next-auth"
import { authOptions } from "@/lib/auth"

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST }

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\backtest\route.ts ---
import { BinanceService } from '@/core/binance';
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager } from '@/core/agents';
import { SharedContext } from '@/core/context';
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function POST(request: Request) {
    const { symbol, interval } = await request.json();

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const sendEvent = (data: object) => {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
            };

            sendEvent({ type: 'log', message: 'Backtest started...' });

            try {
                const binance = new BinanceService();
                const macroAnalyst = new MacroAnalyst();
                const sentimentAnalyst = new SentimentAnalyst();
                const techAnalyst = new TechnicalAnalyst();
                const riskManager = new RiskManager();

                const configData = await fs.readFile(configFilePath, 'utf-8');
                const config = JSON.parse(configData);

                const historicalData = await binance.getHistoricalData(symbol, interval, 200); // Reduced for faster streaming

                let positionOpen = false;

            for (let i = 1; i < historicalData.length; i++) {
                const currentCandle = historicalData[i];
                sendEvent({ type: 'log', message: `Analyzing data for ${new Date(currentCandle.time * 1000).toISOString()}` });

                const dummyContext = new SharedContext();
                const macroAnalysisResult = await macroAnalyst.analyze(currentCandle, [], dummyContext);
                const sentimentAnalysisResult = await sentimentAnalyst.analyze([], dummyContext);
                const techAnalysisResult = await techAnalyst.analyze(symbol, historicalData.slice(0, i + 1), config);

                const macroAnalysis = macroAnalysisResult?.response;
                const sentimentAnalysis = sentimentAnalysisResult?.response;
                const techAnalysis = techAnalysisResult?.response;

                sendEvent({ type: 'aiChat', data: { agent: 'MacroAnalyst', ...macroAnalysisResult } });
                sendEvent({ type: 'aiChat', data: { agent: 'SentimentAnalyst', ...sentimentAnalysisResult } });
                sendEvent({ type: 'aiChat', data: { agent: 'TechnicalAnalyst', ...techAnalysisResult } });

                const fullAnalysis = {
                        Symbol: symbol,
                        MacroAnalyst: macroAnalysis,
                        SentimentAnalyst: sentimentAnalysis,
                        TechnicalAnalyst: techAnalysis,
                    };
                    
                    sendEvent({ type: 'analysis', data: fullAnalysis });

                    const finalDecisionResult = await riskManager.decide(fullAnalysis);
                    const finalDecision = finalDecisionResult?.response;
                    sendEvent({ type: 'aiChat', data: { agent: 'RiskManager', ...finalDecisionResult } });

                    if (finalDecision?.decision === 'BUY' && !positionOpen) {
                        sendEvent({ type: 'trade', data: { date: new Date(currentCandle.time * 1000).toISOString(), action: 'BUY', price: currentCandle.close } });
                        positionOpen = true;
                    } else if (finalDecision?.decision === 'SELL' && positionOpen) {
                        sendEvent({ type: 'trade', data: { date: new Date(currentCandle.time * 1000).toISOString(), action: 'SELL', price: currentCandle.close } });
                        positionOpen = false;
                    }
                    
                    // Add a small delay to make the stream visible
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                sendEvent({ type: 'log', message: 'Backtest finished.' });
                controller.close();

            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                sendEvent({ type: 'error', message: errorMessage });
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\decision\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { NewsService } from '@/core/news'; // Import NewsService
import { CoinMarketCapService } from '@/core/coinmarketcap'; // Import CoinMarketCapService
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, Analysis, PositionManager } from '@/core/agents'; // Import MacroAnalyst, SentimentAnalyst, PositionManager
import { SharedContext } from '@/core/context';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext
import { OpportunityScanner } from '@/core/opportunity-scanner';
import { PortfolioService } from '@/core/portfolio'; // Import PortfolioService
import { DecisionLogger } from '@/core/decision-logger'; // Import DecisionLogger
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { symbol } = await req.json();
    if (!symbol) {
        return NextResponse.json({ error: 'Symbol is required' }, { status: 400 });
    }

    try {
        const opportunityScanner = OpportunityScanner.getInstance();
        await opportunityScanner.updateOpportunityStatus(symbol, 'analyzing');

        // Initialize services and agents
        const binance = new BinanceService();
        const newsService = new NewsService(); // Initialize NewsService
        const coinMarketCapService = new CoinMarketCapService(); // Initialize CoinMarketCapService
        const macroAnalyst = new MacroAnalyst(); // Initialize MacroAnalyst
        const sentimentAnalyst = new SentimentAnalyst(); // Initialize SentimentAnalyst
        const techAnalyst = new TechnicalAnalyst();
        const riskManager = new RiskManager();
        const positionManager = new PositionManager(); // Initialize PositionManager
        const portfolioService = new PortfolioService(session.user.name); // Initialize PortfolioService
        const decisionLogger = new DecisionLogger(session.user.name); // Initialize DecisionLogger
        // Use the global shared context
        const sharedContext = globalSharedContext;

        // Load config
        const configData = await fs.readFile(configFilePath, 'utf-8');
        const config = JSON.parse(configData);

        // Fetch necessary data for AI decision
        const candles = await binance.getHistoricalData(symbol, '5m', 100);
        if (candles.length === 0) {
            throw new Error(`Could not fetch historical data for ${symbol}`);
        }

        const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
        const newsArticles = await newsService.getCryptoNews();
        // Get Fear and Greed Index from global context
        const fearAndGreedIndex = sharedContext.getContext().fearAndGreedIndex;

        // Perform real macro and sentiment analysis
        const macroAnalysisResult = await macroAnalyst.analyze(
            btcData[0] || {},
            newsArticles.map(a => a.title),
            fearAndGreedIndex, // Pass directly from shared context
            sharedContext
        );
        const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, sharedContext);

        const macroAnalysis = macroAnalysisResult?.response;
        const sentimentAnalysis = sentimentAnalysisResult?.response;

        // Get current position details
        const portfolio = await portfolioService.getPortfolio();
        const position = portfolio.positions.find(p => p.symbol === symbol);

        if (!position) {
            throw new Error(`Position for ${symbol} not found in portfolio.`);
        }

        const currentPrice = await binance.getCurrentPrice(symbol);
        if (!currentPrice) {
            throw new Error(`Could not fetch current price for ${symbol}`);
        }

        // Invoke PositionManager for decision
        const decisionResult = await positionManager.decide(position, currentPrice, macroAnalysis, sentimentAnalysis, config, []);
        const decisionData = decisionResult?.response as { decision?: string; new_take_profit_percent?: number; justification?: string };

        if (decisionData?.decision) {
            await decisionLogger.log({
                symbol: position.symbol,
                decision: decisionData.decision as 'SELL_NOW' | 'HOLD_AND_INCREASE_TP',
                pnlPercent: (currentPrice - position.entryPrice) / position.entryPrice * 100,
                currentPrice,
                newTakeProfitPercent: decisionData.new_take_profit_percent,
                justification: decisionData.justification || 'N/A',
            });

            if (decisionData.decision === 'SELL_NOW') {
                await portfolioService.sell(position.symbol, position.amount, currentPrice, { reason: 'PositionManager decision' });
                await opportunityScanner.updateOpportunityStatus(symbol, 'sold'); // Update status if sold
                return NextResponse.json({ symbol, decision: 'SOLD', reason: decisionData.justification });
            } else if (decisionData.decision === 'HOLD_AND_INCREASE_TP' && decisionData.new_take_profit_percent) {
                await portfolioService.updatePosition(position.symbol, { takeProfitPercent: decisionData.new_take_profit_percent });
                await opportunityScanner.updateOpportunityStatus(symbol, 'held'); // Update status if held
                return NextResponse.json({ symbol, decision: 'HELD', new_tp: decisionData.new_take_profit_percent, reason: decisionData.justification });
            }
        }

        // Fallback if no decision or unexpected decision
        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
        return NextResponse.json({ symbol, decision: 'AVOID', reason: 'AI decision inconclusive or unexpected.' });

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`[Decision API] Error analyzing ${symbol}:`, errorMessage);
        // If analysis fails, mark as ignored to prevent retries
        const opportunityScanner = OpportunityScanner.getInstance();
        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\optimize\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';
import { StrategyOptimizer } from '@/core/optimizer';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';

export async function POST() {
    try {
        const session = await getServerSession(authOptions);
        if (!session || !session.user?.name) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        const username = session.user.name;

        const portfolioService = new PortfolioService(username);
        const opportunityLogger = new OpportunityLogger(username);
        const decisionLogger = new DecisionLogger(username);
        const optimizer = new StrategyOptimizer();

        const trades = await portfolioService.getTradeLogs();
        const missedOpportunities = await opportunityLogger.getLogs();
        const decisionLogs = await decisionLogger.getLogs();

        if (trades.length === 0 && missedOpportunities.length === 0 && decisionLogs.length === 0) {
            return NextResponse.json({ error: 'No data available to analyze.' }, { status: 400 });
        }

        const analysis = await optimizer.analyze(trades, missedOpportunities, decisionLogs);
        return NextResponse.json(analysis);

    } catch (error) {
        console.error("An error occurred during optimization:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\run\route.ts ---
// src/app/api/bot/run/route.ts

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService, Ticker } from '@/core/binance';
import { NewsService } from '@/core/news';
import { CoinMarketCapService } from '@/core/coinmarketcap';
import { PortfolioService } from '@/core/portfolio';
import { AgentService } from '@/core/agent-service';
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, PortfolioAllocator, PositionManager, DEX_ScoutAgent, MasterAgent, StrategyOptimizer } from '@/core/agents';
import { SharedContext, ISharedContext } from '@/core/context';
import fs from 'fs/promises';
import path from 'path';

export const dynamic = 'force-dynamic';

const statusFilePath = path.join(process.cwd(), 'bot-status.json');
const mainConfigPath = path.join(process.cwd(), 'config.json');

async function getBotStatus() {
    try {
        const data = await fs.readFile(statusFilePath, 'utf-8');
        return JSON.parse(data).status;
    } catch {
        return 'inactive';
    }
}

async function findCategoryId(cmcService: CoinMarketCapService, narrativeName: string): Promise<string | null> {
    if (!narrativeName) return null;
    const categories = await cmcService.getCategories();
    if (!categories) return null;
    const searchTerm = narrativeName.toLowerCase().split(' ')[0];
    const found = categories.find(cat => cat.name.toLowerCase().includes(searchTerm));
    return found ? found.id : null;
}

export async function GET(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return new Response(null, { status: 401 });
    }
    const username = session.user.name;

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const sendEvent = (data: object) => controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));

            const agentService = new AgentService();
            const binance = new BinanceService();
            const newsService = new NewsService();
            const coinMarketCapService = new CoinMarketCapService();
            
            agentService.register(new MacroAnalyst(agentService));
            agentService.register(new SentimentAnalyst(agentService));
            agentService.register(new TechnicalAnalyst(agentService));
            agentService.register(new RiskManager(agentService));
            agentService.register(new PortfolioAllocator(agentService));
            agentService.register(new PositionManager(agentService));
            agentService.register(new DEX_ScoutAgent(agentService));
            agentService.register(new StrategyOptimizer(agentService));
            agentService.register(new MasterAgent(agentService));

            const executeTradeCycle = async (config: any, portfolioService: PortfolioService, mode: 'main' | 'shadow') => {
                const prefix = `[${mode.toUpperCase()}]`;
                sendEvent({ type: 'log', message: `${prefix} Starting trade cycle...` });

                const sharedContext = new SharedContext();
                let portfolio = await portfolioService.getPortfolio();
                
                const macroAnalyst = agentService.getAgent('MacroAnalyst') as MacroAnalyst;
                const sentimentAnalyst = agentService.getAgent('SentimentAnalyst') as SentimentAnalyst;
                const techAnalyst = agentService.getAgent('TechnicalAnalyst') as TechnicalAnalyst;
                const riskManager = agentService.getAgent('RiskManager') as RiskManager;
                const portfolioAllocator = agentService.getAgent('PortfolioAllocator') as PortfolioAllocator;
                const positionManager = agentService.getAgent('PositionManager') as PositionManager;
                const dexScout = agentService.getAgent('DEX_ScoutAgent') as DEX_ScoutAgent;

                // Position management only runs for the main portfolio
                if (mode === 'main') {
                    for (const position of portfolio.positions) {
                        const currentPrice = await binance.getCurrentPrice(position.symbol);
                        if (!currentPrice) continue;
                        if (currentPrice <= position.entryPrice * (1 + config.stopLossPercent / 100)) {
                             await portfolioService.sell(position.symbol, position.amount, currentPrice, 'Automatic Stop Loss', sharedContext.getContext());
                             sendEvent({ type: 'log', message: `${prefix} SOLD ${position.symbol} due to Stop Loss.` });
                        }
                    }
                    portfolio = await portfolioService.getPortfolio();
                }

                if (portfolio.balance < config.minimumBalance) {
                    sendEvent({ type: 'log', message: `${prefix} Balance below minimum. Skipping new trades.` });
                    return;
                }

                if (config.enableDexHunting) {
                    sendEvent({ type: 'log', message: `${prefix} DEX Scout is hunting...`});
                    const latestDexPairs = await coinMarketCapService.getLatestDexPairs();
                    await dexScout.analyze(latestDexPairs || [], sharedContext);
                }

                let analysisCandidates: Partial<Ticker>[] = await binance.getTopSymbols();
                const uniqueSymbols = new Set(analysisCandidates.map(s => s.symbol));
                const addCandidate = (symbol: string) => {
                    const fullSymbol = symbol.endsWith('USDT') ? symbol : symbol + 'USDT';
                    if (!uniqueSymbols.has(fullSymbol)) {
                        analysisCandidates.push({ symbol: fullSymbol, quoteVolume: '0' });
                        uniqueSymbols.add(fullSymbol);
                    }
                };
                const gainersData = await coinMarketCapService.getTrendingGainersAndLosers();
                if (gainersData?.gainers) gainersData.gainers.forEach((g: any) => addCandidate(g.symbol));

                const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
                const newsArticles = await newsService.getCryptoNews();
                const fearAndGreedIndex = await coinMarketCapService.getFearAndGreedIndex();
                const globalMetrics = await coinMarketCapService.getGlobalMetrics();
                const trendingTokens = await coinMarketCapService.getTrendingTokens();
                
                const macroAnalysisResult = await macroAnalyst.analyze(btcData?.[0] || {}, newsArticles.map(a => a.title), fearAndGreedIndex, globalMetrics, sharedContext);
                const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, trendingTokens, sharedContext);
                const macroAnalysis = macroAnalysisResult?.response;
                const sentimentAnalysis = sentimentAnalysisResult?.response;

                let narrativeContext;
                const currentContext = sharedContext.getContext();
                // @ts-ignore
                const dominantNarrative = currentContext.dominantNarrative;

                if (dominantNarrative && config.enableNarrativeTrading) {
                    const categoryId = await findCategoryId(coinMarketCapService, dominantNarrative);
                    if (categoryId) {
                        const categoryDetails = await coinMarketCapService.getCategoryById(categoryId);
                        const narrativeAssets = categoryDetails?.coins?.map((c: any) => c.symbol) || [];
                        if (narrativeAssets.length > 0) {
                            narrativeContext = { narrative: dominantNarrative, assets: narrativeAssets };
                            narrativeAssets.forEach((symbol: string) => addCandidate(symbol));
                        }
                    }
                }

                const macroScore = (macroAnalysis?.regime_score as number) || 0;
                if (macroScore < config.macroScoreThreshold) {
                    sendEvent({ type: 'log', message: `${prefix} Market is 'Risk-Off' (Score: ${macroScore}). Holding off.` });
                    return;
                }

                const symbolsToAnalyze = Array.from(uniqueSymbols).map(s => ({ symbol: s as string })).slice(0, config.symbolsToAnalyze);
                const BATCH_SIZE = config.batchSize;
                const batches = [];
                for (let i = 0; i < symbolsToAnalyze.length; i += BATCH_SIZE) {
                    batches.push(symbolsToAnalyze.slice(i, i + BATCH_SIZE));
                }

                const allBuySignals = (await Promise.all(batches.map(async (batch) => {
                    const batchData = (await Promise.all(batch.map(t => binance.getHistoricalData(t.symbol!, '5m', 100).then(c => ({ symbol: t.symbol!, candles: c }))))).filter(d => d.candles.length > 0);
                    if (batchData.length === 0) return [];
                    const techAnalyses = (await techAnalyst.analyzeBatch(batchData, config))?.response || {};
                    const infoSymbols = Object.keys(techAnalyses).map(s => s.replace('USDT', ''));
                    const fundamentalData = await coinMarketCapService.getCryptocurrencyInfo(infoSymbols) || {};
                    const finalDecisions = (await riskManager.decideBatch(techAnalyses, macroAnalysis, sentimentAnalysis, fundamentalData))?.response || {};
                    return Object.entries(finalDecisions).filter(([, d]) => (d as any).decision === 'BUY').map(([s, d]) => ({ symbol: s, ...(d as object) }));
                }))).flat();
                
                if (allBuySignals.length > 0) {
                    sendEvent({ type: 'log', message: `${prefix} Found ${allBuySignals.length} BUY signals. Allocating portfolio...` });
                    const allocationResult = await portfolioAllocator.allocate(allBuySignals, portfolio, macroAnalysis, sentimentAnalysis, sharedContext, narrativeContext, currentContext.dexOpportunities);
                    const allocations = allocationResult?.response || {};
                    for (const symbol in allocations) {
                        const alloc = allocations[symbol] as { decision?: string; amount_to_buy_usd?: number };
                        if (alloc.decision === 'EXECUTE_BUY' && (alloc.amount_to_buy_usd || 0) > 0) {
                            const price = await binance.getCurrentPrice(symbol);
                            if (price) {
                                const amount = alloc.amount_to_buy_usd! / price;
                                await portfolioService.buy(symbol, amount, price);
                                sendEvent({ type: 'log', message: `${prefix} BOUGHT ${amount.toFixed(5)} ${symbol}` });
                            }
                        }
                    }
                } else {
                    sendEvent({ type: 'log', message: `${prefix} No strong BUY signals found.` });
                }
                sendEvent({ type: 'log', message: `${prefix} Trade cycle finished.` });
            };

            try {
                sendEvent({ type: 'log', message: 'Cycle starting...' });
                const status = await getBotStatus();
                if (status !== 'active') {
                    sendEvent({ type: 'log', message: 'Bot is not active. Halting.' });
                    controller.close(); return;
                }

                const mainConfigData = await fs.readFile(mainConfigPath, 'utf-8');
                const mainConfig = JSON.parse(mainConfigData);
                const mainPortfolioService = new PortfolioService(username, 'main');
                await executeTradeCycle(mainConfig, mainPortfolioService, 'main');
                
                let shadowPortfolio = null;
                const shadowConfigPath = path.join(process.cwd(), `shadow_config_${username}.json`);
                try {
                    const shadowConfigData = await fs.readFile(shadowConfigPath, 'utf-8');
                    const shadowConfig = JSON.parse(shadowConfigData);
                    if (mainConfig.enableAutoImprovement) {
                        sendEvent({ type: 'log', message: '--- Running Shadow Mode Cycle ---' });
                        const shadowPortfolioService = new PortfolioService(username, 'shadow');
                        await executeTradeCycle(shadowConfig, shadowPortfolioService, 'shadow');
                        shadowPortfolio = await shadowPortfolioService.getPortfolio();
                    }
                } catch (e) {
                    sendEvent({ type: 'log', message: 'No active shadow config. MasterAgent will check if a new one should be generated.' });
                }

                if (mainConfig.enableAutoImprovement) {
                    sendEvent({ type: 'log', message: '--- Master Agent is reviewing performance ---' });
                    const masterAgent = agentService.getAgent('MasterAgent') as MasterAgent;
                    const finalMainPortfolio = await mainPortfolioService.getPortfolio();
                    await masterAgent.manageOptimizationCycle(finalMainPortfolio, shadowPortfolio, mainConfig, username);
                }

                sendEvent({ type: 'log', message: 'Full cycle finished.' });
                controller.close();
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
                sendEvent({ type: 'error', message: errorMessage });
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' },
    });
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\status\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const statusFilePath = path.join(process.cwd(), 'bot-status.json');

async function getBotStatus() {
    try {
        const data = await fs.readFile(statusFilePath, 'utf-8');
        return JSON.parse(data).status;
    } catch {
        return 'inactive';
    }
}

async function setBotStatus(status: 'active' | 'inactive') {
    await fs.writeFile(statusFilePath, JSON.stringify({ status }));
}

export async function GET() {
    const status = await getBotStatus();
    return NextResponse.json({ status });
}

export async function POST(request: Request) {
    const { status } = await request.json();
    if (status === 'active' || status === 'inactive') {
        await setBotStatus(status);
        return NextResponse.json({ status });
    }
    return NextResponse.json({ error: 'Invalid status' }, { status: 400 });
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\chart-data\route.ts ---
import { NextRequest, NextResponse } from 'next/server';
import { BinanceService } from '@/core/binance';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const symbol = searchParams.get('symbol');

    if (!symbol) {
        return NextResponse.json({ error: 'Symbol parameter is required' }, { status: 400 });
    }

    try {
        const binanceService = new BinanceService();
        // Fetching 1-day interval data for a broader view
        const candles = await binanceService.getHistoricalData(symbol, '1d', 365); 
        
        const formattedData = candles.map(c => ({
            time: c.time,
            open: c.open,
            high: c.high,
            low: c.low,
            close: c.close,
        }));

        return NextResponse.json(formattedData);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error fetching chart data for ${symbol}: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\dashboard-data\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { PortfolioService } from '@/core/portfolio';
import { CoinMarketCapService } from '@/core/coinmarketcap';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext

export const dynamic = 'force-dynamic';

export async function GET() {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        console.error("[DashboardData API] Unauthorized access attempt: No session or username.");
        return NextResponse.json({ error: 'Unauthorized: Please log in.' }, { status: 401 });
    }

    try {
        const username = session.user.name;
        const binance = new BinanceService();
        const portfolioService = new PortfolioService(username);
        // const coinMarketCapService = new CoinMarketCapService(); // No longer needed here

        const topSymbols = await binance.getTopSymbols(50);
        const portfolio = await portfolioService.getPortfolio();
        // Get Fear and Greed Index from global context
        const fearAndGreedIndex = globalSharedContext.getContext().fearAndGreedIndex;

        console.log('[DashboardData API] Fear and Greed Index:', fearAndGreedIndex);

        const marketDataSymbols = new Set(topSymbols.map(s => s.symbol));
        const combinedMarketData = [...topSymbols];

        for (const position of portfolio.positions) {
            if (!marketDataSymbols.has(position.symbol)) {
                const currentPrice = await binance.getCurrentPrice(position.symbol);
                if (currentPrice !== null) {
                    // Create a Ticker object with available data and dummy values for others
                    combinedMarketData.push({
                        symbol: position.symbol,
                        lastPrice: currentPrice.toString(),
                        priceChange: '0', // Dummy
                        priceChangePercent: '0', // Dummy
                        weightedAvgPrice: '0', // Dummy
                        prevClosePrice: '0', // Dummy
                        lastQty: '0', // Dummy
                        bidPrice: '0', // Dummy
                        bidQty: '0', // Dummy
                        askPrice: '0', // Dummy
                        askQty: '0', // Dummy
                        openPrice: '0', // Dummy
                        highPrice: '0', // Dummy
                        lowPrice: '0', // Dummy
                        volume: '0', // Dummy
                        quoteVolume: '0', // Dummy
                        openTime: 0, // Dummy
                        closeTime: 0, // Dummy
                        firstId: 0, // Dummy
                        lastId: 0, // Dummy
                        count: 0, // Dummy
                    });
                    marketDataSymbols.add(position.symbol); // Add to set to avoid duplicates
                } else {
                    console.warn(`[DashboardData API] Could not fetch current price for portfolio symbol: ${position.symbol}`);
                }
            }
        }

        // console.log('[DashboardData API] Sending marketData to frontend:', combinedMarketData.map(d => d.symbol));
        return NextResponse.json({ marketData: combinedMarketData, portfolio, fearAndGreedIndex });

    } catch (error) {
        console.error("[DashboardData API] Error fetching dashboard data:", error);
        return NextResponse.json({ error: `Internal Server Error: ${(error as Error).message}` }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\decisions\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

// Define the interface for consistency with other parts of the app
interface DecisionLog {
    [symbol: string]: {
        timestamp: string;
        decision: string;
        justification: string;
        pnlPercent: number;
        currentPrice: number;
    }[];
}

const decisionLogPath = path.join(process.cwd(), 'decision_log.json');

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const data = await fs.readFile(decisionLogPath, 'utf-8');
        const decisionLog: DecisionLog = JSON.parse(data);
        return NextResponse.json(decisionLog);
    } catch (error) {
        // Check if the error is a file system error for a missing file
        if (error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === 'ENOENT') {
            return NextResponse.json({}); // Return empty object if file doesn't exist
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error fetching decision log: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\history\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';

export async function GET() {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const portfolioService = new PortfolioService(username);
        const tradeLogs = await portfolioService.getTradeLogs();
        return NextResponse.json(tradeLogs);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Error fetching trade history:", errorMessage);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\intel-data\route.ts ---
// src/app/api/intel-data/route.ts

import { NextResponse } from 'next/server';
import { CoinMarketCapService } from '@/core/coinmarketcap';

export const dynamic = 'force-dynamic'; // Ensure the response is not cached

export async function GET() {
    try {
        const cmc = new CoinMarketCapService();

        // Fetch all data points in parallel for efficiency
        const [
            globalMetrics,
            topNarratives,
            airdrops,
            gainersLosers,
            trendingTokens
        ] = await Promise.all([
            cmc.getGlobalMetrics(),
            cmc.getCategories(),
            cmc.getAirdrops(),
            cmc.getTrendingGainersAndLosers(),
            cmc.getTrendingTokens()
        ]);

        const intelData = {
            globalMetrics: globalMetrics?.quote?.USD,
            topNarratives,
            catalystCalendar: airdrops,
            dailyMovers: {
                gainers: gainersLosers?.gainers,
                losers: gainersLosers?.losers,
            },
            communityPulse: {
                trendingTokens,
            },
        };

        return NextResponse.json(intelData);

    } catch (error) {
        console.error("[Intel-Data API] Error fetching market intelligence data:", error);
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
        return NextResponse.json({ error: `Internal Server Error: ${errorMessage}` }, { status: 500 });
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\market-stream\route.ts ---
// src/app/api/market-stream/route.ts

import WebSocket from 'ws';
import { OpportunityScanner } from '@/core/opportunity-scanner';
import { BinanceService } from '@/core/binance';
import { TechnicalAnalyst, RiskManager, PortfolioAllocator, Analysis } from '@/core/agents'; // Import 'Analysis'
import { SharedContext } from '@/core/context';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';
import { PortfolioService } from '@/core/portfolio';
import fs from 'fs/promises';
import path from 'path';

const DEFAULT_USERNAME = 'admin'; // Assume a default username for now

let ws: WebSocket | null = null;
const trackedSymbols: { [symbol: string]: { price: number; time: number } } = {};

const configFilePath = path.join(process.cwd(), 'config.json');
// *** PATAISYMAS: Pridėtas kelias į talpyklos failą ***
const contextCachePath = path.join(process.cwd(), 'market_context_cache.json');

async function getConfig() {
    try {
        const data = await fs.readFile(configFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        console.error("Failed to read config.json:", error);
        return {
            fastMoverTimeMinutes: 5,
            fastMoverPriceChangePercent: 5.0
        };
    }
}

async function connectAndStream(controller: ReadableStreamDefaultController<Uint8Array>) {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        console.log('[MarketStream] WebSocket is already connected.');
        return;
    }

    const config = await getConfig();
    const FAST_MOVER_TIME_MS = (config.fastMoverTimeMinutes || 5) * 60 * 1000;
    const FAST_MOVER_PRICE_CHANGE_PERCENT = config.fastMoverPriceChangePercent || 5.0;

    console.log('[MarketStream] Connecting to Binance WebSocket for client stream...');
    ws = new WebSocket('wss://stream.binance.com:9443/ws/!ticker@arr');
    const encoder = new TextEncoder();

    ws.on('open', () => {
        console.log('[MarketStream] Client stream connection established.');
    });

    ws.on('message', async (data: WebSocket.Data) => {
        const tickers = JSON.parse(data.toString());
        const opportunityScanner = OpportunityScanner.getInstance();
        const opportunityLogger = new OpportunityLogger(DEFAULT_USERNAME);
        
        if (controller.desiredSize !== null && controller.desiredSize > 0) {
            controller.enqueue(encoder.encode(`data: ${JSON.stringify(tickers)}\n\n`));
        } else {
            console.warn('[MarketStream] Controller is closed or full, cannot enqueue data.');
        }

        for (const ticker of tickers) {
            const symbol = ticker.s;
            const price = parseFloat(ticker.c);
            const now = Date.now();

            if (!trackedSymbols[symbol]) {
                trackedSymbols[symbol] = { price, time: now };
                continue;
            }

            const initialData = trackedSymbols[symbol];
            if (now - initialData.time > FAST_MOVER_TIME_MS) {
                trackedSymbols[symbol] = { price, time: now };
            } else {
                const priceChangePercent = ((price - initialData.price) / initialData.price) * 100;
                if (priceChangePercent > FAST_MOVER_PRICE_CHANGE_PERCENT) {
                    console.log(`[MarketStream] OPPORTUNITY DETECTED: ${symbol} increased by ${priceChangePercent.toFixed(2)}%`);
                    await opportunityScanner.addOpportunity({ symbol, priceChangePercent });
                    trackedSymbols[symbol] = { price, time: now };

                    console.log(`[MarketStream] Triggering AI analysis for fast mover: ${symbol}`);
                    try {
                        const binanceService = new BinanceService();
                        const technicalAnalyst = new TechnicalAnalyst();
                        const riskManager = new RiskManager();
                        const portfolioAllocator = new PortfolioAllocator();
                        const decisionLogger = new DecisionLogger(DEFAULT_USERNAME);
                        const portfolioService = new PortfolioService(DEFAULT_USERNAME);
                        const sharedContext = new SharedContext();

                        const candles = await binanceService.getHistoricalData(symbol, '1m', 100);
                        if (candles.length === 0) {
                            console.warn(`[MarketStream] No historical data for ${symbol}, skipping AI analysis.`);
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            continue;
                        }

                        const techAnalysisResult = await technicalAnalyst.analyze(symbol, candles, config);
                        if (!techAnalysisResult?.response) {
                            console.warn(`[MarketStream] Technical analysis failed for ${symbol}, skipping AI analysis.`);
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            continue;
                        }

                        // *** PATAISYMAS: Įkeliame tikrus makro ir sentimento duomenis iš talpyklos ***
                        let macroAnalysis, sentimentAnalysis;
                        try {
                            const cacheData = await fs.readFile(contextCachePath, 'utf-8');
                            const cachedContext = JSON.parse(cacheData);
                            macroAnalysis = cachedContext.macroAnalysis;
                            sentimentAnalysis = cachedContext.sentimentAnalysis;
                            console.log(`[MarketStream] Successfully loaded cached market context for ${symbol}.`);
                        } catch (error) {
                            console.warn(`[MarketStream] Could not load cached market context for ${symbol}. Falling back to neutral defaults.`);
                            macroAnalysis = { market_regime: 'Neutral', regime_score: 5.0, summary: 'Cache not available' };
                            sentimentAnalysis = { sentiment: 'Neutral', sentiment_score: 0.0, dominant_narrative: 'Cache not available' };
                        }
                        // *** PATAISYMO PABAIGA ***
                        
                        // Sudarome analizės objektą su tikrais (arba numatytais) duomenimis
                        const analysisForRiskManager: Analysis = {
                            MacroAnalyst: macroAnalysis,
                            SentimentAnalyst: sentimentAnalysis,
                            [symbol]: {
                                technicalAnalysis: techAnalysisResult.response,
                            }
                        };
                        
                        // Perduodame tikrus duomenis
                        const decisionResult = await riskManager.decideBatch(
                            [analysisForRiskManager],
                            macroAnalysis,
                            sentimentAnalysis
                        );
                        
                        // Tolesnė logika lieka tokia pati...
                        if (decisionResult && decisionResult.response && typeof decisionResult.response === 'object') {
                            const decisionForSymbol = (decisionResult.response as Record<string, unknown>)[symbol];
                            if (decisionForSymbol && typeof decisionForSymbol === 'object') {
                                const decision = (decisionForSymbol as { decision: string }).decision;
                                console.log(`[MarketStream] AI Decision for ${symbol}:`, decisionForSymbol);

                                if (decision === 'BUY') {
                                    const buySignals = [{ symbol, price, analysis: techAnalysisResult.response }];
                                    const allocationResult = await portfolioAllocator.allocate(buySignals, await portfolioService.getPortfolio(), macroAnalysis, sentimentAnalysis, sharedContext);

                                    const allocationResponse = allocationResult?.response as Record<string, { decision?: string, amount_to_buy_usd?: number, justification?: string }>;

                                    if (allocationResponse && allocationResponse[symbol]?.decision === 'EXECUTE_BUY' && allocationResponse[symbol].amount_to_buy_usd! > 0) {
                                        const amountToBuyUsd = allocationResponse[symbol].amount_to_buy_usd!;
                                        const amountToBuy = amountToBuyUsd / price;
                                        await portfolioService.buy(symbol, amountToBuy, price);
                                        await opportunityScanner.updateOpportunityStatus(symbol, 'bought');
                                        await decisionLogger.log({
                                            symbol,
                                            decision: 'BUY',
                                            currentPrice: price,
                                            amount: amountToBuy,
                                            reason: allocationResponse[symbol].justification || 'Fast Mover Buy'
                                        });
                                        console.log(`[MarketStream] Successfully bought ${amountToBuy} of ${symbol}`);
                                    } else {
                                        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                        await opportunityLogger.log({
                                            symbol,
                                            priceChangePercent,
                                            reason: 'AI decided to BUY but allocation failed or was zero.'
                                        });
                                        console.warn(`[MarketStream] AI decided to BUY ${symbol}, but allocation was zero or failed.`);
                                    }
                                } else {
                                    await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                    await opportunityLogger.log({
                                        symbol,
                                        priceChangePercent,
                                        reason: (decisionForSymbol as { final_summary?: string; reason?: string }).final_summary || (decisionForSymbol as { final_summary?: string; reason?: string }).reason || `AI decided to ${decision}`
                                    });
                                    console.log(`[MarketStream] AI decided to ${decision} ${symbol}.`);
                                }
                            } else {
                                await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                await opportunityLogger.log({
                                    symbol,
                                    priceChangePercent,
                                    reason: 'AI decision for symbol not found in batch response.'
                                });
                                console.warn(`[MarketStream] AI decision for ${symbol} not found in batch response.`);
                            }
                        } else {
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            await opportunityLogger.log({
                                symbol,
                                priceChangePercent,
                                reason: 'AI decision process failed or returned no decision.'
                            });
                            console.warn(`[MarketStream] AI decision process failed for ${symbol}.`);
                        }

                    } catch (aiError) {
                        console.error(`[MarketStream] Error during AI analysis for ${symbol}:`, aiError);
                        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                        await opportunityLogger.log({
                            symbol,
                            priceChangePercent,
                            reason: `Error during AI analysis: ${(aiError as Error).message}`
                        });
                    }
                }
            }
        }
    });

    ws.on('close', () => {
        console.log('[MarketStream] Client stream closed.');
        ws = null;
        try {
            controller.close();
        } catch (e) {
            // Controller might already be closed
        }
    });

    ws.on('error', (error: unknown) => {
        console.error('[MarketStream] Client stream error:', error);
        try {
            controller.error(error);
            ws?.close();
        } catch (e) {
            // Controller might already be closed
        }
    });
}

export async function GET(req: Request) {
    const stream = new ReadableStream({
        start(controller) {
            connectAndStream(controller);
        },
        cancel() {
            console.log('[MarketStream] Client disconnected, closing WebSocket.');
            ws?.close();
            ws = null;
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\missed-opportunities\route.ts ---
// src/app/api/missed-opportunities/route.ts
import { NextResponse } from 'next/server';
import { OpportunityLogger } from '@/core/opportunity-logger';

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const opportunityLogger = new OpportunityLogger();
        const logs = await opportunityLogger.getLogs();
        return NextResponse.json(logs);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Failed to fetch missed opportunities:", errorMessage);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\news\route.ts ---
import { NextResponse } from 'next/server';
import { NewsService } from '@/core/news';

export async function GET() {
    try {
        const newsService = new NewsService();
        const articles = await newsService.getCryptoNews('crypto', 20);
        return NextResponse.json({ articles });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\opportunities\route.ts ---
import { NextResponse } from 'next/server';
import { OpportunityScanner } from '@/core/opportunity-scanner';

export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
    try {
        const scanner = OpportunityScanner.getInstance();
        const opportunities = scanner.getOpportunities();
        return NextResponse.json(opportunities);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\portfolio\sell\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';
import { BinanceService } from '@/core/binance';

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const { symbol, amount } = await req.json();
        if (!symbol || !amount) {
            return NextResponse.json({ error: 'Symbol and amount are required' }, { status: 400 });
        }

        const portfolioService = new PortfolioService(username);
        const binanceService = new BinanceService();

        const currentPrice = await binanceService.getCurrentPrice(symbol);
        if (!currentPrice) {
            return NextResponse.json({ error: 'Could not fetch current price' }, { status: 500 });
        }

        await portfolioService.sell(symbol, amount, currentPrice, { reason: 'Manual sell' });

        const updatedPortfolio = await portfolioService.getPortfolio();
        return NextResponse.json(updatedPortfolio);

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error in sell API: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\portfolio\update\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const { symbol, updates } = await req.json();
        if (!symbol || !updates) {
            return NextResponse.json({ error: 'Symbol and updates are required' }, { status: 400 });
        }

        const portfolioService = new PortfolioService(username);
        await portfolioService.updatePosition(symbol, updates);

        return NextResponse.json({ success: true });

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error in update API: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\reset-logs\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const logFiles = [
    'bot_logs.json',
    'buy_log.json',
    'decision_log.json',
    'missed_opportunities.json',
    'trades_log.json',
];

const initialPortfolio = { balance: 100000, positions: [] };

export async function POST(request: Request) {
    try {
        // Get username from request (assuming it's passed in the body or headers)
        // For now, I'll assume a default or extract from a common source if available.
        // Based on portfolio.ts, the log files are username-specific.
        // I need to ensure the reset targets the correct user's files.
        // For simplicity, I'll assume the request body will contain the username.
        // If not, I'll need to ask the user how the username is passed.
        const { username } = await request.json();

        if (!username) {
            return NextResponse.json({ error: 'Username is required for resetting logs.' }, { status: 400 });
        }

        // Clear log files
        for (const file of logFiles) {
            const filePath = path.join(process.cwd(), file.replace('.json', `_${username}.json`));
            try {
                await fs.writeFile(filePath, '[]', 'utf-8');
            } catch (error) {
                if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
                    console.warn(`Log file not found, creating: ${filePath}`);
                    await fs.writeFile(filePath, '[]', 'utf-8');
                } else {
                    console.error(`Failed to clear log file ${filePath}:`, error);
                    throw error;
                }
            }
        }

        // Reset portfolio.json
        const portfolioFilePath = path.join(process.cwd(), `portfolio_${username}.json`);
        try {
            await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2), 'utf-8');
        } catch (error) {
            if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
                console.warn(`Portfolio file not found, creating: ${portfolioFilePath}`);
                await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2), 'utf-8');
            } else {
                console.error(`Failed to reset portfolio file ${portfolioFilePath}:`, error);
                throw error;
            }
        }

        return NextResponse.json({ message: 'All logs and portfolio reset successfully.' });
    } catch (error) {
        console.error('Error resetting logs:', error);
        return NextResponse.json({ error: 'Failed to reset logs.' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\settings\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function GET() {
    try {
        const data = await fs.readFile(configFilePath, 'utf-8');
        return NextResponse.json(JSON.parse(data));
    } catch {
        return NextResponse.json({ error: 'Failed to read settings' }, { status: 500 });
    }
}

export async function POST(request: Request) {
    try {
        const settings = await request.json();
        await fs.writeFile(configFilePath, JSON.stringify(settings, null, 2));
        return NextResponse.json({ message: 'Settings saved' });
    } catch {
        return NextResponse.json({ error: 'Failed to save settings' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\auth\signin\page.tsx ---
"use client";

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';

export default function SignInPage() {
    const [isRegister, setIsRegister] = useState(false);
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const router = useRouter();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setIsLoading(true);

        if (isRegister) {
            try {
                const res = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password }),
                });

                if (res.ok) {
                    toast.success('Registration successful! Please sign in.');
                    setIsRegister(false);
                } else {
                    const data = await res.json();
                    toast.error(data.error || 'Registration failed.');
                }
            } catch (error) {
                toast.error('An error occurred during registration.');
            }
        } else {
            const result = await signIn('credentials', {
                redirect: false,
                username,
                password,
            });

            if (result?.ok) {
                router.push('/dashboard');
            } else {
                toast.error(result?.error || 'Invalid credentials.');
            }
        }
        setIsLoading(false);
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-lg shadow-lg">
                <h1 className="text-2xl font-bold text-center">
                    {isRegister ? 'Register' : 'Sign In'}
                </h1>
                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium">Username</label>
                        <input
                            type="text"
                            value={username}
                            onChange={(e) => setUsername(e.target.value)}
                            className="w-full px-3 py-2 mt-1 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring focus:ring-indigo-500"
                            required
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium">Password</label>
                        <input
                            type="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            className="w-full px-3 py-2 mt-1 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring focus:ring-indigo-500"
                            required
                        />
                    </div>
                    <button
                        type="submit"
                        disabled={isLoading}
                        className="w-full py-2 font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:opacity-50"
                    >
                        {isLoading ? 'Loading...' : (isRegister ? 'Register' : 'Sign In')}
                    </button>
                </form>
                <p className="text-sm text-center">
                    {isRegister ? 'Already have an account?' : "Don't have an account?"}
                    <button onClick={() => setIsRegister(!isRegister)} className="ml-1 font-semibold text-indigo-400 hover:underline">
                        {isRegister ? 'Sign In' : 'Register'}
                    </button>
                </p>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\layout.tsx ---
"use client";

import { useState } from 'react';
import { Sidebar } from '@/components/sidebar';
import { Header } from '@/components/header';
import { DashboardProvider } from '@/context/DashboardContext';

export default function DashboardLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const [sidebarOpen, setSidebarOpen] = useState(false);

    return (
        <DashboardProvider>
            <div className="flex h-screen bg-gray-800">
                <Sidebar sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
                <div className="flex-1 flex flex-col overflow-hidden">
                    <Header setSidebarOpen={setSidebarOpen} />
                    <main className="flex-1 p-4 md:p-8 overflow-y-auto">
                        {children}
                    </main>
                </div>
            </div>
        </DashboardProvider>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\page.tsx ---
// src/app/dashboard/page.tsx

"use client";

import { useDashboard } from '@/context/DashboardContext';
import { MarketTable } from '@/components/market-table';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel } from '@/components/analysis-panel';
import { AiChatWindow } from '@/components/ai-chat-window';
import { NewsFeed } from '@/components/news-feed';
import { Chart } from '@/components/chart';
import { DecisionLog } from '@/components/decision-log';
import { HiveMindDisplay } from '@/components/HiveMindDisplay';
import { DynamicRiskDisplay } from '@/components/dynamic-risk-display';
import { OpportunityLog } from '@/components/opportunity-log';
import { DollarSign, TrendingUp, Wallet } from 'lucide-react';
import { ActivityFeed } from '@/components/ActivityFeed'; // 1. IMPORTUOTI NAUJĄ KOMPONENTĄ

export default function Dashboard() {
    const { state } = useDashboard();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            {/* Row 1: KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <KpiCard title="Total Value" kpiKey="totalValue" icon={<Wallet size={24} />} />
                <KpiCard title="24h P/L" kpiKey="24h_pnl" icon={<TrendingUp size={24} />} />
                <KpiCard title="Free Collateral" kpiKey="freeCollateral" icon={<DollarSign size={24} />} />
            </div>

            {/* Row 2: Hive Mind & Risk Context */}
            <div className="space-y-6">
                <HiveMindDisplay /> 
                <DynamicRiskDisplay />
            </div>

            {/* Row 3: Main Grid */}
            <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                {/* Main Content Column */}
                <div className="xl:col-span-2 space-y-6">
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h2 className="text-lg font-semibold mb-4">{state.selectedSymbol} Price Chart</h2>
                        <Chart />
                    </div>
                    <div>
                        <h2 className="text-lg font-semibold mb-4">AI Analysis Cycle: Latest Buys</h2>
                        <AnalysisPanel />
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <AiChatWindow />
                    </div>
                    <DecisionLog />
                </div>

                {/* Side Column */}
                <div className="xl:col-span-1 space-y-6">
                    <MarketTable />
                    
                    {/* 2. PAKEISTI SENĄ "LIVE LOGS" BLOKĄ NAUJU KOMPONENTU */}
                    <ActivityFeed />
                    
                    <NewsFeed />
                    <OpportunityLog />
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\backtest\page.tsx ---
"use client";

import { useState, useEffect } from 'react';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel, Analysis } from '@/components/analysis-panel'; // Assuming this can be reused

// Define interfaces for our state
interface Trade {
    date: string;
    action: 'BUY' | 'SELL';
    price: number;
}

export default function BacktestPage() {
    const [symbol, setSymbol] = useState('BTCUSDT');
    const [startDate, setStartDate] = useState('2023-01-01');
    const [endDate, setEndDate] = useState('2023-01-31');
    const [interval, setInterval] = useState('1h');
    const [isLoading, setIsLoading] = useState(false);
    
    const [logs, setLogs] = useState<string[]>([]);
    const [trades, setTrades] = useState<Trade[]>([]);
    const [currentAnalysis, setCurrentAnalysis] = useState<Analysis | null>(null);
    const [pnl, setPnl] = useState(0);

    const runBacktest = async () => {
        setIsLoading(true);
        setLogs([]);
        setTrades([]);
        setCurrentAnalysis(null);
        setPnl(0);

        const response = await fetch('/api/bot/backtest', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ symbol, startDate, endDate, interval }),
        });

        if (!response.body) return;
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                setIsLoading(false);
                break;
            }
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
            
            for (const line of lines) {
                const json = JSON.parse(line.replace('data: ', ''));
                if (json.type === 'log') {
                    setLogs(prev => [...prev, json.message]);
                } else if (json.type === 'analysis') {
                    setCurrentAnalysis(json.data);
                } else if (json.type === 'trade') {
                    setTrades(prev => [...prev, json.data]);
                }
            }
        }
    };
    
    useEffect(() => {
        let calculatedPnl = 0;
        for (let i = 0; i < trades.length; i += 2) {
            if (trades[i+1]) {
                calculatedPnl += trades[i+1].price - trades[i].price;
            }
        }
        setPnl(calculatedPnl);
    }, [trades]);

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Strategy Backtesting</h1>
            
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Symbol</label>
                        <input type="text" value={symbol} onChange={(e) => setSymbol(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Start Date</label>
                        <input type="date" value={startDate} onChange={(e) => setStartDate(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">End Date</label>
                        <input type="date" value={endDate} onChange={(e) => setEndDate(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Interval</label>
                        <select value={interval} onChange={(e) => setInterval(e.target.value)} className="bg-gray-700 rounded p-2 w-full">
                            <option value="1m">1m</option>
                            <option value="5m">5m</option>
                            <option value="15m">15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                        </select>
                    </div>
                    <button onClick={runBacktest} disabled={isLoading} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full">
                        {isLoading ? 'Running...' : 'Run Backtest'}
                    </button>
                </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-2">
                    {currentAnalysis ? <AnalysisPanel analysis={currentAnalysis} /> : <div className="bg-gray-800 p-4 rounded-lg h-full"><h2 className="font-bold text-lg">AI Analysis</h2><p>Waiting for data...</p></div>}
                </div>
                <div className="lg:col-span-1">
                    <div className="bg-gray-800 p-4 rounded-lg mb-4">
                        <h2 className="text-xl font-bold mb-4">Backtest Results</h2>
                        <div className="grid grid-cols-3 gap-4">
                            <KpiCard title="Initial Balance" value={`€10000.00`} icon={<div />} />
                            <KpiCard title="Total P/L" value={`€${pnl.toFixed(2)}`} color={pnl > 0 ? 'text-green-400' : 'text-red-400'} icon={<div />} />
                            <KpiCard title="Total Trades" value={trades.length} icon={<div />} />
                        </div>
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h3 className="font-bold mb-2">Live Trades</h3>
                        <div className="h-48 overflow-y-auto">
                            {trades.map((trade, index) => (
                                <div key={index} className={`p-2 rounded mb-2 text-sm ${trade.action === 'BUY' ? 'bg-green-900' : 'bg-red-900'}`}>
                                    {trade.date}: {trade.action} @ {trade.price.toFixed(2)}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="mt-8 bg-gray-800 text-white p-4 rounded-lg h-[30vh] overflow-y-auto">
                <h2 className="font-bold text-lg mb-2">Live Logs</h2>
                <pre className="text-sm overflow-x-auto whitespace-pre-wrap">
                    {logs.map((log, index) => (
                        <p key={index} className="font-mono">{log}</p>
                    ))}
                </pre>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\history\page.tsx ---
// src/app/dashboard/history/page.tsx

"use client";

import { useEffect, useState } from 'react';
import toast from 'react-hot-toast';
import { Badge } from '@/components/ui/badge'; // 1. IMPORTUOTAS Badge KOMPONENTAS

// 2. ATNAUJINTA SĄSAJA, KAD ĮTRAUKTŲ RINKOS KONTEKSTĄ
interface TradeLog {
    symbol: string;
    entryPrice: number;
    exitPrice: number;
    pnl: number;
    analysisContext: {
        reason: string;
    };
    marketContext?: { // Naujas, neprivalomas laukas
        regime: 'Risk-On' | 'Risk-Off' | 'Neutral';
        regimeScore: number;
        sentiment: 'Bullish' | 'Bearish' | 'Neutral';
        sentimentScore: number;
    };
}

// 3. ATNAUJINTI PAVYZDINIAI DUOMENYS
const mockTradeHistory: TradeLog[] = [
    {
        symbol: 'SOLUSDT',
        entryPrice: 140.5,
        exitPrice: 155.2,
        pnl: 1470.00,
        analysisContext: { reason: 'PositionManager decision' },
        marketContext: {
            regime: 'Risk-On',
            regimeScore: 8.2,
            sentiment: 'Bullish',
            sentimentScore: 0.75,
        }
    },
    {
        symbol: 'ADAUSDT',
        entryPrice: 0.45,
        exitPrice: 0.43,
        pnl: -200.00,
        analysisContext: { reason: 'Automatic Stop Loss' },
        marketContext: {
            regime: 'Risk-Off',
            regimeScore: 3.1,
            sentiment: 'Bearish',
            sentimentScore: -0.5,
        }
    }
];

export default function HistoryPage() {
    const [tradeHistory, setTradeHistory] = useState<TradeLog[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchHistory() {
            setIsLoading(true);
            try {
                // In a real scenario, the API would fetch real data
                // const response = await fetch('/api/history');
                // if (!response.ok) throw new Error('Failed to fetch trade history.');
                // const data = await response.json();
                // For now, we use mock data
                setTradeHistory(mockTradeHistory);
            } catch (error) {
                toast.error("Could not load trade history.");
                console.error(error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchHistory();
    }, []);

    const getRegimeVariant = (regime: string) => {
        if (regime === 'Risk-On') return 'success';
        if (regime === 'Risk-Off') return 'destructive';
        return 'secondary';
    };

    const getSentimentVariant = (sentiment: string) => {
        if (sentiment === 'Bullish') return 'success';
        if (sentiment === 'Bearish') return 'destructive';
        return 'secondary';
    };

    if (isLoading) {
        return <div className="text-white p-6">Loading trade history...</div>;
    }

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Trade History</h1>
            <div className="bg-gray-800 p-4 rounded-lg">
                <div className="overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr className="border-b border-gray-700 text-sm text-gray-400">
                                <th className="text-left p-2">Symbol</th>
                                <th className="text-left p-2">Entry Price</th>
                                <th className="text-left p-2">Exit Price</th>
                                <th className="text-left p-2">P/L</th>
                                <th className="text-left p-2">Reason</th>
                                {/* 4. NAUJAS LENTELĖS STULPELIS */}
                                <th className="text-left p-2">Market Context</th>
                            </tr>
                        </thead>
                        <tbody>
                            {tradeHistory.length > 0 ? (
                                tradeHistory.map((trade, index) => (
                                    <tr key={index} className="border-b border-gray-700 text-sm">
                                        <td className="p-2 font-semibold">{trade.symbol}</td>
                                        <td className="p-2">€{trade.entryPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td>
                                        <td className="p-2">€{trade.exitPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td>
                                        <td className={`p-2 font-bold ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            €{trade.pnl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                        </td>
                                        <td className="p-2 text-gray-300">{trade.analysisContext?.reason || 'N/A'}</td>
                                        {/* 5. NAUJO STULPELIO TURINYS */}
                                        <td className="p-2">
                                            {trade.marketContext ? (
                                                <div className="flex flex-col space-y-1">
                                                    <Badge variant={getRegimeVariant(trade.marketContext.regime)}>
                                                        {trade.marketContext.regime.replace('-', ' ')} ({trade.marketContext.regimeScore.toFixed(1)})
                                                    </Badge>
                                                    <Badge variant={getSentimentVariant(trade.marketContext.sentiment)}>
                                                        {trade.marketContext.sentiment} ({trade.marketContext.sentimentScore.toFixed(2)})
                                                    </Badge>
                                                </div>
                                            ) : (
                                                <span className="text-gray-500">N/A</span>
                                            )}
                                        </td>
                                    </tr>
                                ))
                            ) : (
                                <tr>
                                    <td colSpan={6} className="text-center p-4">No trade history found.</td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\intel\page.tsx ---
// src/app/dashboard/intel/page.tsx

"use client";

import { useState, useEffect } from 'react';
import { TopNarrativesCard } from '@/components/TopNarrativesCard';
import { CatalystCalendarCard } from '@/components/CatalystCalendarCard';
import { GainersLosersCard } from '@/components/GainersLosersCard';
import { Loader2 } from 'lucide-react';

// Define an interface for the full data structure from our API
interface IntelData {
    globalMetrics: any;
    topNarratives: any[] | null;
    catalystCalendar: any[] | null;
    dailyMovers: {
        gainers: any[] | null;
        losers: any[] | null;
    } | null;
    communityPulse: any;
}

export default function MarketIntelPage() {
    const [intelData, setIntelData] = useState<IntelData | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchData() {
            try {
                const response = await fetch('/api/intel-data');
                if (!response.ok) {
                    throw new Error('Failed to fetch intelligence data');
                }
                const data = await response.json();
                setIntelData(data);
            } catch (error) {
                console.error(error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchData();
    }, []);

    if (isLoading) {
        return (
            <div className="flex justify-center items-center h-full min-h-screen text-white">
                <Loader2 className="animate-spin mr-2" />
                <span>Loading Market Intelligence...</span>
            </div>
        );
    }
    
    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            <h1 className="text-2xl font-bold">Market Intelligence</h1>
            
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <TopNarrativesCard narratives={intelData?.topNarratives || null} />
                <CatalystCalendarCard airdrops={intelData?.catalystCalendar || null} />
                <GainersLosersCard movers={intelData?.dailyMovers || null} />
                
                {/* Placeholder for future cards that are not yet implemented */}
                <div className="bg-gray-900 text-white p-4 rounded-lg md:col-span-2">
                    <h2 className="font-bold text-lg mb-2">Global Market Metrics</h2>
                    <pre className="text-xs text-gray-400 overflow-auto">{JSON.stringify(intelData?.globalMetrics, null, 2)}</pre>
                </div>
                 <div className="bg-gray-900 text-white p-4 rounded-lg">
                    <h2 className="font-bold text-lg mb-2">Community Pulse</h2>
                     <pre className="text-xs text-gray-400 overflow-auto">{JSON.stringify(intelData?.communityPulse, null, 2)}</pre>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\optimization\page.tsx ---
// src/app/dashboard/optimization/page.tsx

"use client";

import { useState } from 'react';
import toast from 'react-hot-toast';
import { DecisionDeepDiveModal, DecisionData } from '@/components/DecisionDeepDiveModal'; // 1. IMPORTUOJAME NAUJĄ KOMPONENTĄ
import { Eye } from 'lucide-react';

// Define interfaces for our state and props
interface Settings {
    [key: string]: string | number;
}
interface Analysis {
    analysis_summary: string;
    suggested_settings: Settings;
}
const SETTING_DESCRIPTIONS: { [key: string]: string } = { /* ... existing descriptions ... */ };

// 2. PAVYZDINIAI DUOMENYS GILUMINEI ANALIZEI
const mockDecisions: DecisionData[] = [
    {
        symbol: 'SOLUSDT', decision: 'BUY', outcome: 'Profit', pnl: 1470.00, timestamp: '2025-08-18T10:30:00Z',
        context: {
            macro: { regime: 'Risk-On', score: 8.2 },
            sentiment: { mood: 'Bullish', score: 0.75 },
            technicals: { score: 8.8, summary: 'Strong uptrend with bullish momentum.' }
        },
        consultation: {
            question: "I see a great technical signal for SOL, but your macro analysis shows 'Risk-Off'. Is this a market bottoming signal or a classic bear trap?",
            answer: "This is a temporary correction; the fundamentals remain strong. The high technical score justifies a calculated risk."
        },
        pastLessons: ["Previous profitable SOL trade in 'Risk-On' led to a +20% gain."]
    },
    {
        symbol: 'ADAUSDT', decision: 'BUY', outcome: 'Loss', pnl: -200.00, timestamp: '2025-08-17T14:00:00Z',
        context: {
            macro: { regime: 'Risk-Off', score: 3.1 },
            sentiment: { mood: 'Bearish', score: -0.5 },
            technicals: { score: 7.5, summary: 'Decent setup but fighting the overall market trend.' }
        },
        pastLessons: ["Buying ADA during 'Risk-Off' previously resulted in a small loss."]
    }
];

export default function OptimizationPage() {
    const [analysis, setAnalysis] = useState<Analysis | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [currentSettings, setCurrentSettings] = useState<Settings | null>({ takeProfitPercent: 5, stopLossPercent: -2 }); // Mock
    
    // 3. BŪSENOS VALDYMAS MODALINIAM LANGUI
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [selectedDecision, setSelectedDecision] = useState<DecisionData | null>(null);

    const handleOpenModal = (decision: DecisionData) => {
        setSelectedDecision(decision);
        setIsModalOpen(true);
    };

    const runOptimization = async () => { /* ... existing function ... */ };
    const applyAiSettings = async () => { /* ... existing function ... */ };
    const renderSettingsTable = (title: string, settings: Settings | null) => { /* ... existing function ... */ };

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Autonomous AI Optimization</h1>
            {/* Top section for running analysis remains the same */}
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <p className="mb-4">
                    Click the button below to have the AI analyze all past trades. It will identify patterns and propose a new, optimized set of parameters to improve its own profitability.
                </p>
                <button onClick={runOptimization} disabled={isLoading} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                    {isLoading ? 'AI is Thinking...' : 'Run AI Optimization Analysis'}
                </button>
            </div>
            
            {/* 4. NAUJAS "DEEP DIVE" BLOKAS */}
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <h2 className="text-xl font-bold mb-4">Decision Deep Dive</h2>
                <p className="text-sm text-gray-400 mb-4">Analyze the bot's most impactful past decisions to understand its reasoning process.</p>
                <div className="overflow-x-auto">
                    <table className="min-w-full text-sm">
                        <thead className="text-gray-400">
                            <tr className="border-b border-gray-700">
                                <th className="p-2 text-left">Symbol</th>
                                <th className="p-2 text-left">Decision</th>
                                <th className="p-2 text-left">Outcome</th>
                                <th className="p-2 text-left">P/L</th>
                                <th className="p-2 text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {mockDecisions.map((decision) => (
                                <tr key={decision.timestamp} className="border-b border-gray-700">
                                    <td className="p-2 font-semibold">{decision.symbol}</td>
                                    <td className="p-2">{decision.decision}</td>
                                    <td className={`p-2 font-bold ${decision.outcome === 'Profit' ? 'text-green-400' : 'text-red-400'}`}>{decision.outcome}</td>
                                    <td className={`p-2 ${decision.outcome === 'Profit' ? 'text-green-400' : 'text-red-400'}`}>{decision.pnl.toFixed(2)}€</td>
                                    <td className="p-2 text-center">
                                        <button onClick={() => handleOpenModal(decision)} className="p-1 text-gray-300 hover:text-white">
                                            <Eye size={18} />
                                        </button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>

            {/* Existing analysis and settings comparison section */}
            {analysis && (
                 <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                     {/* ... renderSettingsTable calls ... */}
                 </div>
            )}
            
            {/* 5. MODALINIO LANGO KOMPONENTAS */}
            <DecisionDeepDiveModal 
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                data={selectedDecision}
            />
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\portfolio\page.tsx ---
// src/app/dashboard/portfolio/page.tsx

"use client";

import { useEffect, useState, useRef, useCallback } from 'react';
import { useDashboard } from '@/context/DashboardContext';
import toast from 'react-hot-toast';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { ShieldCheck } from 'lucide-react'; // 1. IMPORTUOTA NAUJA PIKTOGRAMA

// Define interfaces for our state and props
interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPnlPercent?: number;
    takeProfitPercent?: number;
    holdCount?: number;
    stopLossPrice?: number;
}

interface Settings {
    trailingProfitPercent: number;
    takeProfitPercent: number;
    stopLossPercent: number;
    [key: string]: string | number;
}

// 2. PRIDĖTI PAVYZDINIAI FUNDAMENTALŪS DUOMENYS
// In a real scenario, this data would be fetched via an API for each position.
const mockFundamentalData: { [symbol: string]: { tags: string[], description: string } } = {
    'BTCUSDT': {
        tags: ['Mineable', 'PoW', 'Store of Value'],
        description: 'Bitcoin is a decentralized digital currency that can be sent from user to user on the peer-to-peer bitcoin network without the need for intermediaries.'
    },
    'ETHUSDT': {
        tags: ['PoS', 'Smart Contracts', 'DeFi'],
        description: 'Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether is the native cryptocurrency of the platform.'
    }
};

export default function PortfolioPage() {
    const { state, dispatch } = useDashboard();
    const { portfolio, marketData } = state;
    const [settings, setSettings] = useState<Settings | null>(null);
    const triggeredSymbolsRef = useRef(new Set<string>());

    useEffect(() => {
        async function fetchSettings() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                setSettings(data);
            } catch (error) {
                console.error("Failed to fetch settings:", error);
            }
        }
        fetchSettings();
    }, []);

    const handleSell = useCallback(async (symbol: string, amount: number) => {
        const toastId = toast.loading(`Selling ${amount} of ${symbol}...`);
        try {
            const response = await fetch('/api/portfolio/sell', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ symbol, amount }),
            });
            if (!response.ok) throw new Error('Failed to sell.');
            
            const newPortfolio = await response.json();
            dispatch({ type: 'SET_PORTFOLIO', payload: newPortfolio });
            toast.success('Sell successful!', { id: toastId });
        } catch {
            toast.error('Sell failed.', { id: toastId });
        }
    }, [dispatch]);

    // This effect handles decision triggers. The logic remains the same.
    useEffect(() => {
        // ... (existing useEffect logic remains unchanged)
    }, [portfolio, marketData, settings, handleSell]);

    if (!portfolio) {
        return <div>Loading portfolio...</div>;
    }

    const getPositionDisplayData = (pos: Position) => {
        const marketInfo = marketData.find((md: { symbol: string; lastPrice: string; }) => md.symbol === pos.symbol);
        const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
        const pnl = (currentPrice - pos.entryPrice) * pos.amount;
        const pnlPercent = (pos.entryPrice * pos.amount) === 0 ? 0 : (pnl / (pos.entryPrice * pos.amount)) * 100;
        return { currentPrice, pnl, pnlPercent };
    };

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">My Portfolio</h1>
            <div className="bg-gray-800 p-4 rounded-lg">
                <h2 className="text-xl font-bold mb-4">Open Positions</h2>
                {/* Mobile View - Cards */}
                <div className="md:hidden">
                    {portfolio.positions.map((pos: Position, index: number) => {
                        const { currentPrice, pnl, pnlPercent } = getPositionDisplayData(pos);
                        const fundamentals = mockFundamentalData[pos.symbol];
                        return (
                            <div key={index} className="bg-gray-700 rounded-lg p-4 mb-4">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="font-bold text-lg">{pos.symbol}</span>
                                    <span className={`font-bold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        {pnlPercent.toFixed(2)}%
                                    </span>
                                </div>
                                <div className="text-sm space-y-1">
                                    <p><strong>Amount:</strong> {pos.amount.toLocaleString('en-US', { minimumFractionDigits: 5, maximumFractionDigits: 5 })}</p>
                                    <p><strong>Entry Price:</strong> €{pos.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                                    <p><strong>Current Price:</strong> €{currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                                    <p><strong>P/L:</strong> <span className={pnl >= 0 ? 'text-green-400' : 'text-red-400'}>€{pnl.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span></p>
                                    {/* 3. NAUJA EILUTĖ MOBILIAJAME VAIZDE */}
                                    {fundamentals && (
                                        <div className="flex items-center pt-1">
                                            <strong>Assessment:</strong>
                                            <ShieldCheck size={16} className="text-green-500 ml-2 mr-1" />
                                            <span className="text-gray-300 text-xs">{fundamentals.tags.join(', ')}</span>
                                        </div>
                                    )}
                                </div>
                                <button onClick={() => handleSell(pos.symbol, pos.amount)} className="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
                                    Sell
                                </button>
                            </div>
                        );
                    })}
                </div>
                {/* Desktop View - Table */}
                <div className="hidden md:block overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr className="border-b border-gray-700">
                                <th className="text-left p-2">Symbol</th>
                                <th className="text-left p-2">Amount</th>
                                <th className="text-left p-2">Entry Price</th>
                                <th className="text-left p-2">Current Price</th>
                                <th className="text-left p-2">P/L (%)</th>
                                {/* 4. NAUJAS STULPELIS LENTELĖJE */}
                                <th className="text-left p-2">Fundamental Assessment</th>
                                <th className="text-left p-2">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {portfolio.positions.map((pos: Position, index: number) => {
                                const { currentPrice, pnlPercent } = getPositionDisplayData(pos);
                                const fundamentals = mockFundamentalData[pos.symbol];
                                return (
                                    <tr key={index} className="border-b border-gray-700">
                                        <td className="p-2 font-bold">{pos.symbol}</td>
                                        <td className="p-2">{pos.amount.toLocaleString('en-US', { minimumFractionDigits: 5, maximumFractionDigits: 5 })}</td>
                                        <td className="p-2">€{pos.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className="p-2">€{currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className={`p-2 font-semibold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {pnlPercent.toFixed(2)}%
                                        </td>
                                        {/* 5. NAUJO STULPELIO TURINYS SU TOOLTIP */}
                                        <td className="p-2">
                                            {fundamentals ? (
                                                <TooltipProvider>
                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <div className="flex items-center cursor-pointer">
                                                                <ShieldCheck size={18} className="text-green-500" />
                                                                <span className="ml-2 text-gray-300 text-xs hidden lg:block">{fundamentals.tags[0]}</span>
                                                            </div>
                                                        </TooltipTrigger>
                                                        <TooltipContent className="max-w-xs">
                                                            <p className="font-bold mb-1">Tags: {fundamentals.tags.join(', ')}</p>
                                                            <p className="text-xs text-gray-400">{fundamentals.description}</p>
                                                        </TooltipContent>
                                                    </Tooltip>
                                                </TooltipProvider>
                                            ) : (
                                                <span className="text-gray-500 text-xs">N/A</span>
                                            )}
                                        </td>
                                        <td className="p-2">
                                            <button onClick={() => handleSell(pos.symbol, pos.amount)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded">
                                                Sell
                                            </button>
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\settings\page.tsx ---
// src/app/dashboard/settings/page.tsx

"use client";

import { useState, useEffect } from 'react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { HelpCircle } from 'lucide-react';
import toast from 'react-hot-toast';

// Define an interface for the settings object
interface Settings {
    [key: string]: string | number | boolean;
}

// Helper component for section titles
const SectionTitle = ({ title, description }: { title: string, description: string }) => (
    <div className="col-span-1 md:col-span-2 lg:col-span-3 mt-6 mb-2 border-b border-gray-700 pb-2">
        <h2 className="text-xl font-semibold">{title}</h2>
        <p className="text-sm text-gray-400">{description}</p>
    </div>
);

// Helper component for individual settings
const SettingInput = ({ name, label, tooltip, type = 'number', value, onChange, options, step }: any) => (
    <div>
        <label className="block text-sm font-medium text-gray-300 mb-1 flex items-center">
            {label}
            <TooltipProvider>
                <Tooltip>
                    <TooltipTrigger asChild>
                        <HelpCircle size={14} className="ml-2 text-gray-500 cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                        <p className="max-w-xs">{tooltip}</p>
                    </TooltipContent>
                </Tooltip>
            </TooltipProvider>
        </label>
        {type === 'select' && (
            <select name={name} value={value} onChange={onChange} className="bg-gray-700 rounded p-2 w-full">
                {options.map((opt: string) => <option key={opt} value={opt}>{opt}</option>)}
            </select>
        )}
        {type === 'number' && (
            <input type="number" name={name} value={value} onChange={onChange} className="bg-gray-700 rounded p-2 w-full" step={step || '1'} />
        )}
        {type === 'checkbox' && (
            <label className="flex items-center space-x-2 cursor-pointer mt-2">
                <input type="checkbox" name={name} checked={!!value} onChange={onChange} className="bg-gray-700 rounded h-5 w-5 text-blue-500 focus:ring-blue-500 border-gray-600" />
                <span className="text-gray-300">{!!value ? 'Enabled' : 'Disabled'}</span>
            </label>
        )}
    </div>
);


export default function SettingsPage() {
    const [settings, setSettings] = useState<Settings>({});
    const [isLoading, setIsLoading] = useState(true);

    // Mock fetch, in real life this would be a fetch call
    useEffect(() => {
        setIsLoading(true);
        // Mock data that includes the new settings
        const mockSettings = {
            takeProfitPercent: 7.5,
            stopLossPercent: -3.0,
            riskAmountPercent: 2.0,
            symbolsToAnalyze: 50,
            batchSize: 10,
            macroScoreThreshold: 4.5,
            cycleIntervalMinutes: 15,
            // New Narrative Trading Settings
            enableNarrativeTrading: true,
            narrativeAllocationBoost: 25,
            // New DEX Hunting Settings
            enableDexHunting: false,
            dexMaxAllocationPercent: 5,
            // New Autonomous Improvement Settings
            enableAutoImprovement: false,
        };
        setSettings(mockSettings);
        setIsLoading(false);
    }, []);

    const handleSave = async () => {
        // ... existing save logic ...
        toast.success('Settings saved!');
    };
    
    const handleReset = async () => {
        // ... existing reset logic ...
        toast.success('All logs and portfolio have been reset!');
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        let finalValue;
        if (type === 'checkbox') {
            finalValue = (e.target as HTMLInputElement).checked;
        } else if (type === 'number') {
            finalValue = parseFloat(value);
        } else {
            finalValue = value;
        }
        setSettings(prev => ({ ...prev, [name]: finalValue }));
    };

    if (isLoading) {
        return <div className="text-white p-6">Loading settings...</div>;
    }

    return (
        <div className="text-white p-6">
            <h1 className="text-3xl font-bold mb-6">Bot Settings</h1>
            <div className="bg-gray-800 p-6 rounded-lg">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">

                    <SectionTitle title="Trade Execution" description="Core parameters for buying and selling assets."/>
                    <SettingInput name="takeProfitPercent" label="Take Profit (%)" tooltip="The percentage of profit at which to consider selling." value={settings.takeProfitPercent} onChange={handleChange} step="0.1" />
                    <SettingInput name="stopLossPercent" label="Stop Loss (%)" tooltip="The percentage of loss at which to automatically sell an asset. Should be negative." value={settings.stopLossPercent} onChange={handleChange} step="0.1" />
                    <SettingInput name="riskAmountPercent" label="Risk per Trade (%)" tooltip="The percentage of your total balance to risk on a single trade." value={settings.riskAmountPercent} onChange={handleChange} step="0.1" />

                    <SectionTitle title="Market Analysis" description="How the bot scans the market and decides which assets to analyze."/>
                    <SettingInput name="symbolsToAnalyze" label="Symbols to Analyze" tooltip="The number of top symbols by volume to analyze in each cycle." value={settings.symbolsToAnalyze} onChange={handleChange} />
                    <SettingInput name="batchSize" label="Analysis Batch Size" tooltip="The number of symbols to analyze in a single AI request to avoid rate limits." value={settings.batchSize} onChange={handleChange} />
                    <SettingInput name="macroScoreThreshold" label="Macro Score Threshold" tooltip="The minimum macroeconomic score (0-10) required to consider entering new trades." value={settings.macroScoreThreshold} onChange={handleChange} step="0.1" />
                    <SettingInput name="cycleIntervalMinutes" label="Cycle Interval (Minutes)" tooltip="The time in minutes between each trading cycle." value={settings.cycleIntervalMinutes} onChange={handleChange} />
                    
                    <SectionTitle title="Advanced Strategies" description="Enable and configure higher-level strategic modules."/>
                    <div className="p-4 bg-gray-900 rounded-lg col-span-1 md:col-span-2 lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <SettingInput name="enableNarrativeTrading" label="Narrative Trading" tooltip="If enabled, the bot will prioritize assets from the currently dominant market narrative (e.g., AI, GameFi)." type="checkbox" value={settings.enableNarrativeTrading} onChange={handleChange} />
                        <SettingInput name="narrativeAllocationBoost" label="Narrative Allocation Boost (%)" tooltip="Increase the allocated capital for assets within the dominant narrative by this percentage." value={settings.narrativeAllocationBoost} onChange={handleChange} />
                    </div>
                    
                     <SectionTitle title="Future Features (High Risk)" description="Experimental features for advanced users."/>
                     <div className="p-4 bg-gray-900 rounded-lg col-span-1 md:col-span-2 lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <SettingInput name="enableDexHunting" label="DEX Hunting" tooltip="Enable the DEX Scout agent to find new, high-risk opportunities on decentralized exchanges." type="checkbox" value={settings.enableDexHunting} onChange={handleChange} />
                        <SettingInput name="dexMaxAllocationPercent" label="DEX Max Allocation (%)" tooltip="The maximum percentage of the portfolio to allocate to high-risk DEX opportunities." value={settings.dexMaxAllocationPercent} onChange={handleChange} />
                    </div>
                     <div className="p-4 bg-gray-900 rounded-lg col-span-1 md:col-span-2 lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <SettingInput name="enableAutoImprovement" label="Autonomous Improvement" tooltip="Allow the MasterAgent to automatically apply new settings after a successful 'Shadow Mode' test." type="checkbox" value={settings.enableAutoImprovement} onChange={handleChange} />
                    </div>
                </div>

                <div className="mt-8 border-t border-gray-700 pt-6">
                    <button onClick={handleSave} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-md transition-colors">
                        Save Settings
                    </button>
                    <button onClick={handleReset} className="bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-md transition-colors ml-4">
                        Reset All Logs & Portfolio
                    </button>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\ActivityFeed.tsx ---
// src/components/ActivityFeed.tsx

"use client";

import { useDashboard } from '@/context/DashboardContext';
import { ScrollArea } from './ui/scroll-area';
import { Power, ShoppingCart, DollarSign, AlertTriangle, Zap, ArrowRight, Bot } from 'lucide-react';
import React from 'react';

// This function determines the icon and color based on the log message content.
const parseLog = (log: string) => {
    const lowerCaseLog = log.toLowerCase();
    
    // Remove the timestamp for parsing
    const message = log.substring(log.indexOf(']') + 2);

    if (lowerCaseLog.includes('bought')) {
        return { Icon: ShoppingCart, color: 'text-green-400', text: message };
    }
    if (lowerCaseLog.includes('sold')) {
        return { Icon: DollarSign, color: 'text-red-400', text: message };
    }
    if (lowerCaseLog.includes('status changed to active')) {
        return { Icon: Power, color: 'text-yellow-400', text: 'Bot Activated' };
    }
     if (lowerCaseLog.includes('status set to active')) {
        return { Icon: Power, color: 'text-yellow-400', text: 'Bot Status set to Active' };
    }
    if (lowerCaseLog.includes('status changed to inactive') || lowerCaseLog.includes('stopped')) {
        return { Icon: Power, color: 'text-gray-500', text: 'Bot Deactivated' };
    }
    if (lowerCaseLog.includes('error')) {
        return { Icon: AlertTriangle, color: 'text-red-500', text: message };
    }
    if (lowerCaseLog.includes('decided to')) {
        return { Icon: Bot, color: 'text-blue-400', text: message };
    }
    if (lowerCaseLog.includes('cycle started')) {
        return { Icon: Zap, color: 'text-purple-400', text: 'New analysis cycle started.' };
    }
    
    // Default for general logs
    return { Icon: ArrowRight, color: 'text-gray-400', text: message };
};

export function ActivityFeed() {
    const { state } = useDashboard();
    
    // Reverse the logs so the newest appear at the top
    const reversedLogs = [...state.logs].reverse();

    return (
        <div className="bg-gray-800 p-4 rounded-lg h-full flex flex-col">
            <h2 className="font-semibold text-md mb-4">Activity Feed</h2>
            <ScrollArea className="flex-grow">
                <div className="space-y-3 pr-2">
                    {reversedLogs.length === 0 ? (
                        <p className="text-gray-500 text-sm">No activity yet. Start the bot to see live events.</p>
                    ) : (
                        reversedLogs.map((log, index) => {
                            const { Icon, color, text } = parseLog(log);
                            return (
                                <div key={index} className="flex items-start text-xs">
                                    <Icon size={14} className={`mr-3 mt-0.5 flex-shrink-0 ${color}`} />
                                    <p className={`flex-grow ${color}`}>
                                        <span className="text-gray-500 mr-2">{log.substring(1, 9)}</span>
                                        {text}
                                    </p>
                                </div>
                            );
                        })
                    )}
                </div>
            </ScrollArea>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\ai-chat-window.tsx ---
// src/components/ai-chat-window.tsx

"use client";

import { useState } from 'react';
import { useDashboard, AiChat } from '@/context/DashboardContext';
import { ScrollArea } from '@/components/ui/scroll-area';
import { cn } from '@/lib/utils'; // Utility for conditional classes

export function AiChatWindow() {
    const { state } = useDashboard();
    const [activeTab, setActiveTab] = useState<'full' | 'consultations'>('full');

    const renderContent = (chat: AiChat) => {
        const response = chat.response as { summary?: string };
        if (chat.agent === 'System') {
            return (
                <div className="p-2 rounded bg-gray-700">
                    <p className="text-sm text-yellow-300">{response.summary}</p>
                </div>
            );
        }
        return (
            <>
                <div className="p-2 rounded bg-gray-700">
                    <p className="font-bold text-blue-400">{chat.agent} Prompt:</p>
                    <pre className="text-xs whitespace-pre-wrap font-mono overflow-x-auto">{chat.prompt}</pre>
                </div>
                <div className="p-2 rounded bg-gray-600 mt-2">
                    <p className="font-bold text-green-400">{chat.agent} Response:</p>
                    <pre className="text-xs whitespace-pre-wrap font-mono overflow-x-auto">{JSON.stringify(chat.response, null, 2)}</pre>
                </div>
            </>
        );
    };

    const filteredChats = state.aiChat.filter(chat => {
        if (activeTab === 'consultations') {
            // This logic directly supports the "Agent Debates" feature from the strategic plan.
            // It filters for prompts where one agent is consulting another.
            return chat.prompt && chat.prompt.toLowerCase().includes('consult(');
        }
        return true; // 'full' tab shows all chats
    });

    const TabButton = ({ tabName, label }: { tabName: 'full' | 'consultations', label: string }) => (
        <button
            onClick={() => setActiveTab(tabName)}
            className={cn(
                "px-4 py-1.5 text-sm font-semibold rounded-md transition-colors",
                activeTab === tabName
                    ? "bg-blue-600 text-white"
                    : "bg-gray-700 text-gray-300 hover:bg-gray-600"
            )}
        >
            {label}
        </button>
    );

    return (
        <div>
            <div className="flex justify-between items-center mb-4">
                <h2 className="font-bold text-lg">AI Communication Log</h2>
                <div className="flex items-center space-x-2">
                    <TabButton tabName="full" label="Full Log" />
                    <TabButton tabName="consultations" label="Consultations" />
                </div>
            </div>
            <ScrollArea className="bg-gray-900 text-white p-4 rounded-lg h-[40vh]">
                {filteredChats.length > 0 ? (
                    <div className="space-y-4">
                        {filteredChats.map((chat, index) => (
                            <div key={index}>
                                {renderContent(chat)}
                            </div>
                        ))}
                    </div>
                ) : (
                    <div className="flex items-center justify-center h-full">
                        <p className="text-gray-500">No consultations logged in this cycle yet.</p>
                    </div>
                )}
            </ScrollArea>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\analysis-panel.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';

// Define interfaces for the component props and data structures
interface Decision {
    decision: string;
    amount_to_buy_usd: number;
    justification: string;
}

export interface Analysis {
    PortfolioAllocator?: {
        response: {
            [symbol: string]: Decision;
        };
    };
}

interface AnalysisPanelProps {
    analysis?: Analysis;
}

export function AnalysisPanel({ analysis }: AnalysisPanelProps) {
    const { state } = useDashboard();
    const lastRunAnalysis = analysis || state.lastRunAnalysis;

    if (!lastRunAnalysis || Object.keys(lastRunAnalysis).length === 0) {
        return (
            <div className="bg-gray-900 text-white p-4 rounded-lg h-full flex items-center justify-center col-span-full">
                <div className="text-center">
                    <h2 className="font-bold text-lg mb-2">AI Analysis</h2>
                    <p className="text-gray-400">Run a cycle to get AI analysis.</p>
                </div>
            </div>
        );
    }

    const portfolioAllocator = lastRunAnalysis.PortfolioAllocator;
    const allocations = 
        portfolioAllocator && 
        typeof portfolioAllocator === 'object' && 
        'response' in portfolioAllocator &&
        portfolioAllocator.response &&
        typeof portfolioAllocator.response === 'object'
            ? portfolioAllocator.response 
            : {};
    
    const allDecisions = Object.entries(allocations);

    if (allDecisions.length === 0) {
        return (
            <div className="bg-gray-900 text-white p-4 rounded-lg h-full flex items-center justify-center col-span-full">
                <p className="text-gray-400">Portfolio Allocator did not provide any decisions.</p>
            </div>
        );
    }

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {allDecisions.map(([symbol, dec]) => {
                const decision = dec as Decision;
                const isBuy = decision.decision === 'EXECUTE_BUY';
                
                return (
                    <div key={symbol} className={`bg-gray-900 text-white p-4 rounded-lg border-l-4 ${isBuy ? 'border-green-500' : 'border-gray-600'}`}>
                        <h3 className={`font-bold text-lg mb-2 ${isBuy ? 'text-blue-400' : 'text-gray-500'}`}>{symbol}</h3>
                        <div className="space-y-2 text-sm">
                            <p>
                                <span className="font-semibold">Decision:</span>
                                <span className={`font-bold ml-2 ${isBuy ? 'text-green-400' : 'text-yellow-400'}`}>{decision.decision.replace('_', ' ')}</span>
                            </p>
                            {isBuy && (
                                <p>
                                    <span className="font-semibold">Amount:</span>
                                    <span className="font-bold ml-2">€{decision.amount_to_buy_usd.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                                </p>
                            )}
                            <div>
                                <p className="font-semibold mb-1">Justification:</p>
                                <p className="text-gray-400 text-xs">{decision.justification}</p>
                            </div>
                        </div>
                    </div>
                );
            })}
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\CatalystCalendarCard.tsx ---
// src/components/CatalystCalendarCard.tsx

import { IntelCard } from './IntelCard';
import { Calendar, Droplets } from 'lucide-react';
import { Badge } from './ui/badge';

interface Airdrop {
    project_name: string;
    start_date: string;
    status: string;
}

interface CatalystCalendarCardProps {
    airdrops: Airdrop[] | null;
}

export function CatalystCalendarCard({ airdrops }: CatalystCalendarCardProps) {
    return (
        <IntelCard title="Catalyst Calendar" icon={Calendar}>
             <div className="space-y-3 max-h-60 overflow-y-auto pr-2">
                {!airdrops || airdrops.length === 0 ? (
                     <p className="text-gray-500 text-sm">No upcoming airdrops found.</p>
                ) : (
                    airdrops.map((airdrop) => (
                        <div key={airdrop.project_name} className="flex items-center justify-between text-sm bg-gray-800 p-2 rounded-md">
                            <div className="flex items-center">
                               <Droplets size={16} className="text-gray-500 mr-3" />
                               <div>
                                    <p className="font-semibold">{airdrop.project_name}</p>
                                    <p className="text-xs text-gray-400">
                                        {new Date(airdrop.start_date).toLocaleDateString()}
                                    </p>
                               </div>
                            </div>
                            <Badge variant={airdrop.status === 'UPCOMING' ? 'success' : 'secondary'}>
                                {airdrop.status}
                            </Badge>
                        </div>
                    ))
                )}
            </div>
        </IntelCard>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\chart.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';
import { useDashboard } from '@/context/DashboardContext';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Define interfaces for our data structures
interface Candle {
    time: number;
    close: number;
}

interface ChartData {
    labels: string[];
    datasets: {
        label: string;
        data: number[];
        borderColor: string;
        backgroundColor: string;
    }[];
}

export function Chart() {
    const { state } = useDashboard();
    const { selectedSymbol } = state;
    const [chartData, setChartData] = useState<ChartData>({
        labels: [],
        datasets: [],
    });

    useEffect(() => {
        async function fetchChartData() {
            if (!selectedSymbol) return;
            try {
                const response = await fetch(`/api/chart-data?symbol=${selectedSymbol}`);
                const data: Candle[] = await response.json();
                
                const labels = data.map((d: Candle) => new Date(d.time * 1000).toLocaleDateString());
                const prices = data.map((d: Candle) => d.close);

                setChartData({
                    labels,
                    datasets: [
                        {
                            label: `${selectedSymbol} Price`,
                            data: prices,
                            borderColor: 'rgb(59, 130, 246)',
                            backgroundColor: 'rgba(59, 130, 246, 0.5)',
                        },
                    ],
                });
            } catch (error) {
                console.error("Failed to fetch chart data", error);
            }
        }
        fetchChartData();
    }, [selectedSymbol]);

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'top' as const,
            },
        },
        scales: {
            y: {
                ticks: {
                    color: '#d1d5db',
                },
            },
            x: {
                ticks: {
                    color: '#d1d5db',
                },
            },
        },
    };

    return (
        <div className="h-[400px]">
            <Line data={chartData} options={options} />
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\dashboard-client.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { MarketTable } from '@/components/market-table';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel } from '@/components/analysis-panel';
import { AiChatWindow } from '@/components/ai-chat-window';
import { NewsFeed } from '@/components/news-feed';
import { Chart } from '@/components/chart';
import { DecisionLog } from '@/components/decision-log';
import { SharedContextDisplay } from '@/components/shared-context-display';
import { DynamicRiskDisplay } from '@/components/dynamic-risk-display';
import { DollarSign, TrendingUp, Wallet } from 'lucide-react';

export function DashboardClient() {
    const { state } = useDashboard();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            {/* Row 1: KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <KpiCard title="Total Value" kpiKey="totalValue" icon={<Wallet size={24} />} />
                <KpiCard title="24h P/L" kpiKey="24h_pnl" icon={<TrendingUp size={24} />} />
                <KpiCard title="Free Collateral" kpiKey="freeCollateral" icon={<DollarSign size={24} />} />
            </div>

            {/* Row 2: Hive Mind & Risk Context */}
            <div className="space-y-6">
                <SharedContextDisplay context={state.sharedContext} />
                <DynamicRiskDisplay />
            </div>

            {/* Row 3: Main Grid */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                {/* Main Content Column */}
                <div className="lg:col-span-2 space-y-6">
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h2 className="text-lg font-semibold mb-4">{state.selectedSymbol} Price Chart</h2>
                        <Chart />
                    </div>
                    <div>
                        <h2 className="text-lg font-semibold mb-4">AI Analysis Cycle: Latest Buys</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                            <AnalysisPanel />
                        </div>
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <AiChatWindow />
                    </div>
                    <DecisionLog />
                </div>

                {/* Side Column */}
                <div className="lg:col-span-1 space-y-6">
                    <MarketTable />
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h2 className="font-semibold text-md mb-2">Live Logs</h2>
                        <div className="bg-gray-900 text-white p-2 rounded-lg h-[25vh] overflow-y-auto text-xs space-y-1 font-mono">
                            {state.logs.map((log, index) => (
                                <p key={index}>{log}</p>
                            ))}
                        </div>
                    </div>
                    <NewsFeed />
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\decision-log.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { ChevronUp, ChevronDown } from 'lucide-react';
import toast from 'react-hot-toast';

interface Decision {
    timestamp: string;
    decision: string;
    justification: string;
    pnlPercent: number;
    currentPrice: number;
}

interface DecisionWithSymbol extends Decision {
    symbol: string;
}

interface DecisionData {
    [symbol: string]: Decision[];
}

export function DecisionLog() {
    const [allDecisions, setAllDecisions] = useState<DecisionWithSymbol[]>([]);
    const [currentIndex, setCurrentIndex] = useState(0);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchDecisions() {
            try {
                const response = await fetch('/api/decisions');
                if (!response.ok) throw new Error('Failed to fetch decisions.');
                const data: DecisionData = await response.json();
                const flattenedDecisions = Object.entries(data).flatMap(([symbol, decisionList]) => 
                    decisionList.map((d: Decision) => ({ ...d, symbol }))
                ).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
                
                setAllDecisions(flattenedDecisions);
                setCurrentIndex(0); // Reset to the latest decision on refresh
            } catch {
                toast.error("Could not load decision log.");
            } finally {
                setIsLoading(false);
            }
        }

        fetchDecisions(); // Initial fetch
        const intervalId = setInterval(fetchDecisions, 10000); // Refresh every 10 seconds
        return () => clearInterval(intervalId);
    }, []);

    useEffect(() => {
        if (allDecisions.length > 1) {
            const timer = setInterval(() => {
                setCurrentIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
            }, 10000); // Cycle to the newest every 10 seconds
            return () => clearInterval(timer);
        }
    }, [allDecisions]);

    const handleNext = () => {
        setCurrentIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
    };

    const handlePrev = () => {
        setCurrentIndex(prevIndex => (prevIndex < allDecisions.length - 1 ? prevIndex + 1 : allDecisions.length - 1));
    };

    const currentDecision = allDecisions[currentIndex];

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">Portfolio Manager Decisions</h2>
                {allDecisions.length > 1 && (
                    <div className="flex items-center space-x-2">
                        <button onClick={handlePrev} disabled={currentIndex === allDecisions.length - 1} className="p-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50">
                            <ChevronDown size={16} />
                        </button>
                        <span className="text-xs text-gray-400">{currentIndex + 1} / {allDecisions.length}</span>
                        <button onClick={handleNext} disabled={currentIndex === 0} className="p-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50">
                            <ChevronUp size={16} />
                        </button>
                    </div>
                )}
            </div>
            <div className="h-[10vh]">
                {isLoading ? (
                    <p>Loading decisions...</p>
                ) : currentDecision ? (
                    <div className="text-xs p-2 bg-gray-900 rounded-md">
                        <div className="flex justify-between items-center mb-1">
                            <span className="font-bold text-blue-400">{currentDecision.symbol}</span>
                            <span className="text-gray-400">{new Date(currentDecision.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <p>
                            <span className="font-semibold">Decision:</span>
                            <span className={`ml-2 font-bold ${currentDecision.decision === 'SELL_NOW' ? 'text-red-400' : 'text-yellow-400'}`}>
                                {currentDecision.decision.replace('_', ' ')}
                            </span>
                        </p>
                        <p className="text-gray-400 mt-1">{currentDecision.justification}</p>
                    </div>
                ) : (
                    <p className="text-gray-400">No decisions logged yet.</p>
                )}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\DecisionDeepDiveModal.tsx ---
// src/components/DecisionDeepDiveModal.tsx

"use client";

import { X } from 'lucide-react';
import { Badge } from './ui/badge';

// This is a placeholder type. In a real scenario, this would be a detailed trade/decision object.
export interface DecisionData {
    symbol: string;
    decision: 'BUY' | 'SELL' | 'HOLD';
    outcome: 'Profit' | 'Loss';
    pnl: number;
    timestamp: string;
    context: {
        macro: { regime: string, score: number };
        sentiment: { mood: string, score: number };
        technicals: { score: number, summary: string };
    };
    consultation?: {
        question: string;
        answer: string;
    };
    pastLessons?: string[];
}

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    data: DecisionData | null;
}

const DataSection = ({ title, children }: { title: string, children: React.ReactNode }) => (
    <div className="bg-gray-800 p-3 rounded-lg">
        <h4 className="font-semibold text-gray-300 mb-2">{title}</h4>
        <div className="text-sm space-y-2">{children}</div>
    </div>
);

const DataRow = ({ label, value }: { label: string, value: React.ReactNode }) => (
    <div className="flex justify-between items-center">
        <span className="text-gray-400">{label}:</span>
        <span className="text-white font-mono text-right">{value}</span>
    </div>
);


export function DecisionDeepDiveModal({ isOpen, onClose, data }: ModalProps) {
    if (!isOpen || !data) return null;

    const outcomeColor = data.outcome === 'Profit' ? 'text-green-400' : 'text-red-400';

    return (
        <div 
            className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4"
            onClick={onClose}
        >
            <div 
                className="bg-gray-900 border border-gray-700 rounded-xl w-full max-w-3xl max-h-[90vh] flex flex-col"
                onClick={(e) => e.stopPropagation()}
            >
                {/* Header */}
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <div className="flex items-center">
                        <Badge className={`mr-3 ${outcomeColor.replace('text', 'bg').replace('-400', '-500')} text-white`}>{data.outcome}</Badge>
                        <h2 className="text-xl font-bold">Deep Dive: {data.decision} {data.symbol}</h2>
                    </div>
                    <button onClick={onClose} className="text-gray-400 hover:text-white">
                        <X size={24} />
                    </button>
                </div>

                {/* Content */}
                <div className="p-4 space-y-4 overflow-y-auto">
                    {/* Situation Section */}
                    <DataSection title="Situation at Time of Decision">
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                               <DataRow label="Macro Regime" value={<Badge variant={data.context.macro.regime === 'Risk-On' ? 'success' : 'destructive'}>{data.context.macro.regime}</Badge>} />
                               <DataRow label="Macro Score" value={data.context.macro.score.toFixed(1)} />
                            </div>
                             <div>
                               <DataRow label="Sentiment" value={<Badge variant={data.context.sentiment.mood === 'Bullish' ? 'success' : 'destructive'}>{data.context.sentiment.mood}</Badge>} />
                               <DataRow label="Sentiment Score" value={data.context.sentiment.score.toFixed(2)} />
                            </div>
                             <div>
                                <DataRow label="Technical Score" value={data.context.technicals.score.toFixed(1)} />
                                <p className="text-xs text-gray-400 mt-1">{data.context.technicals.summary}</p>
                            </div>
                        </div>
                    </DataSection>

                    {/* Consultation Section */}
                    {data.consultation && (
                         <DataSection title="Agent Consultation (Debate)">
                            <div className="bg-gray-900 p-2 rounded">
                                <p className="text-xs text-blue-300 font-semibold">RiskManager asked MacroAnalyst:</p>
                                <p className="text-sm italic">"{data.consultation.question}"</p>
                            </div>
                             <div className="bg-gray-900 p-2 rounded mt-2">
                                <p className="text-xs text-green-300 font-semibold">MacroAnalyst answered:</p>
                                <p className="text-sm">"{data.consultation.answer}"</p>
                            </div>
                        </DataSection>
                    )}

                     {/* Memory Section */}
                    {data.pastLessons && data.pastLessons.length > 0 && (
                         <DataSection title="Past Lessons (From Vector Memory)">
                            <ul className="list-disc list-inside space-y-1 text-xs text-gray-300">
                                {data.pastLessons.map((lesson, i) => <li key={i}>{lesson}</li>)}
                            </ul>
                        </DataSection>
                    )}
                </div>
                 {/* Footer */}
                <div className="p-4 border-t border-gray-700 mt-auto">
                    <div className="flex justify-between items-center text-lg">
                        <span className="text-gray-400">Final Outcome:</span>
                        <span className={`font-bold ${outcomeColor}`}>
                            {data.pnl >= 0 ? '+' : ''}€{data.pnl.toFixed(2)}
                        </span>
                    </div>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\dynamic-risk-display.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { AlertTriangle, ShieldCheck } from 'lucide-react';

export function DynamicRiskDisplay() {
    const { state } = useDashboard();
    const { adjustedConfig, sharedContext } = state;

    if (!adjustedConfig || !sharedContext) {
        return null; // Don't render if there's no adjustment
    }

    const isAggressive = sharedContext.regimeScore > 7.5;
    const isDefensive = sharedContext.regimeScore < 4.0;

    if (!isAggressive && !isDefensive) {
        return null; // No significant adjustment, don't render
    }

    const title = isAggressive ? "Aggressive Stance Adopted" : "Defensive Stance Adopted";
    const Icon = isAggressive ? AlertTriangle : ShieldCheck;
    const color = isAggressive ? "text-yellow-400" : "text-blue-400";
    const reason = isAggressive 
        ? `Market regime is highly favorable (Score: ${sharedContext.regimeScore.toFixed(1)}). Increasing risk exposure.`
        : `Market regime is unfavorable (Score: ${sharedContext.regimeScore.toFixed(1)}). Reducing risk exposure.`;

    return (
        <div className={`bg-gray-800 p-4 rounded-lg border-l-4 ${isAggressive ? 'border-yellow-400' : 'border-blue-400'}`}>
            <div className="flex items-center">
                <Icon size={24} className={`${color} mr-3`} />
                <div>
                    <h3 className={`text-lg font-semibold ${color}`}>{title}</h3>
                    <p className="text-sm text-gray-300">{reason}</p>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\GainersLosersCard.tsx ---
// src/components/GainersLosersCard.tsx

import { IntelCard } from './IntelCard';
import { ArrowUpRight, ArrowDownRight } from 'lucide-react';

interface Mover {
    symbol: string;
    quote: {
        USD: {
            percent_change_24h: number;
        }
    }
}

interface GainersLosersCardProps {
    movers: {
        gainers: Mover[] | null;
        losers: Mover[] | null;
    } | null;
}

const TickerList = ({ title, data, icon: Icon, colorClass }: { title: string, data: Mover[], icon: any, colorClass: string }) => (
    <div>
        <h3 className="font-semibold mb-2 flex items-center">
            <Icon size={18} className={`mr-2 ${colorClass}`} />
            {title}
        </h3>
        <ul className="space-y-2 text-sm">
            {data.map(item => (
                <li key={item.symbol} className="flex justify-between bg-gray-800 p-1.5 rounded">
                    <span className="font-bold">{item.symbol}</span>
                    <span className={colorClass}>{item.quote.USD.percent_change_24h.toFixed(1)}%</span>
                </li>
            ))}
        </ul>
    </div>
);

export function GainersLosersCard({ movers }: GainersLosersCardProps) {
    const hasData = movers && movers.gainers && movers.losers;

    return (
        <IntelCard title="Daily Movers" icon={ArrowUpRight} className="col-span-1 md:col-span-2">
            {!hasData ? (
                 <p className="text-gray-500 text-sm">Could not load daily movers data.</p>
            ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
                    <TickerList title="Top Gainers" data={movers.gainers!} icon={ArrowUpRight} colorClass="text-green-400" />
                    <TickerList title="Top Losers" data={movers.losers!} icon={ArrowDownRight} colorClass="text-red-400" />
                </div>
            )}
        </IntelCard>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\header.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { Power, Timer, Wallet, Menu } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dispatch, SetStateAction } from 'react';

interface HeaderProps {
    setSidebarOpen: Dispatch<SetStateAction<boolean>>;
}

export function Header({ setSidebarOpen }: HeaderProps) {
    const { state, dispatch } = useDashboard();

    const toggleBotStatus = async () => {
        const newStatus = state.botStatus === 'active' ? 'inactive' : 'active';
        try {
            const response = await fetch('/api/bot/status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: newStatus }),
            });
            if (response.ok) {
                dispatch({ type: 'SET_BOT_STATUS', payload: newStatus });
                dispatch({ type: 'ADD_LOG', payload: `Bot status set to ${newStatus}` });
            } else {
                dispatch({ type: 'ADD_LOG', payload: 'Error updating bot status' });
            }
        } catch {
            dispatch({ type: 'ADD_LOG', payload: 'Error updating bot status' });
        }
    };

    return (
        <header className="flex justify-between items-center p-4 bg-gray-900 text-white border-b border-gray-700">
            <div className="flex items-center">
                <button
                    onClick={() => setSidebarOpen(true)}
                    className="md:hidden mr-4 text-gray-400 hover:text-white"
                >
                    <Menu size={24} />
                </button>
                <h1 className="text-xl font-semibold hidden md:block">CryptoBot Dashboard</h1>
            </div>
            <div className="flex items-center space-x-2 md:space-x-6">
                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger>
                            <div className="flex items-center text-sm">
                                <Timer size={16} className="mr-2 text-gray-400" />
                                <span>Next cycle in: <strong>{state.nextCycleIn}</strong></span>
                            </div>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Time until the next automated trading cycle begins.</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>

                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger>
                            <div className="flex items-center text-sm">
                                <Wallet size={16} className="mr-2 text-gray-400" />
                                <span className="hidden sm:inline">Sandbox Balance: </span>
                                <strong className="ml-1">€{state.portfolio.balance.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</strong>
                            </div>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Your current virtual balance for simulated trading.</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>

                <button
                    onClick={toggleBotStatus}
                    className={`flex items-center px-4 py-2 rounded-md font-semibold text-sm transition-colors ${state.botStatus === 'active' 
                        ? 'bg-red-600 hover:bg-red-700 text-white' 
                        : 'bg-green-600 hover:bg-green-700 text-white'}`}
                >
                    <Power size={16} className="mr-2" />
                    {state.botStatus === 'active' ? 'Stop Bot' : 'Start Bot'}
                </button>
            </div>
        </header>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\HiveMindDisplay.tsx ---
// src/components/HiveMindDisplay.tsx

"use client";

import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Activity, Flame, Gauge, TrendingUp, HelpCircle } from 'lucide-react';

// This is mock data that simulates the full context object.
// Later, it will be replaced by `useDashboard` state.
const mockContext = {
    marketRegime: 'Risk-On',
    regimeScore: 7.8,
    sentiment: 'Bullish',
    sentimentScore: 0.6,
    fearAndGreed: { value: 72, classification: 'Greed' },
    btcDominance: 45.8,
    totalMarketCap: 2.1, // In trillions
    dominantNarrative: 'AI Tokens',
};

const RegimeBadge = ({ regime }: { regime: string }) => {
    const color = regime === 'Risk-On' ? 'bg-green-600' : regime === 'Risk-Off' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{regime.replace('-', ' ')}</Badge>;
};

const SentimentBadge = ({ sentiment }: { sentiment: string }) => {
    const color = sentiment === 'Bullish' ? 'bg-green-600' : sentiment === 'Bearish' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{sentiment}</Badge>;
};

const InfoRow = ({ label, children }: { label: string, children: React.ReactNode }) => (
    <div className="flex justify-between items-center text-sm py-2 border-b border-gray-800 last:border-none">
        <span className="text-gray-400 flex items-center">
            {label}
        </span>
        <span className="font-semibold">{children}</span>
    </div>
);

export function HiveMindDisplay() {
    // In the future, we will use the real context from the dashboard state:
    // const { state } = useDashboard();
    // const context = state.sharedContext;
    // if (!context) return <div>Loading Hive Mind...</div>;
    
    const context = mockContext; // Using mock data for now

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Macro Environment Card */}
            <div className="bg-gray-800 p-4 rounded-lg">
                <h3 className="font-semibold mb-2 flex items-center">
                    <Activity size={18} className="mr-2 text-gray-400" />
                    Macro Environment
                </h3>
                <div className="space-y-1">
                    <InfoRow label="Market Regime">
                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger>
                                    <RegimeBadge regime={context.marketRegime} />
                                </TooltipTrigger>
                                <TooltipContent><p>Score: {context.regimeScore.toFixed(1)} / 10.0</p></TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    </InfoRow>
                    <InfoRow label="Total Market Cap">
                        <span className="flex items-center">
                            ${context.totalMarketCap.toFixed(1)}T
                            <TrendingUp size={14} className="ml-1 text-green-500" />
                        </span>
                    </InfoRow>
                    <InfoRow label="BTC Dominance">
                         <span className="flex items-center">
                            {context.btcDominance.toFixed(1)}%
                            <TrendingUp size={14} className="ml-1 text-red-500" />
                        </span>
                    </InfoRow>
                </div>
            </div>

            {/* Market Sentiment Card */}
            <div className="bg-gray-800 p-4 rounded-lg">
                 <h3 className="font-semibold mb-2 flex items-center">
                    <Flame size={18} className="mr-2 text-gray-400" />
                    Market Sentiment
                </h3>
                <div className="space-y-1">
                    <InfoRow label="Overall Sentiment">
                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger>
                                     <SentimentBadge sentiment={context.sentiment} />
                                </TooltipTrigger>
                                <TooltipContent><p>Score: {context.sentimentScore.toFixed(2)} / 1.0</p></TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    </InfoRow>
                    <InfoRow label="Fear & Greed Index">
                        <span className="flex items-center text-yellow-400">
                           <Gauge size={14} className="mr-1.5" />
                           {context.fearAndGreed.value} - {context.fearAndGreed.classification}
                        </span>
                    </InfoRow>
                     <InfoRow label="Dominant Narrative">
                        <span>{context.dominantNarrative}</span>
                    </InfoRow>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\IntelCard.tsx ---
// src/components/IntelCard.tsx

import { ReactNode } from 'react';
import { LucideIcon } from 'lucide-react';

interface IntelCardProps {
    title: string;
    icon: LucideIcon;
    children: ReactNode;
    className?: string;
}

export function IntelCard({ title, icon: Icon, children, className = '' }: IntelCardProps) {
    return (
        <div className={`bg-gray-900 text-white p-4 rounded-lg ${className}`}>
            <div className="flex items-center mb-4">
                <Icon size={20} className="text-blue-400 mr-3" />
                <h2 className="font-bold text-lg">{title}</h2>
            </div>
            <div className="space-y-4">
                {children}
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\kpi-card.tsx ---
"use client";

import { ReactNode, useMemo, useEffect, useState } from 'react';
import { useDashboard } from '@/context/DashboardContext';

interface KpiCardProps {
    title: string;
    icon: ReactNode;
    kpiKey?: 'totalValue' | '24h_pnl' | 'freeCollateral';
    value?: string | number;
    color?: string;
}

export function KpiCard({ title, icon, kpiKey, value, color: propColor }: KpiCardProps) {
    const { state } = useDashboard();
    const { portfolio, marketData } = state;
    const [tradeHistory, setTradeHistory] = useState([]);

    useEffect(() => {
        async function fetchTradeHistory() {
            try {
                const response = await fetch('/api/history');
                const data = await response.json();
                setTradeHistory(data);
            } catch (error) {
                console.error("Failed to fetch trade history:", error);
            }
        }
        fetchTradeHistory();
        const interval = setInterval(fetchTradeHistory, 10000); // Refetch every 10 seconds
        return () => clearInterval(interval);
    }, []);

    const kpiValue = useMemo(() => {
        if (value !== undefined) return value;
        if (!portfolio || !kpiKey) return 0;

        const positionsValue = portfolio.positions.reduce((acc, pos) => {
            const marketInfo = marketData.find(md => md.symbol === pos.symbol);
            const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
            return acc + (currentPrice * pos.amount);
        }, 0);

        const totalValue = portfolio.balance + positionsValue;

        switch (kpiKey) {
            case 'totalValue':
                return totalValue;
            case 'freeCollateral':
                return portfolio.balance;
            case '24h_pnl':
                const now = new Date().getTime();
                const twentyFourHoursAgo = now - 24 * 60 * 60 * 1000;
                const pnl24h = tradeHistory.reduce((acc, trade) => {
                    const tradeTimestamp = new Date((trade as { timestamp: string }).timestamp).getTime();
                    if (tradeTimestamp > twentyFourHoursAgo) {
                        return acc + (trade as { pnl: number }).pnl;
                    }
                    return acc;
                }, 0);
                return pnl24h;
            default:
                return 0;
        }
    }, [portfolio, marketData, kpiKey, value, tradeHistory]);

    const formattedValue = typeof kpiValue === 'number' 
        ? `€${kpiValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
        : kpiValue;
    
    let color = propColor || 'text-white';
    if (kpiKey === '24h_pnl' && typeof kpiValue === 'number') {
        if (kpiValue > 0) color = 'text-green-400';
        if (kpiValue < 0) color = 'text-red-400';
    }

    return (
        <div className="bg-gray-900 p-4 rounded-lg flex items-center">
            <div className={`mr-4 ${color}`}>
                {icon}
            </div>
            <div>
                <p className="text-sm text-gray-400">{title}</p>
                <p className={`text-2xl font-bold ${color}`}>{formattedValue}</p>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\market-table.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { Ticker } from '@/core/binance';

export function MarketTable() {
    const { state, dispatch } = useDashboard();

    const handleRowClick = (symbol: string) => {
        dispatch({ type: 'SET_SELECTED_SYMBOL', payload: symbol });
    };

    return (
        <div className="bg-gray-900 text-white p-4 rounded-lg">
            <h2 className="font-bold text-lg mb-2">Market Scanner</h2>
            <div className="overflow-y-auto h-[70vh]">
                <table className="w-full text-left">
                    <thead>
                        <tr className="border-b border-gray-700">
                            <th className="p-2">Symbol</th>
                            <th className="p-2">Price</th>
                            <th className="p-2">Change (24h)</th>
                            <th className="p-2">Volume (24h)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {state.marketData.map((ticker: Ticker) => (
                            <tr 
                                key={ticker.symbol} 
                                className={`border-b border-gray-800 hover:bg-gray-700 cursor-pointer ${state.selectedSymbol === ticker.symbol ? 'bg-gray-700' : ''}`}
                                onClick={() => handleRowClick(ticker.symbol)}
                            >
                                <td className="p-2 font-bold">{ticker.symbol}</td>
                                <td className="p-2">${parseFloat(ticker.lastPrice).toFixed(2)}</td>
                                <td className={`p-2 ${parseFloat(ticker.priceChangePercent) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    {parseFloat(ticker.priceChangePercent).toFixed(2)}%
                                </td>
                                <td className="p-2">${(parseFloat(ticker.quoteVolume) / 1_000_000).toFixed(2)}M</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\news-feed.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { Rss } from 'lucide-react';

interface Article {
    title: string;
    url: string;
    source: { name: string };
    publishedAt: string;
}

export function NewsFeed() {
    const [articles, setArticles] = useState<Article[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchNews() {
            setIsLoading(true);
            try {
                const response = await fetch('/api/news');
                const data = await response.json();
                setArticles(data.articles || []);
            } catch (error) {
                console.error("Failed to fetch news", error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchNews();
    }, []);

    if (isLoading) {
        return <div className="text-center p-4">Loading news...</div>;
    }

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="text-lg font-semibold mb-4 flex items-center">
                <Rss size={20} className="mr-2" />
                Latest Crypto News
            </h2>
            <div className="space-y-4 max-h-96 overflow-y-auto">
                {articles.map((article, index) => (
                    <a 
                        key={index} 
                        href={article.url} 
                        target="_blank" 
                        rel="noopener noreferrer" 
                        className="block p-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors"
                    >
                        <p className="font-semibold">{article.title}</p>
                        <div className="flex justify-between items-center mt-2 text-xs text-gray-400">
                            <span>{article.source.name}</span>
                            <span>{new Date(article.publishedAt).toLocaleDateString()}</span>
                        </div>
                    </a>
                ))}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\opportunity-log.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { useDashboard } from '@/context/DashboardContext';
import { Opportunity } from '@/core/opportunity-scanner';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { PlayCircle } from 'lucide-react';

export function OpportunityLog() {
    const { state, dispatch } = useDashboard();
    const [isLoading, setIsLoading] = useState<string | null>(null);

    const handleAnalyze = async (symbol: string) => {
        setIsLoading(symbol);
        try {
            const response = await fetch('/api/bot/decision', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ symbol }),
            });
            if (!response.ok) {
                throw new Error('Failed to analyze opportunity.');
            }
            // The dashboard context will update the opportunities list automatically
            // through its polling mechanism.
        } catch (error) {
            console.error("Analysis error:", error);
        } finally {
            setIsLoading(null);
        }
    };

    const getStatusVariant = (status: Opportunity['status']) => {
        switch (status) {
            case 'bought': return 'success';
            case 'ignored': return 'destructive';
            case 'analyzing': return 'secondary';
            default: return 'default';
        }
    };

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="font-semibold text-md mb-4">Opportunity Log (Fast Movers)</h2>
            <div className="space-y-3">
                {state.opportunities.length === 0 ? (
                    <p className="text-gray-400 text-sm">No significant price movements detected recently.</p>
                ) : (
                    state.opportunities.slice(0, 10).map((opp) => (
                        <div key={opp.timestamp} className="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                            <div>
                                <p className="font-bold">{opp.symbol}</p>
                                <p className={`text-sm ${opp.priceChangePercent && opp.priceChangePercent > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    +{ (opp.priceChangePercent || 0).toFixed(2) }%
                                </p>
                                <p className="text-xs text-gray-400">{new Date(opp.timestamp).toLocaleTimeString()}</p>
                            </div>
                            <div className="flex items-center space-x-2">
                                <Badge variant={getStatusVariant(opp.status)}>{opp.status}</Badge>
                                {opp.status === 'detected' && (
                                    <Button 
                                        size="sm" 
                                        onClick={() => handleAnalyze(opp.symbol)}
                                        disabled={isLoading === opp.symbol}
                                    >
                                        <PlayCircle size={16} />
                                        <span className="ml-2">{isLoading === opp.symbol ? 'Analyzing...' : 'Analyze'}</span>
                                    </Button>
                                )}
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\sidebar.tsx ---
// src/components/sidebar.tsx

"use client";

import Link from 'next/link';
import { usePathname } from 'next/navigation';
// 1. A new icon is imported for the new navigation item
import { Bot, Settings, BarChart, Wallet, LineChart, FlaskConical, History, X, Radar } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dispatch, SetStateAction } from 'react';

// 2. The navItems array is updated with the new "Market Intelligence" page
const navItems = [
    { href: '/dashboard', icon: BarChart, label: 'Dashboard', tooltip: 'View key performance indicators and market data.' },
    { href: '/dashboard/intel', icon: Radar, label: 'Market Intelligence', tooltip: 'The hub for deep market analysis and intel.' },
    { href: '/dashboard/portfolio', icon: Wallet, label: 'Portfolio', tooltip: 'Manage your open positions and view your balance.' },
    { href: '/dashboard/history', icon: History, label: 'History', tooltip: 'View your past trade history.' },
    { href: '/dashboard/backtest', icon: FlaskConical, label: 'Backtesting', tooltip: 'Test your strategies against historical data.' },
    { href: '/dashboard/optimization', icon: LineChart, label: 'Optimization', tooltip: 'Optimize your strategy parameters for better performance.' },
    { href: '/dashboard/settings', icon: Settings, label: 'Settings', tooltip: 'Configure your trading bot and strategies.' },
];

interface SidebarProps {
    sidebarOpen: boolean;
    setSidebarOpen: Dispatch<SetStateAction<boolean>>;
}

export function Sidebar({ sidebarOpen, setSidebarOpen }: SidebarProps) {
    const pathname = usePathname();

    return (
        <>
            {/* Mobile Sidebar */}
            <div className={`fixed inset-0 z-40 flex md:hidden ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'} transition-transform duration-300 ease-in-out`}>
                <div className="w-64 bg-gray-900 text-white border-r border-gray-700 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-8">
                        <div className="flex items-center space-x-2">
                            <Bot size={28} className="text-blue-400" />
                            <h1 className="text-2xl font-bold">CryptoBot</h1>
                        </div>
                        <button onClick={() => setSidebarOpen(false)} className="text-gray-400 hover:text-white">
                            <X size={24} />
                        </button>
                    </div>
                    <nav className="flex-grow space-y-2">
                        {navItems.map((item) => (
                            <Link
                                key={item.href}
                                href={item.href}
                                onClick={() => setSidebarOpen(false)}
                                className={`flex items-center p-3 rounded-lg transition-colors ${
                                    pathname === item.href
                                        ? 'bg-blue-600 text-white'
                                        : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                                }`}
                            >
                                <item.icon className="mr-4" size={20} />
                                <span className="font-medium">{item.label}</span>
                            </Link>
                        ))}
                    </nav>
                    <div className="mt-auto">
                        <p className="text-xs text-gray-500">© 2025 CryptoBot Inc.</p>
                    </div>
                </div>
                <div className="flex-shrink-0 w-14" onClick={() => setSidebarOpen(false)}></div>
            </div>

            {/* Desktop Sidebar */}
            <div className="hidden md:flex md:flex-shrink-0">
                <div className="w-64 flex flex-col p-4 bg-gray-900 text-white border-r border-gray-700">
                    <div className="mb-8 flex items-center space-x-2">
                        <Bot size={28} className="text-blue-400" />
                        <h1 className="text-2xl font-bold">CryptoBot</h1>
                    </div>
                    <nav className="flex-grow space-y-2">
                        <TooltipProvider>
                            {navItems.map((item) => (
                                <Tooltip key={item.href}>
                                    <TooltipTrigger asChild>
                                        <Link
                                            href={item.href}
                                            className={`flex items-center p-3 rounded-lg transition-colors ${
                                                pathname === item.href
                                                    ? 'bg-blue-600 text-white'
                                                    : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                                            }`}
                                        >
                                            <item.icon className="mr-4" size={20} />
                                            <span className="font-medium">{item.label}</span>
                                        </Link>
                                    </TooltipTrigger>
                                    <TooltipContent side="right">
                                        <p>{item.tooltip}</p>
                                    </TooltipContent>
                                </Tooltip>
                            ))}
                        </TooltipProvider>
                    </nav>
                    <div className="mt-auto">
                        <p className="text-xs text-gray-500">© 2025 CryptoBot Inc.</p>
                    </div>
                </div>
            </div>
        </>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\TopNarrativesCard.tsx ---
// src/components/TopNarrativesCard.tsx

"use client";

import { IntelCard } from './IntelCard';
import { Layers, TrendingUp } from 'lucide-react';

interface Narrative {
    id: string;
    name: string;
    market_cap: number;
    market_cap_change_24h: number;
}

interface TopNarrativesCardProps {
    narratives: Narrative[] | null;
}

export function TopNarrativesCard({ narratives }: TopNarrativesCardProps) {
    return (
        <IntelCard title="Top Narratives" icon={Layers} className="col-span-1 md:col-span-2">
            <div className="overflow-x-auto">
                {!narratives || narratives.length === 0 ? (
                    <p className="text-gray-500 text-sm">Could not load narrative data.</p>
                ) : (
                    <table className="w-full text-left text-sm">
                        <thead>
                            <tr className="border-b border-gray-700">
                                <th className="p-2">Narrative / Sector</th>
                                <th className="p-2 text-right">Market Cap</th>
                                <th className="p-2 text-right">24h Change</th>
                            </tr>
                        </thead>
                        <tbody>
                            {narratives.map((narrative) => (
                                <tr key={narrative.id} className="border-b border-gray-800 hover:bg-gray-800 cursor-pointer">
                                    <td className="p-2 font-semibold">{narrative.name}</td>
                                    <td className="p-2 text-right">${(narrative.market_cap / 1_000_000_000).toFixed(2)}B</td>
                                    <td className={`p-2 text-right flex justify-end items-center ${narrative.market_cap_change_24h >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        <TrendingUp size={14} className="mr-1" />
                                        {narrative.market_cap_change_24h.toFixed(1)}%
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        </IntelCard>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\badge.tsx ---
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success: "border-transparent bg-green-500 text-white",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\button.tsx ---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\scroll-area.tsx ---
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Scrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Scrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.Scrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-gray-700" />
  </ScrollAreaPrimitive.Scrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.Scrollbar.displayName

export { ScrollArea, ScrollBar }

--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\tooltip.tsx ---
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

--- END FILE: {relative_filepath} ---

--- FILE: src\context\DashboardContext.tsx ---
"use client";

import { createContext, useContext, useReducer, ReactNode, useEffect, useRef, useState } from 'react';
import { Ticker } from '@/core/binance';
import { ISharedContext } from '@/core/context';
import { Opportunity } from '@/core/opportunity-scanner';
import toast from 'react-hot-toast';

// --- STATE AND TYPES ---
interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

interface BinanceTickerEvent {
    s: string; // Symbol
    c: string; // Last price
    P: string; // Price change percent
    q: string; // Quote volume
}

export interface AiChat {
    agent: string;
    prompt: string;
    response: Record<string, unknown>;
}

// More specific type for analysis data
interface Analysis {
    [key: string]: unknown;
}

interface DashboardState {
    logs: string[];
    marketData: Ticker[];
    portfolio: Portfolio;
    isLoading: boolean;
    selectedSymbol: string;
    analysis: Analysis | null;
    botStatus: 'active' | 'inactive';
    aiChat: AiChat[];
    nextCycleIn: string;
    lastRunAnalysis: Analysis | null;
    sharedContext: ISharedContext | null;
    adjustedConfig: Config | null;
    opportunities: Opportunity[];
}

type Action =
    | { type: 'ADD_LOG'; payload: string }
    | { type: 'ADD_AI_CHAT'; payload: AiChat }
    | { type: 'SET_MARKET_DATA'; payload: Ticker[] }
    | { type: 'UPDATE_MARKET_PRICES'; payload: Ticker[] }
    | { type: 'SET_PORTFOLIO'; payload: Portfolio }
    | { type: 'SET_LOADING'; payload: boolean }
    | { type: 'SET_SELECTED_SYMBOL'; payload: string }
    | { type: 'SET_ANALYSIS'; payload: Analysis | null }
    | { type: 'SET_BOT_STATUS'; payload: 'active' | 'inactive' }
    | { type: 'SET_TIMER'; payload: string }
    | { type: 'SET_LAST_RUN_ANALYSIS'; payload: Analysis | null }
    | { type: 'SET_SHARED_CONTEXT'; payload: ISharedContext }
    | { type: 'SET_ADJUSTED_CONFIG'; payload: Config }
    | { type: 'SET_OPPORTUNITIES'; payload: Opportunity[] };

const initialState: DashboardState = {
    logs: [],
    aiChat: [],
    marketData: [],
    portfolio: { balance: 0, positions: [] },
    isLoading: true,
    selectedSymbol: 'BTCUSDT',
    analysis: null,
    botStatus: 'inactive',
    nextCycleIn: 'N/A',
    lastRunAnalysis: null,
    sharedContext: null,
    adjustedConfig: null,
    opportunities: [],
};

// --- REDUCER ---
function dashboardReducer(state: DashboardState, action: Action): DashboardState {
    switch (action.type) {
        case 'ADD_LOG':
            const newLogs = [...state.logs, `[${new Date().toLocaleTimeString()}] ${action.payload}`];
            return { ...state, logs: newLogs.slice(-100) };
        case 'ADD_AI_CHAT':
            const newChats = [...state.aiChat, action.payload];
            return { ...state, aiChat: newChats.slice(-100) };
        case 'SET_MARKET_DATA':
            // console.log('[DashboardReducer] SET_MARKET_DATA payload:', action.payload.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
            return { ...state, marketData: action.payload };
        case 'UPDATE_MARKET_PRICES':
            // console.log('[DashboardReducer] UPDATE_MARKET_PRICES payload:', action.payload.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
            const updatedMarketData = state.marketData.map(ticker => {
                const update = action.payload.find(u => u.symbol === ticker.symbol);
                return update ? { ...ticker, ...update } : ticker;
            });
            // console.log('[DashboardReducer] UPDATE_MARKET_PRICES new state.marketData:', updatedMarketData.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
            return { ...state, marketData: updatedMarketData };
        case 'SET_PORTFOLIO':
            return { ...state, portfolio: action.payload };
        case 'SET_LOADING':
            return { ...state, isLoading: action.payload };
        case 'SET_SELECTED_SYMBOL':
            return { ...state, selectedSymbol: action.payload };
        case 'SET_ANALYSIS':
            return { ...state, analysis: action.payload };
        case 'SET_BOT_STATUS':
            return { ...state, botStatus: action.payload };
        case 'SET_TIMER':
            return { ...state, nextCycleIn: action.payload };
        case 'SET_LAST_RUN_ANALYSIS':
            return { ...state, lastRunAnalysis: action.payload };
        case 'SET_SHARED_CONTEXT':
            return { ...state, sharedContext: action.payload };
        case 'SET_ADJUSTED_CONFIG':
            return { ...state, adjustedConfig: action.payload };
        case 'SET_OPPORTUNITIES':
            // To avoid re-rendering the entire list every time, we can be a bit smarter
            // and only update if the data has actually changed.
            if (JSON.stringify(state.opportunities) !== JSON.stringify(action.payload)) {
                return { ...state, opportunities: action.payload };
            }
            return state;
        default:
            return state;
    }
}

// --- CONTEXT ---
const DashboardContext = createContext<{ state: DashboardState; dispatch: React.Dispatch<Action>; } | undefined>(undefined);

// --- PROVIDER ---
interface Config {
    cycleIntervalMinutes: number;
    [key: string]: unknown;
}

export function DashboardProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(dashboardReducer, initialState);
    const [config, setConfig] = useState<Config | null>(null);
    const timerIdRef = useRef<NodeJS.Timeout | null>(null);
    const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const isCycleRunningRef = useRef(false);

    useEffect(() => {
        async function fetchInitialData() {
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_MARKET_DATA', payload: data.marketData });
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch initial dashboard data:", error);
            }
        }

        fetchInitialData();

        const eventSource = new EventSource('/api/market-stream');
        
        eventSource.onmessage = (event) => {
            try {
                const data: BinanceTickerEvent[] = JSON.parse(event.data);
                // Log raw data for debugging
                // console.log('[DashboardContext] Raw market stream data:', data.map(d => ({ s: d.s, c: d.c })));

                const transformedData: Ticker[] = data.map((item) => ({
                    symbol: item.s,
                    lastPrice: item.c,
                    priceChangePercent: item.P,
                    quoteVolume: item.q,
                    // --- Adding dummy data to satisfy the Ticker type ---
                    priceChange: '',
                    weightedAvgPrice: '',
                    prevClosePrice: '',
                    lastQty: '',
                    bidPrice: '',
                    bidQty: '',
                    askPrice: '',
                    askQty: '',
                    openPrice: '',
                    highPrice: '',
                    lowPrice: '',
                    volume: '',
                    openTime: 0,
                    closeTime: 0,
                    firstId: 0,
                    lastId: 0,
                    count: 0,
                }));
                // Log transformed data for debugging
                // console.log('[DashboardContext] Transformed market stream data:', transformedData.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
                dispatch({ type: 'UPDATE_MARKET_PRICES', payload: transformedData });
            } catch (error) {
                console.error("Failed to parse market stream data:", error);
            }
        };

        eventSource.onerror = (error) => {
            console.error('EventSource failed:', error);
            dispatch({ type: 'ADD_LOG', payload: 'Market data stream disconnected.' });
            eventSource.close();
        };

        const portfolioInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch updated portfolio data:", error);
            }
        }, 1000);

        const opportunityInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/opportunities');
                if (!response.ok) throw new Error('Failed to fetch opportunities');
                const data = await response.json();
                dispatch({ type: 'SET_OPPORTUNITIES', payload: data });
            } catch (error) {
                // This can fail if the file doesn't exist yet, which is fine.
            }
        }, 2000); // Poll every 2 seconds for responsiveness

        return () => {
            eventSource.close();
            clearInterval(portfolioInterval);
            clearInterval(opportunityInterval);
        };
    }, []);

    useEffect(() => {
        async function fetchConfig() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                setConfig(data);
            } catch {
                console.error("Failed to fetch config");
            }
        }
        fetchConfig();
    }, []);

    const CYCLE_INTERVAL = (config?.cycleIntervalMinutes || 20) * 60 * 1000;

    const runCycle = async () => {
        if (isCycleRunningRef.current) {
            dispatch({ type: 'ADD_LOG', payload: 'Cycle already in progress. Skipping.' });
            return;
        }
        isCycleRunningRef.current = true;
        dispatch({ type: 'ADD_LOG', payload: 'Bot cycle started... Attempting to fetch API.' });

        try {
            const res = await fetch('/api/bot/run');
            dispatch({ type: 'ADD_LOG', payload: `API response received. Status: ${res.status}` });

            if (!res.ok || !res.body) {
                const errorText = await res.text();
                dispatch({ type: 'ADD_LOG', payload: `API Error: Response not OK or no body. Details: ${errorText}` });
                throw new Error(`API request failed with status ${res.status}`);
            }
            
            dispatch({ type: 'ADD_LOG', payload: 'Response body is valid. Starting to read stream...' });
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            const currentAnalysis: Analysis = {};

            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    dispatch({ type: 'ADD_LOG', payload: 'Bot cycle finished.' });
                    dispatch({ type: 'SET_LAST_RUN_ANALYSIS', payload: currentAnalysis });
                    break;
                }
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
                for (const line of lines) {
                    try {
                        const json = JSON.parse(line.replace('data: ', ''));
                        const { type, message, data } = json;
                        if (type === 'log') {
                            if (message.startsWith('BOUGHT') || message.startsWith('SOLD')) {
                                toast.success(message);
                            }
                            dispatch({ type: 'ADD_LOG', payload: message });
                        } else if (type === 'analysis') {
                            dispatch({ type: 'SET_ANALYSIS', payload: data });
                        } else if (type === 'context') {
                            dispatch({ type: 'SET_SHARED_CONTEXT', payload: data });
                        } else if (type === 'adjusted_config') {
                            dispatch({ type: 'SET_ADJUSTED_CONFIG', payload: data });
                        } else if (type === 'aiChat' && data) {
                            dispatch({ type: 'ADD_AI_CHAT', payload: data });
                            if (data.agent.startsWith('PortfolioAllocator')) {
                                currentAnalysis.PortfolioAllocator = data;
                            }
                        }
                    } catch {
                        dispatch({ type: 'ADD_LOG', payload: 'Failed to parse stream data.' });
                    }
                }
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            dispatch({ type: 'ADD_LOG', payload: `[CYCLE ERROR] ${errorMessage}` });
        } finally {
            isCycleRunningRef.current = false;
            // Fetch the latest portfolio data after a cycle run
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch updated portfolio data:", error);
            }

            if (state.botStatus === 'active') {
                scheduleNextCycle();
            }
        }
    };

    const scheduleNextCycle = (immediate = false) => {
        if (timerIdRef.current) clearTimeout(timerIdRef.current);
        if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);

        if (immediate) {
            runCycle();
            return;
        }

        let timeLeft = CYCLE_INTERVAL;
        const updateTimer = () => {
            if (timeLeft <= 0) {
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
                return;
            }
            timeLeft -= 1000;
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.round((timeLeft % 60000) / 1000);
            dispatch({ type: 'SET_TIMER', payload: `${minutes}:${seconds < 10 ? '0' : ''}${seconds}` });
        };
        
        updateTimer();
        timerIntervalRef.current = setInterval(updateTimer, 1000);
        timerIdRef.current = setTimeout(runCycle, CYCLE_INTERVAL);
    };

    useEffect(() => {
        if (state.botStatus === 'active') {
            dispatch({ type: 'ADD_LOG', payload: "Bot activated. Starting first cycle immediately..." });
            scheduleNextCycle(true);
        } else {
            dispatch({ type: 'ADD_LOG', payload: "Bot stopped." });
            if (timerIdRef.current) clearTimeout(timerIdRef.current);
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
            dispatch({ type: 'SET_TIMER', payload: 'N/A' });
        }

        return () => {
            if (timerIdRef.current) clearTimeout(timerIdRef.current);
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [state.botStatus]);

    return (
        <DashboardContext.Provider value={{ state, dispatch }}>
            {children}
        </DashboardContext.Provider>
    );
}

// --- HOOK ---
export function useDashboard() {
    const context = useContext(DashboardContext);
    if (context === undefined) {
        throw new Error('useDashboard must be used within a DashboardProvider');
    }
    return context;
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\agent-service.ts ---
// src/core/agent-service.ts

import { AIAgent } from './agents';

/**
 * AgentService veikia kaip centrinis registras ir komunikacijos tarpininkas visiems DI agentams.
 * Tai leidžia agentams dinamiškai atrasti vienas kitą ir bendradarbiauti.
 */
export class AgentService {
    // Privatus registras, saugantis visas agentų instancijas pagal jų vardus.
    private agents: Map<string, AIAgent> = new Map();

    /**
     * Užregistruoja agento instanciją tarnyboje, kad kiti agentai galėtų ją rasti.
     * @param agent Agentas, kurį reikia užregistruoti.
     */
    public register(agent: AIAgent): void {
        console.log(`[AgentService] Registering agent: ${agent.name}`);
        this.agents.set(agent.name, agent);
    }

    /**
     * Suranda ir grąžina agento instanciją pagal vardą.
     * @param name Agento vardas.
     * @returns Agento instancija arba undefined, jei nerasta.
     */
    public getAgent(name: string): AIAgent | undefined {
        return this.agents.get(name);
    }

    /**
     * Pagrindinis komunikacijos metodas, leidžiantis vienam agentui konsultuotis su kitu.
     * @param targetAgentName Agento, su kuriuo norima konsultuotis, vardas.
     * @param query Užklausa tekstiniu formatu.
     * @param callingAgentName Agento, kuris inicijuoja konsultaciją, vardas.
     * @returns Atsakymas iš pasikonsultuoto agento.
     */
    public async consult(targetAgentName: string, query: string, callingAgentName: string): Promise<any> {
        const agent = this.getAgent(targetAgentName);
        if (!agent) {
            const errorMessage = `[AgentService] Consultation failed: Agent '${targetAgentName}' not found.`;
            console.error(errorMessage);
            return { error: errorMessage };
        }

        console.log(`[AgentService] Agent '${callingAgentName}' is consulting '${targetAgentName}' with query: "${query}"`);
        // Iškviečiame specialų tikslinio agento metodą, skirtą atsakyti į užklausas.
        return agent.handleConsultation(query, callingAgentName);
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\agents.ts ---
// src/core/agents.ts

import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold, GenerativeModel } from "@google/generative-ai";
import { Candle } from "./binance";
import { SharedContext } from "./context";
import { calculateRSI, calculateMACD, calculateSMAExported } from "./indicators";
import { AgentService } from './agent-service';
import { MemoryService } from "./memory";
import fs from 'fs/promises';
import path from 'path';

class KeyRotator {
    private keys: string[];
    public currentIndex: number;

    constructor() {
        this.keys = process.env.GEMINI_API_KEYS?.split(',') || [];
        if (this.keys.length === 0) {
            throw new Error("GEMINI_API_KEYS not found or empty in .env.local");
        }
        this.currentIndex = 0;
    }

    getKey(): string { return this.keys[this.currentIndex]; }
    getNextKey(): string {
        this.currentIndex = (this.currentIndex + 1) % this.keys.length;
        console.warn(`Switching Gemini API key to #${this.currentIndex}`);
        return this.getKey();
    }
}

export abstract class AIAgent {
    private keyRotator: KeyRotator;
    private genAI: GoogleGenerativeAI;
    protected model: GenerativeModel;
    public readonly name: string;
    protected agentService: AgentService;

    constructor(name: string, agentService: AgentService) {
        if (!name || !agentService) {
            throw new Error("AIAgent requires a name and AgentService instance.");
        }
        this.name = name;
        this.agentService = agentService;
        const modelName = process.env.GEMINI_MODEL_NAME || 'gemini-1.5-flash';
        this.keyRotator = new KeyRotator();
        this.genAI = new GoogleGenerativeAI(this.keyRotator.getKey());
        this.model = this.genAI.getGenerativeModel({ model: modelName });
    }

    private reinitializeModel() {
        this.genAI = new GoogleGenerativeAI(this.keyRotator.getKey());
        this.model = this.genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
    }

    async safeGenerate(prompt: string, retries = 3): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                const safetySettings = [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE }, ];
                const result = await this.model.generateContent({ contents: [{ role: "user", parts: [{ text: prompt }] }], safetySettings, });
                const response = result.response;
                let jsonText = response.text().replace(/```json/g, "").replace(/```/g, "").trim();
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');
                if (firstBrace === -1 || lastBrace === -1) { throw new Error("No valid JSON object found in the response."); }
                jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                const jsonResponse = JSON.parse(jsonText) as Record<string, unknown>;
                return { prompt, response: jsonResponse };
            } catch (error) {
                const errorMessage = (error as Error).message;
                if (errorMessage.includes('429') || errorMessage.includes('Too Many Requests') || errorMessage.includes('RESOURCE_EXHAUSTED') || errorMessage.includes('quota')) {
                    this.keyRotator.getNextKey();
                    this.reinitializeModel();
                    if (attempt < retries - 1) { await new Promise(resolve => setTimeout(resolve, 2000)); continue; } 
                    else { return null; }
                }
                return null;
            }
        }
        return null;
    }
    
    protected async consult(targetAgentName: string, query: string): Promise<any> {
        const agent = this.agentService.getAgent(targetAgentName);
        if (!agent) { return { error: `Agent ${targetAgentName} not found.` }; }
        return agent.handleConsultation(query, this.name);
    }
    
    public async handleConsultation(query: string, callingAgentName: string): Promise<any> {
        const prompt = `
        **Persona:** You are ${this.name}, an expert in your domain.
        **Context:** The agent '${callingAgentName}' is requesting your expert opinion.
        **Query:** "${query}"
        **Task:** Provide a concise, direct, and expert answer to the query in JSON format, under the key "response".
        `;
        const result = await this.safeGenerate(prompt);
        return result?.response;
    }
}

export class MacroAnalyst extends AIAgent {
    constructor(agentService: AgentService) {
        super('MacroAnalyst', agentService);
    }
    
    async analyze(btcData: Record<string, unknown>, newsHeadlines: string[], fearAndGreedIndex: { value: string; classification: string } | null, globalMetrics: any, sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Macroeconomic and Crypto Market Cycle Analyst. Your task is to assess the overall market environment to determine if it's safe to take on risk.
        **Data Provided:**
        1.  **Bitcoin (4H TF) Last Candle:** ${JSON.stringify(btcData)}
        2.  **Top News Headlines:** ${JSON.stringify(newsHeadlines)}
        3.  **CoinMarketCap Fear and Greed Index:** ${JSON.stringify(fearAndGreedIndex)}
        4.  **Global Market Metrics:** ${JSON.stringify(globalMetrics)}
        **Task:** Provide a critical market assessment in JSON format.
        - \`market_regime\`: "Risk-On" (favorable for risky assets like altcoins) or "Risk-Off" (avoid risk, preserve capital).
        - \`regime_score\`: A number from 0.0 (extreme fear/danger) to 10.0 (extreme greed/opportunity).
        - \`reasoning\`: A brief explanation of why you chose this regime, referencing specific data points from the Global Metrics and Fear/Greed Index.
        - \`summary\`: A one-sentence, actionable summary for the portfolio manager.
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const { market_regime, regime_score } = result.response;
            if (typeof market_regime === 'string' && (market_regime === 'Risk-On' || market_regime === 'Risk-Off') && typeof regime_score === 'number') {
                sharedContext.updateContext({
                    marketRegime: market_regime,
                    regimeScore: regime_score
                });
            }
        }
        return result;
    }
}

export class SentimentAnalyst extends AIAgent {
    constructor(agentService: AgentService) {
        super('SentimentAnalyst', agentService);
    }
    
    async analyze(newsArticles: { title?: string }[], trendingTokens: any, sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const headlines = newsArticles.map(article => article.title || '');
        const prompt = `
        **Persona:** You are an AI that analyzes text sentiment and social hype. You measure the emotional state of the market.
        **Data Provided:**
        1.  **General News Headlines:** ${JSON.stringify(headlines.slice(0, 10))}
        2.  **Community Trending Tokens:** ${JSON.stringify(trendingTokens)}
        **Task:** Evaluate the overall sentiment from the provided data and provide a structured analysis in JSON format.
        - \`sentiment\`: "Bullish", "Bearish", or "Neutral".
        - \`sentiment_score\`: A number from -1.0 (extremely negative) to 1.0 (extremely positive).
        - \`dominant_narrative\`: A short phrase describing the main story in the news AND what the community is focused on.
        - \`key_topics\`: An array of key topics driving the narrative.
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const { sentiment, sentiment_score, key_topics, dominant_narrative } = result.response;
            if (typeof sentiment === 'string' && typeof sentiment_score === 'number' && Array.isArray(key_topics)) {
                sharedContext.updateContext({
                    sentiment: sentiment as any,
                    sentimentScore: sentiment_score,
                    keyTopics: key_topics as string[],
                    // @ts-ignore 
                    dominantNarrative: dominant_narrative as string,
                });
            }
        }
        return result;
    }
}

interface Position { symbol: string; amount: number; entryPrice: number; highPrice?: number; takeProfitPercent?: number; technicals?: Record<string, unknown>; }
interface Config { [key: string]: any; }
interface DecisionHistory { timestamp: string; decision: string; justification: string; }

export class PositionManager extends AIAgent {
    constructor(agentService: AgentService) {
        super('PositionManager', agentService);
    }
    
    async decide(position: Position, currentPrice: number, macroAnalysis: unknown, sentimentAnalysis: unknown, config: Config, decisionHistory: DecisionHistory[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const pnlPercent = (currentPrice - position.entryPrice) / position.entryPrice * 100;
        const prompt = `
        **Persona:** You are a professional, stateful trader managing a profitable position. Your goal is to maximize gains while intelligently protecting profits.
        **Current Context:**
        - **Position:** ${JSON.stringify(position, null, 2)}
        - **Current Price:** ${currentPrice}
        - **Current P/L (%):** ${pnlPercent.toFixed(2)}%
        - **Take-Profit Target (%):** ${position.takeProfitPercent || config.takeProfitPercent}%
        - **Macro Environment:** ${JSON.stringify(macroAnalysis, null, 2)}
        - **Market Sentiment:** ${JSON.stringify(sentimentAnalysis, null, 2)}
        **Task:** The position has reached its take-profit target. Decide whether to sell now or to let the profit run by increasing the take-profit target. Be a disciplined profit-taker, not a greedy gambler.
        **Format (JSON):**
        - \`decision\`: "SELL_NOW" or "HOLD_AND_INCREASE_TP".
        - \`new_take_profit_percent\`: (Only if holding) The new take-profit percentage (e.g., if current is ${config.takeProfitPercent}%, new could be ${config.takeProfitPercent + 2}%).
        - \`justification\`: A brief reason for your decision.
        `;
        return await this.safeGenerate(prompt);
    }
}

interface BuySignal { symbol: string; [key: string]: unknown; }
interface Portfolio { balance: number; positions: Position[]; }

export class PortfolioAllocator extends AIAgent {
    constructor(agentService: AgentService) { super('PortfolioAllocator', agentService); }
    async allocate(buySignals: BuySignal[], portfolio: Portfolio, macroAnalysis: unknown, sentimentAnalysis: unknown, sharedContext: SharedContext, narrativeContext?: { narrative: string; assets: string[] }, dexOpportunities?: string[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        let strategicPrioritySection = "No dominant narrative identified.";
        if (narrativeContext?.narrative) {
            strategicPrioritySection = `**Strategic Priority: Dominant narrative is '${narrativeContext.narrative}'.** Prioritize these assets: [${narrativeContext.assets.join(', ')}]`;
        }
        let dexSection = "No high-risk DEX opportunities identified.";
        if (dexOpportunities?.length) {
            dexSection = `**High-Risk Ops:** DEX Scout found: [${dexOpportunities.join(', ')}]. Consider very small, speculative allocations.`;
        }
        const prompt = `
        **Persona:** You are a Chief Investment Officer.
        **Context:**
        - **Portfolio:** ${JSON.stringify(portfolio)}
        - **Macro:** ${JSON.stringify(macroAnalysis)}
        - **Sentiment:** ${JSON.stringify(sentimentAnalysis)}
        - **Candidates:** ${JSON.stringify(buySignals)}
        **Directives:**
        1.  **Narrative:** ${strategicPrioritySection}
        2.  **Speculative:** ${dexSection}
        **Task & Rules:**
        1.  Synthesize all data. Prioritize narrative assets.
        2.  Do not deploy >50% of balance. Do not allocate >25% of deployable capital to one asset. DEX assets are capped at 1% each.
        3.  Justify your decisions based on the directives.
        **Format (JSON):** An object where each key is the symbol, with \`decision\`, \`amount_to_buy_usd\`, and \`justification\`.
        `;
        return await this.safeGenerate(prompt);
    }
}

export class TechnicalAnalyst extends AIAgent {
    constructor(agentService: AgentService) { super('TechnicalAnalyst', agentService); }
    async analyzeBatch(batchData: { symbol: string; candles: Candle[] }[], config: any): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const formattedData = batchData.map(d => ({
            symbol: d.symbol,
            rsi: calculateRSI(d.candles, config.rsiPeriod)?.toFixed(2),
            macdHistogram: calculateMACD(d.candles, config.macdShortPeriod, config.macdLongPeriod, config.macdSignalPeriod)?.histogram?.toFixed(4),
            sma20: calculateSMAExported(d.candles, config.smaShortPeriod)?.toFixed(2),
            sma50: calculateSMAExported(d.candles, config.smaLongPeriod)?.toFixed(2)
        }));
        const prompt = `
        **Persona:** You are a quantitative analyst. Analyze the following batch.
        **Data:** ${JSON.stringify(formattedData)}
        **Task:** For each asset, provide a technical score and summary in JSON format.
        - \`technical_score\`: 0.0 to 10.0.
        - \`trend\`: "Uptrend", "Downtrend", "Sideways".
        - \`momentum\`: "Bullish", "Bearish", "Neutral".
        - \`summary\`: One-sentence summary.
        `;
        return await this.safeGenerate(prompt);
    }
}

export interface Analysis { [key: string]: any; }

export class RiskManager extends AIAgent {
    private memoryService: MemoryService;
    constructor(agentService: AgentService) {
        super('RiskManager', agentService);
        this.memoryService = MemoryService.getInstance();
    }
    determineRiskParameters(baseConfig: any, sharedContext: SharedContext): any {
        const { regimeScore } = sharedContext.getContext();
        const newConfig = { ...baseConfig };
        if (regimeScore > 7.5) { newConfig.riskAmountPercent *= 1.25; } 
        else if (regimeScore < 4.0) { newConfig.riskAmountPercent *= 0.5; }
        return newConfig;
    }
    async decideBatch(batchTechAnalyses: Record<string, any>, macroAnalysis: any, sentimentAnalysis: any, fundamentalData: Record<string, any>): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const candidatesForPrompt: Record<string, any> = {};
        const consultationPromises: Promise<any>[] = [];
        const conflictSymbols: string[] = [];
        for (const symbol in batchTechAnalyses) {
            const tech = batchTechAnalyses[symbol];
            const situationNarrative = `Trade for ${symbol}. Macro: ${macroAnalysis?.market_regime}, Tech score: ${tech?.technical_score}`;
            const pastLessons = await this.memoryService.recallMemories(situationNarrative, 3);
            candidatesForPrompt[symbol] = {
                technicalAnalysis: tech,
                fundamentalAnalysis: fundamentalData[symbol.replace('USDT', '')] || { error: "No data." },
                pastLessons: pastLessons.map(p => p.narrative)
            };
            if ((tech?.technical_score || 0) > 8.0 && (macroAnalysis?.regime_score || 5.0) < 4.0) {
                const question = `Excellent tech signal for ${symbol} but macro is Risk-Off. Is this a trap?`;
                consultationPromises.push(this.consult('MacroAnalyst', question));
                conflictSymbols.push(symbol);
                candidatesForPrompt[symbol].consultation = { question };
            }
        }
        if (consultationPromises.length > 0) {
            const debateResults = await Promise.all(consultationPromises);
            debateResults.forEach((answer, index) => {
                const symbol = conflictSymbols[index];
                if (candidatesForPrompt[symbol].consultation) {
                    candidatesForPrompt[symbol].consultation.answer = answer?.response || "No response.";
                }
            });
        }
        const prompt = `
        **Persona:** You are a critical Risk Manager with perfect memory.
        **Context:**
        - **Macro:** ${JSON.stringify(macroAnalysis)}
        - **Sentiment:** ${JSON.stringify(sentimentAnalysis)}
        - **Candidates:** ${JSON.stringify(candidatesForPrompt)}
        **CRITICAL TASK & RULES:**
        1.  Synthesize all data: Macro, Technical, Fundamental, and Past Lessons.
        2.  **Learn from History:** If past lessons show losses in similar situations, be more cautious.
        3.  **Fundamental Veto:** If fundamentals are weak (missing URLs, vague description), reduce confidence_score by 2-3 points.
        4.  **Debate Interpretation:** Use consultation answers to resolve conflicts.
        **Format (JSON):** An object where each key is the symbol, with \`decision\`, \`confidence_score\`, and \`final_summary\`. Justification must mention key factors.
        `;
        return await this.safeGenerate(prompt);
    }
}

export class DEX_ScoutAgent extends AIAgent {
    constructor(agentService: AgentService) { super('DEX_ScoutAgent', agentService); }
    async analyze(latestDexPairs: any[], sharedContext: SharedContext): Promise<void> {
        if (!latestDexPairs?.length) return;
        const anomalies = latestDexPairs
            .filter(pair => {
                const quote = pair.quote?.[Object.keys(pair.quote)[0]];
                const volume24h = quote?.volume_24h || 0;
                const liquidity = quote?.liquidity || 0;
                return volume24h > 50000 && (liquidity === 0 || volume24h > liquidity);
            })
            .map(pair => pair.base_asset_symbol || pair.symbol);

        if (anomalies.length > 0) {
            // @ts-ignore
            sharedContext.updateContext({ dexOpportunities: anomalies });
        }
    }
}

export interface Trade { symbol: string; amount: number; entryPrice: number; exitPrice: number; pnl: number; timestamp: string; reason: string; }
export interface MissedOpportunity { timestamp: string; symbol: string; reason: string; }
export interface DecisionLogEntry { timestamp: string; symbol: string; decision: string; }

export class StrategyOptimizer extends AIAgent {
    constructor(agentService: AgentService) { super('StrategyOptimizer', agentService); }
    async analyze(trades: Trade[], missedOpportunities: MissedOpportunity[], decisionLogs: DecisionLogEntry[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Quantitative Analyst. Evolve the bot by learning from its history.
        **Data:**
        1.  **Trades:** ${JSON.stringify(trades.slice(-50))}
        2.  **Missed Ops:** ${JSON.stringify(missedOpportunities.slice(-50))}
        3.  **Decisions:** ${JSON.stringify(decisionLogs.slice(-50))}
        **TASK:** Perform a holistic analysis and generate a new, superior configuration.
        - Analyze performance: What are the common characteristics of winning vs. losing trades?
        - Propose & Justify: Generate a new configuration and explain why you are making each key change.
        **Format (JSON):**
        - \`analysis_summary\`: Brief summary of your findings.
        - \`suggested_settings\`: A complete JSON object with all configuration keys for the main config.json file.
        `;
        return await this.safeGenerate(prompt);
    }
}

export class MasterAgent extends AIAgent {
    constructor(agentService: AgentService) { super('MasterAgent', agentService); }
    async manageOptimizationCycle(mainPortfolio: Portfolio, shadowPortfolio: Portfolio | null, config: any, username: string): Promise<void> {
        const mainConfigPath = path.join(process.cwd(), 'config.json');
        const shadowConfigPath = path.join(process.cwd(), `shadow_config_${username}.json`);
        if (shadowPortfolio) {
            const mainValue = mainPortfolio.balance;
            const shadowValue = shadowPortfolio.balance;
            const performanceDiff = ((shadowValue - mainValue) / mainValue) * 100;
            if (performanceDiff > 5.0) {
                console.log(`[MasterAgent] Shadow config performed ${performanceDiff.toFixed(2)}% better. Promoting to main config.`);
                const shadowConfigData = await fs.readFile(shadowConfigPath, 'utf-8');
                await fs.writeFile(mainConfigPath, shadowConfigData);
                await fs.unlink(shadowConfigPath);
                const shadowPortfolioPath = path.join(process.cwd(), `portfolio_shadow_${username}.json`);
                await fs.writeFile(shadowPortfolioPath, JSON.stringify({ balance: 100000, positions: [] }, null, 2));
            } else {
                console.log(`[MasterAgent] Shadow config did not outperform. Discarding and generating a new one.`);
                await fs.unlink(shadowConfigPath);
                await this.generateNewShadowConfig(username, config);
            }
        } else {
            console.log('[MasterAgent] No shadow portfolio found. Generating a new shadow config.');
            await this.generateNewShadowConfig(username, config);
        }
    }
    private async generateNewShadowConfig(username: string, currentConfig: any): Promise<void> {
        const optimizer = this.agentService.getAgent('StrategyOptimizer') as StrategyOptimizer;
        if (!optimizer) { return; }
        const tradesLogPath = path.join(process.cwd(), `trades_log_${username}.json`);
        const missedLogPath = path.join(process.cwd(), `missed_opportunities_${username}.json`);
        const decisionLogPath = path.join(process.cwd(), `decision_log_${username}.json`);
        try {
            const trades = JSON.parse(await fs.readFile(tradesLogPath, 'utf-8'));
            const missed = JSON.parse(await fs.readFile(missedLogPath, 'utf-8'));
            const decisions = JSON.parse(await fs.readFile(decisionLogPath, 'utf-8'));
            if (trades.length < 10) { return; }
            const analysisResult = await optimizer.analyze(trades, missed, decisions);
            const suggestedSettings = analysisResult?.response?.suggested_settings as any;
            if (suggestedSettings) {
                const newConfig = { ...currentConfig, ...suggestedSettings };
                const shadowConfigPath = path.join(process.cwd(), `shadow_config_${username}.json`);
                await fs.writeFile(shadowConfigPath, JSON.stringify(newConfig, null, 2));
            }
        } catch (error) {
            if (error instanceof Error && 'code' in error && (error as NodeJS.ErrnoException).code !== 'ENOENT') {
                 console.error('[MasterAgent] Error during shadow config generation:', error);
            }
        }
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\binance.ts ---
import axios from 'axios';

// Type for a single candle
export type Candle = {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
};

// Type for the daily ticker stats
export type Ticker = {
    symbol: string;
    priceChange: string;
    priceChangePercent: string;
    weightedAvgPrice: string;
    prevClosePrice: string;
    lastPrice: string;
    lastQty: string;
    bidPrice: string;
    bidQty: string;
    askPrice: string;
    askQty: string;
    openPrice: string;
    highPrice: string;
    lowPrice: string;
    volume: string;
    quoteVolume: string;
    openTime: number;
    closeTime: number;
    firstId: number;
    lastId: number;
    count: number;
};

export class BinanceService {
    private baseUrl = 'https://api.binance.com/api/v3';

    private async fetchApi(endpoint: string, params: Record<string, string> = {}) {
        try {
            const response = await axios.get(`${this.baseUrl}/${endpoint}`, { params });
            return response.data;
        } catch (error) {
            console.error(`Failed to fetch from Binance API: ${endpoint}`, error);
            throw error;
        }
    }

    async getHistoricalData(symbol: string, interval: string, limit = 100): Promise<Candle[]> {
        // Define the raw candle type from Binance API
        type BinanceCandle = [number, string, string, string, string, string, ...unknown[]];
        try {
            const data = await this.fetchApi('klines', { symbol, interval, limit: String(limit) });
            return data.map((d: BinanceCandle) => ({
                time: d[0] / 1000,
                open: parseFloat(d[1]),
                high: parseFloat(d[2]),
                low: parseFloat(d[3]),
                close: parseFloat(d[4]),
                volume: parseFloat(d[5]),
            }));
        } catch {
            return [];
        }
    }

    async getCurrentPrice(symbol: string): Promise<number | null> {
        try {
            const data = await this.fetchApi('ticker/price', { symbol });
            return parseFloat(data.price);
        } catch {
            return null;
        }
    }

    async getTopSymbols(limit = 200): Promise<Ticker[]> {
        try {
            const data: Ticker[] = await this.fetchApi('ticker/24hr');
            // Filter for USDT pairs and exclude leveraged tokens or other special assets
            const usdtPairs = data.filter(t => 
                t.symbol.endsWith('USDT') && 
                !t.symbol.includes('UP') && 
                !t.symbol.includes('DOWN') &&
                !t.symbol.includes('BULL') &&
                !t.symbol.includes('BEAR') &&
                !t.symbol.match(/^\d/) // Exclude symbols that start with a number
            );
            const sorted = usdtPairs.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            return sorted.slice(0, limit);
        } catch {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\coinmarketcap.ts ---
// src/core/coinmarketcap.ts

interface FearAndGreedData {
    value: string;
    value_classification: string;
    timestamp: string;
}

interface GlobalMetricsQuote {
    total_market_cap: number;
    btc_dominance: number;
    defi_market_cap: number;
    stablecoin_market_cap: number;
}

interface GlobalMetricsData {
    quote: {
        USD: GlobalMetricsQuote;
    };
}

export class CoinMarketCapService {
    private apiKey: string;
    private baseUrl: string = 'https://pro-api.coinmarketcap.com';

    constructor() {
        this.apiKey = process.env.CMC_API_KEY || '';
        if (!this.apiKey) {
            console.warn('CMC_API_KEY is not defined. CMC features will be limited.');
        }
    }

    private async fetchApi<T>(endpoint: string, params: Record<string, string> = {}): Promise<T | null> {
        if (!this.apiKey) return null;
        
        const url = new URL(`${this.baseUrl}${endpoint}`);
        Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));

        try {
            const response = await fetch(url.toString(), {
                headers: {
                    'X-CMC_PRO_API_KEY': this.apiKey,
                    'Accept': 'application/json',
                },
            });

            if (!response.ok) {
                console.error(`CoinMarketCap API error for ${endpoint}: ${response.statusText}`, await response.text());
                return null;
            }

            const data = await response.json();
            if (data.status.error_code !== 0) {
                console.error('CoinMarketCap API error status:', data.status);
                return null;
            }
            return data.data as T;
        } catch (error) {
            console.error(`Error fetching from CoinMarketCap API endpoint ${endpoint}:`, error);
            return null;
        }
    }

    async getFearAndGreedIndex(): Promise<FearAndGreedData | null> {
        try {
            const response = await fetch('https://api.alternative.me/fng/?limit=1');
             if (!response.ok) return null;
             const data = await response.json();
             return data.data[0] ? {
                 value: data.data[0].value,
                 value_classification: data.data[0].value_classification,
                 timestamp: new Date(data.data[0].timestamp * 1000).toISOString(),
             } : null;
        } catch (error) {
            console.error('Error fetching Fear and Greed Index:', error);
            return null;
        }
    }
    
    async getGlobalMetrics(): Promise<GlobalMetricsData | null> {
        return this.fetchApi<GlobalMetricsData>('/v1/global-metrics/quotes/latest');
    }
    
    async getTrendingTokens(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/trending/most-visited', { limit: '10' });
    }
    
    async getTrendingGainersAndLosers(): Promise<any | null> {
        return this.fetchApi<any>('/v1/cryptocurrency/trending/gainers-losers', { limit: '10', sort_dir: 'desc', time_period: '24h' });
    }

    async getCategories(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/categories', { limit: '10', sort: 'market_cap', sort_dir: 'desc' });
    }
    
    async getCategoryById(id: string): Promise<any | null> {
        return this.fetchApi<any>(`/v1/cryptocurrency/category`, { id });
    }

    async getAirdrops(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/airdrops', { status: 'upcoming' });
    }

    async getCryptocurrencyInfo(symbols: string[]): Promise<any | null> {
        if (symbols.length === 0) return null;
        return this.fetchApi<any>('/v2/cryptocurrency/info', { symbol: symbols.join(',') });
    }

    async getLatestDexPairs(): Promise<any[] | null> {
        // CORRECTED ENDPOINT based on documentation and strategic plan
        return this.fetchApi<any[]>('/v4/dex/spot-pairs/latest', { sort: 'volume_24h', limit: '100' });
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\context.ts ---
// src/core/context.ts

export interface ISharedContext {
    marketRegime: 'Risk-On' | 'Risk-Off' | 'Neutral';
    regimeScore: number;
    sentiment: 'Bullish' | 'Bearish' | 'Neutral';
    sentimentScore: number;
    fearAndGreedIndex: { value: string; classification: string } | null;
    keyTopics: string[];
    activeThreats: string[];
    activeOpportunities: string[];
    dexOpportunities?: string[]; // NEW: For DEX Scout findings
}

export class SharedContext {
    private context: ISharedContext;

    constructor() {
        this.context = {
            marketRegime: 'Neutral',
            regimeScore: 5.0,
            sentiment: 'Neutral',
            sentimentScore: 0.0,
            fearAndGreedIndex: null,
            keyTopics: [],
            activeThreats: [],
            activeOpportunities: [],
            dexOpportunities: [],
        };
    }

    public updateContext(updates: Partial<ISharedContext>): void {
        this.context = { ...this.context, ...updates };
        console.log('SharedContext updated:', updates);
    }

    public getContext(): ISharedContext {
        return { ...this.context };
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\decision-logger.ts ---
import fs from 'fs/promises';
import path from 'path';

const getDecisionLogPath = (username: string) => path.join(process.cwd(), `decision_log_${username}.json`);

export interface DecisionLogEntry {
    symbol: string;
    decision: 'SELL_NOW' | 'HOLD_AND_INCREASE_TP' | 'BUY' | 'AVOID'; // Added BUY and AVOID
    pnlPercent?: number; // Made optional as it might not apply to BUY/AVOID
    currentPrice?: number; // Made optional
    newTakeProfitPercent?: number;
    amount?: number; // Added for BUY decisions
    reason?: string; // Changed from justification to reason for consistency with other logs
    justification?: string; // Kept for backward compatibility if needed, but prefer 'reason'
    timestamp: string;
}

export class DecisionLogger {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to DecisionLogger.");
        }
        this.username = username;
    }

    private getFilePath(): string {
        return getDecisionLogPath(this.username);
    }

    public async log(entry: Omit<DecisionLogEntry, 'timestamp'>): Promise<void> {
        const logFilePath = this.getFilePath();
        let logs: DecisionLogEntry[] = [];
        try {
            const data = await fs.readFile(logFilePath, 'utf-8');
            logs = JSON.parse(data);
        } catch (error) {
            // File might not exist yet, which is fine.
        }

        const newLog: DecisionLogEntry = {
            ...entry,
            timestamp: new Date().toISOString(),
        };

        logs.unshift(newLog); // Add to the beginning
        await fs.writeFile(logFilePath, JSON.stringify(logs, null, 2));
    }

    public async getLogs(): Promise<DecisionLogEntry[]> {
        try {
            const data = await fs.readFile(this.getFilePath(), 'utf-8');
            return JSON.parse(data);
        } catch (error) {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\global-context.ts ---
import { SharedContext } from './context';

// Create a single, global instance of SharedContext
export const globalSharedContext = new SharedContext();

--- END FILE: {relative_filepath} ---

--- FILE: src\core\indicators.ts ---
import { Candle } from './binance';

// Helper to calculate Simple Moving Average (SMA)
function calculateSMA(data: number[], period: number): number[] {
    const sma: number[] = [];
    for (let i = 0; i <= data.length - period; i++) {
        const chunk = data.slice(i, i + period);
        const sum = chunk.reduce((a, b) => a + b, 0);
        sma.push(sum / period);
    }
    return sma;
}

// Helper to calculate Exponential Moving Average (EMA)
function calculateEMA(data: number[], period: number): number[] {
    const ema: number[] = [];
    const multiplier = 2 / (period + 1);
    let prevEma = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
    ema.push(prevEma);

    for (let i = period; i < data.length; i++) {
        const currentEma = (data[i] - prevEma) * multiplier + prevEma;
        ema.push(currentEma);
        prevEma = currentEma;
    }
    return ema;
}

export function calculateSMAExported(candles: Candle[], period: number): number | null {
    if (candles.length < period) return null;
    const prices = candles.map(c => c.close);
    const smaValues = calculateSMA(prices, period);
    return smaValues[smaValues.length - 1];
}

export function calculateRSI(candles: Candle[], period: number = 14): number | null {
    if (candles.length < period) return null;
    const prices = candles.map(c => c.close);
    let gains = 0;
    let losses = 0;

    for (let i = 1; i < prices.length; i++) {
        const diff = prices[i] - prices[i - 1];
        if (diff > 0) {
            gains += diff;
        } else {
            losses -= diff;
        }
    }

    const avgGain = gains / period;
    const avgLoss = losses / period;

    if (avgLoss === 0) return 100;

    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}

export function calculateMACD(candles: Candle[], shortPeriod: number = 12, longPeriod: number = 26, signalPeriod: number = 9) {
    if (candles.length < longPeriod) return null;
    const prices = candles.map(c => c.close);
    
    const emaShort = calculateEMA(prices, shortPeriod);
    const emaLong = calculateEMA(prices, longPeriod);
    
    const macdLine = emaShort.slice(emaLong.length - emaShort.length).map((val, index) => val - emaLong[index]);
    const signalLine = calculateEMA(macdLine, signalPeriod);
    
    const histogram = macdLine.slice(signalLine.length - macdLine.length).map((val, index) => val - signalLine[index]);

    return {
        macd: macdLine[macdLine.length - 1],
        signal: signalLine[signalLine.length - 1],
        histogram: histogram[histogram.length - 1],
    };
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\memory.ts ---
// src/core/memory.ts

import { GoogleGenerativeAI } from "@google/generative-ai";
import { ChromaClient, Collection } from 'chromadb';

const client = new ChromaClient();
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEYS?.split(',')[0] || '');

// Interface for the data we want to store along with the vector
export interface MemoryMetadata {
    symbol: string;
    outcome: 'profit' | 'loss' | 'missed_opportunity';
    pnl_percent: number;
    timestamp: string;
    narrative: string; // The textual summary of the event
}

export class MemoryService {
    private static instance: MemoryService;
    private collection: Collection | null = null;
    private embeddingModel: any; // Gemini Embedding Model

    private constructor() {
        this.embeddingModel = genAI.getGenerativeModel({ model: "embedding-001" });
        this.initialize();
    }

    public static getInstance(): MemoryService {
        if (!MemoryService.instance) {
            MemoryService.instance = new MemoryService();
        }
        return MemoryService.instance;
    }

    private async initialize(): Promise<void> {
        try {
            this.collection = await client.getOrCreateCollection({ name: "trade_memories" });
            console.log("[MemoryService] ChromaDB collection 'trade_memories' loaded/created successfully.");
        } catch (error) {
            console.error("[MemoryService] Failed to initialize ChromaDB collection:", error);
        }
    }

    /**
     * Creates a vector embedding from a text string.
     * @param text The text to embed.
     * @returns A numeric vector.
     */
    private async createEmbedding(text: string): Promise<number[]> {
        const result = await this.embeddingModel.embedContent(text);
        return result.embedding.values;
    }

    /**
     * Adds a new memory to the vector database.
     * @param metadata The metadata associated with the memory.
     */
    public async addMemory(metadata: MemoryMetadata): Promise<void> {
        if (!this.collection) {
            console.error("[MemoryService] Collection not initialized. Cannot add memory.");
            return;
        }

        try {
            const embedding = await this.createEmbedding(metadata.narrative);
            const id = `${metadata.symbol}_${metadata.timestamp}`;

            await this.collection.add({
                ids: [id],
                embeddings: [embedding],
                metadatas: [metadata],
            });

            console.log(`[MemoryService] Added new memory: ${id}`);
        } catch (error) {
            console.error("[MemoryService] Error adding memory to ChromaDB:", error);
        }
    }

    /**
     * Recalls relevant past memories based on a new situation.
     * @param situation A narrative string of the current situation.
     * @param count The number of memories to retrieve.
     * @returns A list of similar past memories.
     */
    public async recallMemories(situation: string, count: number = 3): Promise<MemoryMetadata[]> {
        if (!this.collection || (await this.collection.count()) === 0) {
            return [];
        }

        try {
            const queryEmbedding = await this.createEmbedding(situation);
            
            const results = await this.collection.query({
                queryEmbeddings: [queryEmbedding],
                nResults: count,
            });

            // The query returns a complex object, we just need the metadata
            return (results.metadatas[0] as MemoryMetadata[]) || [];
        } catch (error) {
            console.error("[MemoryService] Error recalling memories from ChromaDB:", error);
            return [];
        }
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\news.ts ---
// Define the Article interface based on NewsAPI response
interface Article {
    source: {
        id: string | null;
        name: string;
    };
    author: string | null;
    title: string;
    description: string | null;
    url: string;
    urlToImage: string | null;
    publishedAt: string;
    content: string | null;
}

export class NewsService {
    private apiKey: string;
    private baseUrl: string = 'https://newsapi.org/v2/everything';

    constructor() {
        this.apiKey = process.env.NEWS_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('NEWS_API_KEY is not defined in the environment variables.');
        }
    }

    async getCryptoNews(query: string = 'crypto', pageSize: number = 10): Promise<Article[]> {
        try {
            const url = `${this.baseUrl}?q=${query}&apiKey=${this.apiKey}&pageSize=${pageSize}&sortBy=publishedAt&language=en`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch news: ${response.statusText}`);
            }
            const data = await response.json();
            return data.articles || [];
        } catch (error) {
            console.error('Error fetching crypto news:', error);
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\opportunity-logger.ts ---
// src/core/opportunity-logger.ts
import fs from 'fs/promises';
import path from 'path';

const getMissedOpportunitiesPath = (username: string) => path.join(process.cwd(), `missed_opportunities_${username}.json`);

export interface MissedOpportunity {
    timestamp: string;
    symbol: string;
    priceChangePercent: number; // Added this field
    reason: string; // e.g., "AVOID decision by RiskManager"
    confidenceScore?: number;
    finalSummary?: string;
}

export class OpportunityLogger {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to OpportunityLogger.");
        }
        this.username = username;
    }

    private getFilePath(): string {
        return getMissedOpportunitiesPath(this.username);
    }

    public async getLogs(): Promise<MissedOpportunity[]> {
        try {
            const data = await fs.readFile(this.getFilePath(), 'utf-8');
            return JSON.parse(data);
        } catch {
            // If file doesn't exist or is invalid, start with an empty array
            return [];
        }
    }

    async log(opportunity: Omit<MissedOpportunity, 'timestamp'>): Promise<void> {
        try {
            const logs = await this.getLogs();
            const newLog: MissedOpportunity = {
                timestamp: new Date().toISOString(),
                ...opportunity,
            };
            logs.push(newLog);
            // Keep the log from growing indefinitely
            const trimmedLogs = logs.slice(-500); 
            await fs.writeFile(this.getFilePath(), JSON.stringify(trimmedLogs, null, 2));
        } catch (error) {
            console.error("Failed to log missed opportunity:", error);
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\opportunity-scanner.ts ---
import fs from 'fs/promises';
import path from 'path';

const opportunitiesLogPath = path.join(process.cwd(), 'opportunities.json');

export interface Opportunity {
    symbol: string;
    priceChangePercent: number;
    timestamp: string;
    status: 'detected' | 'analyzing' | 'bought' | 'ignored' | 'sold' | 'held';
}

export class OpportunityScanner {
    private static instance: OpportunityScanner;
    private opportunities: Opportunity[] = [];

    private constructor() {
        this.loadOpportunities();
    }

    public static getInstance(): OpportunityScanner {
        if (!OpportunityScanner.instance) {
            OpportunityScanner.instance = new OpportunityScanner();
        }
        return OpportunityScanner.instance;
    }

    private async loadOpportunities(): Promise<void> {
        try {
            const data = await fs.readFile(opportunitiesLogPath, 'utf-8');
            this.opportunities = JSON.parse(data);
        } catch (error) {
            // File might not exist yet, which is fine.
            this.opportunities = [];
        }
    }

    private async saveOpportunities(): Promise<void> {
        await fs.writeFile(opportunitiesLogPath, JSON.stringify(this.opportunities, null, 2));
    }

    public async addOpportunity(opportunity: Omit<Opportunity, 'timestamp' | 'status'>): Promise<void> {
        const newOpportunity: Opportunity = {
            ...opportunity,
            timestamp: new Date().toISOString(),
            status: 'detected',
        };
        this.opportunities.unshift(newOpportunity); // Add to the beginning of the array
        await this.saveOpportunities();
    }

    public getOpportunities(): Opportunity[] {
        return this.opportunities;
    }

    public async updateOpportunityStatus(symbol: string, status: Opportunity['status']): Promise<void> {
        const opportunity = this.opportunities.find(o => o.symbol === symbol);
        if (opportunity) {
            opportunity.status = status;
            await this.saveOpportunities();
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\optimizer.ts ---
import { AIAgent } from './agents';
import { DecisionLogEntry } from './decision-logger';
import { MissedOpportunity } from './opportunity-logger';

// Define the Trade interface
export interface Trade {
    symbol: string;
    amount: number;
    entryPrice: number;
    exitPrice: number;
    pnl: number;
    timestamp: string;
    reason: string;
}

export class StrategyOptimizer extends AIAgent {
    async analyze(trades: Trade[], missedOpportunities: MissedOpportunity[], decisionLogs: DecisionLogEntry[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Quantitative Analyst and AI Strategist. Your core function is to evolve this trading bot by learning from its complete performance history.

        **You have three data sources:**
        1.  **Executed Trades Log:** The final outcome of each trade (profit or loss).
        ${JSON.stringify(trades, null, 2)}

        2.  **Missed Opportunities Log:** Assets the bot decided to "AVOID".
        ${JSON.stringify(missedOpportunities, null, 2)}

        3.  **Position Management Decisions Log:** Records of when the bot decided to "HOLD" a winning position instead of selling immediately.
        ${JSON.stringify(decisionLogs, null, 2)}

        **CRITICAL TASK: Perform a holistic, data-driven analysis and generate a new, superior configuration.**

        1.  **Analyze Executed Trades:** What are the common characteristics of winning trades vs. losing trades? Look for patterns in technical indicators, market regime, etc.
        2.  **Analyze Missed Opportunities:** Were there any "AVOID" decisions that turned out to be highly profitable? Does this suggest the bot's entry criteria are too strict?
        3.  **Analyze Position Management (MOST IMPORTANT):** This is key to maximizing profit. For each "HOLD_AND_INCREASE_TP" decision in the log, compare the price at the time of the decision to the final exit price in the "Executed Trades Log".
            - Was holding the position, on average, more profitable than selling immediately?
            - Does the data suggest the \`takeProfitPercent\` should be higher or lower? Should it be more dynamic?
        4.  **Propose & Justify:** Based on your complete analysis, generate a new, fully optimized configuration. Your summary must explain *why* you are making each key change, referencing your findings from all three data logs.

        **Format (JSON):**
        - \`analysis_summary\`: A brief summary of your key findings from the trade history.
        - \`suggested_settings\`: A complete JSON object containing the full, new configuration. This object must include values for all of these keys: "sellStrategy", "takeProfitPercent", "stopLossPercent", "trailingStopPercent", "riskAmountPercent", "rsiPeriod", "symbolsToAnalyze", "batchSize", "macroScoreThreshold", "minimumBalance", "cycleIntervalMinutes", "smaShortPeriod", "smaLongPeriod", "macdShortPeriod", "macdLongPeriod", "macdSignalPeriod".
        `;
        return await this.safeGenerate(prompt);
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\portfolio.ts ---
// src/core/portfolio.ts

import fs from 'fs/promises';
import path from 'path';
import { setTimeout } from 'timers/promises';
import { Trade } from './optimizer';
import { MemoryService } from './memory';
import { ISharedContext } from './context';

// This function now generates filenames based on the mode (main or shadow)
const getSuffixedPath = (baseName: string, username: string, mode: 'main' | 'shadow') => {
    const suffix = mode === 'shadow' ? `_shadow_${username}.json` : `_${username}.json`;
    return path.join(process.cwd(), baseName.replace('.json', suffix));
};

interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPrice?: number;
    takeProfitPercent?: number;
    holdCount?: number;
    stopLossPrice?: number;
    highPnlPercent?: number;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

export class PortfolioService {
    private username: string;
    private mode: 'main' | 'shadow';
    private memoryService: MemoryService;

    constructor(username: string, mode: 'main' | 'shadow' = 'main') {
        if (!username) {
            throw new Error("Username must be provided to PortfolioService.");
        }
        this.username = username;
        this.mode = mode;
        // Memory service is only used for the main portfolio to avoid learning from untested strategies
        if (this.mode === 'main') {
            this.memoryService = MemoryService.getInstance();
        }
    }

    private getFilePaths() {
        return {
            portfolioFilePath: getSuffixedPath('portfolio.json', this.username, this.mode),
            lockFilePath: getSuffixedPath('portfolio.lock', this.username, this.mode),
            tradesLogFilePath: getSuffixedPath('trades_log.json', this.username, this.mode),
        };
    }

    private async withPortfolio(worker: (portfolio: Portfolio) => Promise<void> | void): Promise<void> {
        const { lockFilePath, portfolioFilePath } = this.getFilePaths();
        const lockAcquired = await this.acquireLock(lockFilePath);
        if (!lockAcquired) {
            throw new Error(`Failed to acquire ${this.mode} portfolio lock after multiple retries.`);
        }

        let portfolio: Portfolio;
        try {
            try {
                const data = await fs.readFile(portfolioFilePath, 'utf-8');
                portfolio = JSON.parse(data);
            } catch (error) {
                portfolio = { balance: 100000, positions: [] };
            }

            await worker(portfolio);
            await fs.writeFile(portfolioFilePath, JSON.stringify(portfolio, null, 2));
        } finally {
            await this.releaseLock(lockFilePath);
        }
    }
    
    private async acquireLock(lockFilePath: string, retries = 20, delay = 200): Promise<boolean> {
        for (let i = 0; i < retries; i++) {
            try {
                await fs.writeFile(lockFilePath, process.pid.toString(), { flag: 'wx' });
                return true;
            } catch (error) {
                if ((error as NodeJS.ErrnoException).code === 'EEXIST') {
                    await setTimeout(delay);
                } else {
                    throw error;
                }
            }
        }
        return false;
    }
    
    private async releaseLock(lockFilePath: string): Promise<void> {
        try {
            await fs.unlink(lockFilePath);
        } catch (error) {
            if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
                console.error(`Failed to release ${this.mode} portfolio lock for ${this.username}:`, error);
            }
        }
    }

    async getPortfolio(): Promise<Portfolio> {
        const { portfolioFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(portfolioFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return { balance: 100000, positions: [] };
        }
    }

    async buy(symbol: string, amount: number, price: number): Promise<void> {
        await this.withPortfolio(async (portfolio) => {
            const cost = amount * price;
            const fee = cost * 0.001;
            if (portfolio.balance < cost + fee) {
                throw new Error('Insufficient balance for cost + fee');
            }
            portfolio.balance -= (cost + fee);

            const newPosition: Position = { symbol, amount, entryPrice: price, highPrice: price };
            
            const existingPosition = portfolio.positions.find(p => p.symbol === symbol);
            if (existingPosition) {
                const totalAmount = existingPosition.amount + amount;
                const newEntryPrice = ((existingPosition.entryPrice * existingPosition.amount) + (price * amount)) / totalAmount;
                existingPosition.entryPrice = newEntryPrice;
                existingPosition.amount = totalAmount;
            } else {
                portfolio.positions.push(newPosition);
            }
        });
    }

    async updatePosition(symbol: string, updates: Partial<Position>): Promise<void> {
        await this.withPortfolio((portfolio) => {
            const position = portfolio.positions.find(p => p.symbol === symbol);
            if (position) {
                Object.assign(position, updates);
            }
        });
    }

    async sell(symbol: string, amount: number, price: number, reason: string, context: ISharedContext): Promise<void> {
        await this.withPortfolio(async (portfolio) => {
            const positionIndex = portfolio.positions.findIndex(p => p.symbol === symbol);
            if (positionIndex === -1) {
                throw new Error('Position not found to sell.');
            }
            const position = portfolio.positions[positionIndex];
            if (position.amount < amount) {
                throw new Error('Insufficient position amount to sell.');
            }

            const revenue = amount * price;
            const fee = revenue * 0.001;
            const pnl = (price - position.entryPrice) * amount - fee;
            const pnlPercent = (pnl / (position.entryPrice * amount)) * 100;
            portfolio.balance += (revenue - fee);

            const tradeLog: Trade = {
                symbol, amount, entryPrice: position.entryPrice, exitPrice: price, pnl,
                timestamp: new Date().toISOString(), reason
            };
            const { tradesLogFilePath } = this.getFilePaths();
            const tradeLogs = await this.getTradeLogs();
            tradeLogs.push(tradeLog);
            await fs.writeFile(tradesLogFilePath, JSON.stringify(tradeLogs, null, 2));

            if (this.mode === 'main' && this.memoryService) {
                const outcome = pnl >= 0 ? 'profit' : 'loss';
                const narrative = `Sold ${amount.toFixed(4)} ${symbol} with a ${pnlPercent.toFixed(2)}% ${outcome}. ` +
                                  `The sale was triggered by: ${reason}. ` +
                                  `Market conditions at the time were: Regime=${context.marketRegime} (Score: ${context.regimeScore.toFixed(1)}), ` +
                                  `Sentiment=${context.sentiment} (Score: ${context.sentimentScore.toFixed(2)}).`;

                await this.memoryService.addMemory({
                    symbol,
                    outcome,
                    pnl_percent: pnlPercent,
                    timestamp: new Date().toISOString(),
                    narrative
                });
            }

            portfolio.positions.splice(positionIndex, 1);
        });
    }

    async getTradeLogs(): Promise<Trade[]> {
        const { tradesLogFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(tradesLogFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return [];
        }
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\lib\auth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import fs from 'fs/promises';
import path from 'path';
import bcrypt from 'bcryptjs';

const usersFilePath = path.join(process.cwd(), 'users.json');

async function getUsers() {
    try {
        const data = await fs.readFile(usersFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        return {};
    }
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials) {
            return null;
        }
        const users = await getUsers();
        const user = users[credentials.username];

        if (user && await bcrypt.compare(credentials.password, user.password)) {
          return { id: credentials.username, name: credentials.username };
        }
        return null;
      }
    })
  ],
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.name = user.name;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.name = token.name;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  }
};

--- END FILE: {relative_filepath} ---

--- FILE: src\lib\utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\middleware.ts ---
export { default } from "next-auth/middleware"

export const config = { matcher: ["/dashboard/:path*"] }

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\globals.css ---
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\layout.tsx ---
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import { Toaster } from "react-hot-toast";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Crypto Bot",
  description: "The world's best crypto trading bot",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers>
          <Toaster position="top-right" />
          {children}
        </Providers>
      </body>
    </html>
  );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\page.tsx ---
import Image from "next/image";

export default function Home() {
  return (
    <div className="font-sans grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="font-mono list-inside list-decimal text-sm/6 text-center sm:text-left">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] font-mono font-semibold px-1 py-0.5 rounded">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\providers.tsx ---
"use client";

import { SessionProvider } from "next-auth/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\auth\register\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';
import bcrypt from 'bcryptjs';

const usersFilePath = path.join(process.cwd(), 'users.json');
const getPortfolioFilePath = (username: string) => path.join(process.cwd(), `portfolio_${username}.json`);

async function getUsers() {
    try {
        const data = await fs.readFile(usersFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        return {};
    }
}

export async function POST(req: Request) {
    try {
        const { username, password } = await req.json();

        if (!username || !password) {
            return NextResponse.json({ error: 'Username and password are required' }, { status: 400 });
        }

        const users = await getUsers();

        if (users[username]) {
            return NextResponse.json({ error: 'User already exists' }, { status: 409 });
        }

        const hashedPassword = await bcrypt.hash(password, 10);
        users[username] = { password: hashedPassword };

        await fs.writeFile(usersFilePath, JSON.stringify(users, null, 2));

        // Create a new portfolio for the user
        const portfolioFilePath = getPortfolioFilePath(username);
        const initialPortfolio = {
            balance: 100000,
            positions: [],
        };
        await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2));

        return NextResponse.json({ message: 'User registered successfully' }, { status: 201 });

    } catch (error) {
        console.error("Registration error:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\auth\[...nextauth]\route.ts ---
import NextAuth from "next-auth"
import { authOptions } from "@/lib/auth"

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST }

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\bot\backtest\route.ts ---
import { BinanceService } from '@/core/binance';
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager } from '@/core/agents';
import { SharedContext } from '@/core/context';
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function POST(request: Request) {
    const { symbol, interval } = await request.json();

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const sendEvent = (data: object) => {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
            };

            sendEvent({ type: 'log', message: 'Backtest started...' });

            try {
                const binance = new BinanceService();
                const macroAnalyst = new MacroAnalyst();
                const sentimentAnalyst = new SentimentAnalyst();
                const techAnalyst = new TechnicalAnalyst();
                const riskManager = new RiskManager();

                const configData = await fs.readFile(configFilePath, 'utf-8');
                const config = JSON.parse(configData);

                const historicalData = await binance.getHistoricalData(symbol, interval, 200); // Reduced for faster streaming

                let positionOpen = false;

            for (let i = 1; i < historicalData.length; i++) {
                const currentCandle = historicalData[i];
                sendEvent({ type: 'log', message: `Analyzing data for ${new Date(currentCandle.time * 1000).toISOString()}` });

                const dummyContext = new SharedContext();
                const macroAnalysisResult = await macroAnalyst.analyze(currentCandle, [], dummyContext);
                const sentimentAnalysisResult = await sentimentAnalyst.analyze([], dummyContext);
                const techAnalysisResult = await techAnalyst.analyze(symbol, historicalData.slice(0, i + 1), config);

                const macroAnalysis = macroAnalysisResult?.response;
                const sentimentAnalysis = sentimentAnalysisResult?.response;
                const techAnalysis = techAnalysisResult?.response;

                sendEvent({ type: 'aiChat', data: { agent: 'MacroAnalyst', ...macroAnalysisResult } });
                sendEvent({ type: 'aiChat', data: { agent: 'SentimentAnalyst', ...sentimentAnalysisResult } });
                sendEvent({ type: 'aiChat', data: { agent: 'TechnicalAnalyst', ...techAnalysisResult } });

                const fullAnalysis = {
                        Symbol: symbol,
                        MacroAnalyst: macroAnalysis,
                        SentimentAnalyst: sentimentAnalysis,
                        TechnicalAnalyst: techAnalysis,
                    };
                    
                    sendEvent({ type: 'analysis', data: fullAnalysis });

                    const finalDecisionResult = await riskManager.decide(fullAnalysis);
                    const finalDecision = finalDecisionResult?.response;
                    sendEvent({ type: 'aiChat', data: { agent: 'RiskManager', ...finalDecisionResult } });

                    if (finalDecision?.decision === 'BUY' && !positionOpen) {
                        sendEvent({ type: 'trade', data: { date: new Date(currentCandle.time * 1000).toISOString(), action: 'BUY', price: currentCandle.close } });
                        positionOpen = true;
                    } else if (finalDecision?.decision === 'SELL' && positionOpen) {
                        sendEvent({ type: 'trade', data: { date: new Date(currentCandle.time * 1000).toISOString(), action: 'SELL', price: currentCandle.close } });
                        positionOpen = false;
                    }
                    
                    // Add a small delay to make the stream visible
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                sendEvent({ type: 'log', message: 'Backtest finished.' });
                controller.close();

            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                sendEvent({ type: 'error', message: errorMessage });
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\bot\decision\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { NewsService } from '@/core/news'; // Import NewsService
import { CoinMarketCapService } from '@/core/coinmarketcap'; // Import CoinMarketCapService
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, Analysis, PositionManager } from '@/core/agents'; // Import MacroAnalyst, SentimentAnalyst, PositionManager
import { SharedContext } from '@/core/context';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext
import { OpportunityScanner } from '@/core/opportunity-scanner';
import { PortfolioService } from '@/core/portfolio'; // Import PortfolioService
import { DecisionLogger } from '@/core/decision-logger'; // Import DecisionLogger
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { symbol } = await req.json();
    if (!symbol) {
        return NextResponse.json({ error: 'Symbol is required' }, { status: 400 });
    }

    try {
        const opportunityScanner = OpportunityScanner.getInstance();
        await opportunityScanner.updateOpportunityStatus(symbol, 'analyzing');

        // Initialize services and agents
        const binance = new BinanceService();
        const newsService = new NewsService(); // Initialize NewsService
        const coinMarketCapService = new CoinMarketCapService(); // Initialize CoinMarketCapService
        const macroAnalyst = new MacroAnalyst(); // Initialize MacroAnalyst
        const sentimentAnalyst = new SentimentAnalyst(); // Initialize SentimentAnalyst
        const techAnalyst = new TechnicalAnalyst();
        const riskManager = new RiskManager();
        const positionManager = new PositionManager(); // Initialize PositionManager
        const portfolioService = new PortfolioService(session.user.name); // Initialize PortfolioService
        const decisionLogger = new DecisionLogger(session.user.name); // Initialize DecisionLogger
        // Use the global shared context
        const sharedContext = globalSharedContext;

        // Load config
        const configData = await fs.readFile(configFilePath, 'utf-8');
        const config = JSON.parse(configData);

        // Fetch necessary data for AI decision
        const candles = await binance.getHistoricalData(symbol, '5m', 100);
        if (candles.length === 0) {
            throw new Error(`Could not fetch historical data for ${symbol}`);
        }

        const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
        const newsArticles = await newsService.getCryptoNews();
        // Get Fear and Greed Index from global context
        const fearAndGreedIndex = sharedContext.getContext().fearAndGreedIndex;

        // Perform real macro and sentiment analysis
        const macroAnalysisResult = await macroAnalyst.analyze(
            btcData[0] || {},
            newsArticles.map(a => a.title),
            fearAndGreedIndex, // Pass directly from shared context
            sharedContext
        );
        const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, sharedContext);

        const macroAnalysis = macroAnalysisResult?.response;
        const sentimentAnalysis = sentimentAnalysisResult?.response;

        // Get current position details
        const portfolio = await portfolioService.getPortfolio();
        const position = portfolio.positions.find(p => p.symbol === symbol);

        if (!position) {
            throw new Error(`Position for ${symbol} not found in portfolio.`);
        }

        const currentPrice = await binance.getCurrentPrice(symbol);
        if (!currentPrice) {
            throw new Error(`Could not fetch current price for ${symbol}`);
        }

        // Invoke PositionManager for decision
        const decisionResult = await positionManager.decide(position, currentPrice, macroAnalysis, sentimentAnalysis, config, []);
        const decisionData = decisionResult?.response as { decision?: string; new_take_profit_percent?: number; justification?: string };

        if (decisionData?.decision) {
            await decisionLogger.log({
                symbol: position.symbol,
                decision: decisionData.decision as 'SELL_NOW' | 'HOLD_AND_INCREASE_TP',
                pnlPercent: (currentPrice - position.entryPrice) / position.entryPrice * 100,
                currentPrice,
                newTakeProfitPercent: decisionData.new_take_profit_percent,
                justification: decisionData.justification || 'N/A',
            });

            if (decisionData.decision === 'SELL_NOW') {
                await portfolioService.sell(position.symbol, position.amount, currentPrice, { reason: 'PositionManager decision' });
                await opportunityScanner.updateOpportunityStatus(symbol, 'sold'); // Update status if sold
                return NextResponse.json({ symbol, decision: 'SOLD', reason: decisionData.justification });
            } else if (decisionData.decision === 'HOLD_AND_INCREASE_TP' && decisionData.new_take_profit_percent) {
                await portfolioService.updatePosition(position.symbol, { takeProfitPercent: decisionData.new_take_profit_percent });
                await opportunityScanner.updateOpportunityStatus(symbol, 'held'); // Update status if held
                return NextResponse.json({ symbol, decision: 'HELD', new_tp: decisionData.new_take_profit_percent, reason: decisionData.justification });
            }
        }

        // Fallback if no decision or unexpected decision
        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
        return NextResponse.json({ symbol, decision: 'AVOID', reason: 'AI decision inconclusive or unexpected.' });

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`[Decision API] Error analyzing ${symbol}:`, errorMessage);
        // If analysis fails, mark as ignored to prevent retries
        const opportunityScanner = OpportunityScanner.getInstance();
        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\bot\optimize\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';
import { StrategyOptimizer } from '@/core/optimizer';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';

export async function POST() {
    try {
        const session = await getServerSession(authOptions);
        if (!session || !session.user?.name) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        const username = session.user.name;

        const portfolioService = new PortfolioService(username);
        const opportunityLogger = new OpportunityLogger(username);
        const decisionLogger = new DecisionLogger(username);
        const optimizer = new StrategyOptimizer();

        const trades = await portfolioService.getTradeLogs();
        const missedOpportunities = await opportunityLogger.getLogs();
        const decisionLogs = await decisionLogger.getLogs();

        if (trades.length === 0 && missedOpportunities.length === 0 && decisionLogs.length === 0) {
            return NextResponse.json({ error: 'No data available to analyze.' }, { status: 400 });
        }

        const analysis = await optimizer.analyze(trades, missedOpportunities, decisionLogs);
        return NextResponse.json(analysis);

    } catch (error) {
        console.error("An error occurred during optimization:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\bot\run\route.ts ---
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { NewsService } from '@/core/news';
import { CoinMarketCapService } from '@/core/coinmarketcap'; // Import CoinMarketCapService
import { PortfolioService } from '@/core/portfolio';
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, PortfolioAllocator, PositionManager, Analysis } from '@/core/agents';
import { SharedContext } from '@/core/context';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext
import fs from 'fs/promises';
import path from 'path';

export const dynamic = 'force-dynamic';

const statusFilePath = path.join(process.cwd(), 'bot-status.json');
const configFilePath = path.join(process.cwd(), 'config.json');

async function getBotStatus() {
    try {
        const data = await fs.readFile(statusFilePath, 'utf-8');
        return JSON.parse(data).status;
    } catch {
        return 'inactive';
    }
}

export async function GET(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        // Although this is a stream, we can't easily return a 401 here.
        // The client will simply see the stream end prematurely.
        // Proper handling would involve sending an error event through the stream.
        return new Response(null, { status: 401 });
    }
    const username = session.user.name;

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const sendEvent = (data: object) => {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
            };

            sendEvent({ type: 'log', message: 'Bot cycle initiated on the server.' });
            sendEvent({ type: 'aiChat', data: { agent: 'System', response: { summary: 'Hello! AI analysis cycle starting now...' } } });

            try {
                // Use the global shared context
                const sharedContext = globalSharedContext;
                
                const status = await getBotStatus();
                if (status !== 'active') {
                    sendEvent({ type: 'log', message: 'Bot is not active. Skipping cycle.' });
                    controller.close();
                    return;
                }

                sendEvent({ type: 'log', message: 'Initializing services...' });
                const binance = new BinanceService();
                sendEvent({ type: 'log', message: 'BinanceService OK.' });
                const newsService = new NewsService();
                sendEvent({ type: 'log', message: 'NewsService OK.' });
                const coinMarketCapService = new CoinMarketCapService(); // Initialize CoinMarketCapService
                sendEvent({ type: 'log', message: 'CoinMarketCapService OK.' });
                const portfolioService = new PortfolioService(username);
                sendEvent({ type: 'log', message: 'PortfolioService OK.' });
                const macroAnalyst = new MacroAnalyst();
                sendEvent({ type: 'log', message: 'MacroAnalyst OK.' });
                const sentimentAnalyst = new SentimentAnalyst();
                sendEvent({ type: 'log', message: 'SentimentAnalyst OK.' });
                const techAnalyst = new TechnicalAnalyst();
                sendEvent({ type: 'log', message: 'TechnicalAnalyst OK.' });
                const riskManager = new RiskManager();
                sendEvent({ type: 'log', message: 'RiskManager OK.' });
                const portfolioAllocator = new PortfolioAllocator();
                sendEvent({ type: 'log', message: 'PortfolioAllocator OK.' });
                const positionManager = new PositionManager();
                sendEvent({ type: 'log', message: 'PositionManager OK.' });
                const decisionLogger = new DecisionLogger(username);
                sendEvent({ type: 'log', message: 'DecisionLogger OK.' });
                const opportunityLogger = new OpportunityLogger(username);
                sendEvent({ type: 'log', message: 'OpportunityLogger OK.' });
                sendEvent({ type: 'log', message: 'All services initialized successfully.' });

                // 1. Load config
                const configData = await fs.readFile(configFilePath, 'utf-8');
                const config = JSON.parse(configData);
                let portfolio = await portfolioService.getPortfolio();

                // --- PHASE 1: MANAGE EXISTING POSITIONS ---
                sendEvent({ type: 'log', message: `Managing ${portfolio.positions.length} existing positions...` });
                for (const position of portfolio.positions) {
                    const currentPrice = await binance.getCurrentPrice(position.symbol);
                    if (!currentPrice) {
                        sendEvent({ type: 'log', message: `Could not fetch current price for ${position.symbol}. Skipping position management for this cycle.` });
                        continue;
                    }

                    const pnlPercent = (currentPrice - position.entryPrice) / position.entryPrice * 100;
                    const takeProfit = position.takeProfitPercent || config.takeProfitPercent;
                    const stopLoss = config.stopLossPercent;

                    if (pnlPercent <= stopLoss) {
                        // Stop Loss hit: automatically sell without AI consultation
                        sendEvent({ type: 'log', message: `Position ${position.symbol} hit STOP LOSS (P/L: ${pnlPercent.toFixed(2)}%). Automatically selling.` });
                        await portfolioService.sell(position.symbol, position.amount, currentPrice, { reason: 'Automatic Stop Loss' });
                        await decisionLogger.log({
                            symbol: position.symbol,
                            decision: 'SELL_NOW',
                            pnlPercent,
                            currentPrice,
                            justification: 'Automatic Stop Loss Triggered',
                        });
                        sendEvent({ type: 'log', message: `SOLD ${position.symbol} due to Stop Loss.` });
                    } else if (pnlPercent >= takeProfit) {
                        // Take Profit hit: consult AI for decision
                        sendEvent({ type: 'log', message: `Position ${position.symbol} hit TAKE PROFIT (P/L: ${pnlPercent.toFixed(2)}%). Invoking PositionManager...` });
                        
                        // We need macro and sentiment context for the decision
                        const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
                        const newsArticles = await newsService.getCryptoNews();
                        // Get Fear and Greed Index from global context
                        const fearAndGreedIndex = sharedContext.getContext().fearAndGreedIndex;
                const macroAnalysisResult = await macroAnalyst.analyze(
                    btcData[0] || {},
                    newsArticles.map(a => a.title),
                    fearAndGreedIndex, // Pass directly from shared context
                    sharedContext
                );
                const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, sharedContext);
                
                const decisionResult = await positionManager.decide(position, currentPrice, macroAnalysisResult?.response, sentimentAnalysisResult?.response, config, []);
                sendEvent({ type: 'aiChat', data: { agent: `PositionManager-${position.symbol}`, ...decisionResult } });

                        const decisionData = decisionResult?.response as { decision?: string; new_take_profit_percent?: number; justification?: string };
                        if (decisionData?.decision) {
                            await decisionLogger.log({
                                symbol: position.symbol,
                                decision: decisionData.decision as 'SELL_NOW' | 'HOLD_AND_INCREASE_TP',
                                pnlPercent,
                                currentPrice,
                                newTakeProfitPercent: decisionData.new_take_profit_percent,
                                justification: decisionData.justification || 'N/A',
                            });

                            if (decisionData.decision === 'SELL_NOW') {
                                await portfolioService.sell(position.symbol, position.amount, currentPrice, { reason: 'PositionManager decision' });
                                sendEvent({ type: 'log', message: `SOLD ${position.symbol} based on PositionManager decision.` });
                            } else if (decisionData.decision === 'HOLD_AND_INCREASE_TP' && decisionData.new_take_profit_percent) {
                                await portfolioService.updatePosition(position.symbol, { takeProfitPercent: decisionData.new_take_profit_percent });
                                sendEvent({ type: 'log', message: `HOLDING ${position.symbol}, new take-profit is ${decisionData.new_take_profit_percent}%.` });
                            }
                        }
                    }
                }
                // Refresh portfolio state after management phase
                portfolio = await portfolioService.getPortfolio();

                // --- PHASE 2: ANALYZE NEW TRADES ---
                if (portfolio.balance < config.minimumBalance) {
                    sendEvent({ type: 'log', message: `Balance is below ${config.minimumBalance}. Skipping new trade analysis.` });
                    controller.close();
                    return;
                }

                sendEvent({ type: 'log', message: 'Fetching market data for new trades...' });
                
                sendEvent({ type: 'log', message: '--> Fetching top symbols from Binance...' });
                const topSymbols = await binance.getTopSymbols();
                sendEvent({ type: 'log', message: `<-- Found ${topSymbols.length} symbols.` });
                // console.log('[Bot Run API] Top Symbols fetched:', topSymbols.map(s => s.symbol));

                sendEvent({ type: 'log', message: '--> Fetching BTC historical data...' });
                const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
                sendEvent({ type: 'log', message: '<-- BTC data fetched.' });

                sendEvent({ type: 'log', message: '--> Fetching crypto news...' });
                const newsArticles = await newsService.getCryptoNews();
                sendEvent({ type: 'log', message: `<-- Found ${newsArticles.length} news articles.` });

                sendEvent({ type: 'log', message: 'Running macro and sentiment analysis...' });
                sendEvent({ type: 'log', message: '--> Fetching Fear and Greed Index for global context...' });
                const fearAndGreedIndex = await coinMarketCapService.getFearAndGreedIndex(); // Fetch the latest index
                if (fearAndGreedIndex) {
                    sharedContext.updateContext({
                        fearAndGreedIndex: {
                            value: fearAndGreedIndex.value,
                            classification: fearAndGreedIndex.value_classification
                        }
                    });
                    sendEvent({ type: 'log', message: '<-- Fear and Greed Index updated in global context.' });
                } else {
                    sendEvent({ type: 'log', message: '<-- Failed to fetch Fear and Greed Index. Using previous or null value.' });
                }

                const btcLastCandle = btcData && btcData.length > 0 ? btcData[0] : {};
                const macroAnalysisResult = await macroAnalyst.analyze(
                    btcLastCandle,
                    newsArticles.map(a => a.title),
                    sharedContext.getContext().fearAndGreedIndex, // Get from global context
                    sharedContext
                );
                sendEvent({ type: 'context', data: sharedContext.getContext() });
                const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, sharedContext);
                sendEvent({ type: 'context', data: sharedContext.getContext() });

                const macroAnalysis = macroAnalysisResult?.response;
                const sentimentAnalysis = sentimentAnalysisResult?.response;

                // Phase 3: Dynamic Risk Management
                const adjustedConfig = riskManager.determineRiskParameters(config, sharedContext);
                if (JSON.stringify(config) !== JSON.stringify(adjustedConfig)) {
                    sendEvent({ type: 'log', message: `Risk parameters dynamically adjusted based on market context.` });
                    sendEvent({ type: 'adjusted_config', data: adjustedConfig });
                }

                sendEvent({ type: 'aiChat', data: { agent: 'MacroAnalyst', ...macroAnalysisResult } });
                sendEvent({ type: 'aiChat', data: { agent: 'SentimentAnalyst', ...sentimentAnalysisResult } });

                const macroScore = (macroAnalysis?.regime_score as number) || 0;
                if (macroScore < config.macroScoreThreshold) {
                    sendEvent({ type: 'log', message: `Market regime is 'Risk-Off' (Score: ${macroScore}). Holding off.` });
                    controller.close();
                    return;
                }

                sendEvent({ type: 'log', message: `Market is 'Risk-On' (Score: ${macroScore}). Analyzing top ${config.symbolsToAnalyze} symbols...` });

                const symbolsToAnalyze = topSymbols.slice(0, config.symbolsToAnalyze);
                const BATCH_SIZE = config.batchSize;
                
                const batches = [];
                for (let i = 0; i < symbolsToAnalyze.length; i += BATCH_SIZE) {
                    batches.push(symbolsToAnalyze.slice(i, i + BATCH_SIZE));
                }

                sendEvent({ type: 'log', message: `Analyzing ${symbolsToAnalyze.length} symbols in ${batches.length} parallel batches...` });

                const batchPromises = batches.map(async (batch, index) => {
                    sendEvent({ type: 'log', message: `Starting analysis for batch #${index + 1}...` });
                    
                    const batchDataPromises = batch.map(ticker => 
                        binance.getHistoricalData(ticker.symbol, '5m', 100).then(candles => ({
                            symbol: ticker.symbol,
                            candles
                        }))
                    );
                    const batchData = await Promise.all(batchDataPromises);
                    const validBatchData = batchData.filter(d => d.candles.length > 0);

                    const techAnalysisResult = await techAnalyst.analyzeBatch(validBatchData, adjustedConfig);
                    sendEvent({ type: 'aiChat', data: { agent: `TechnicalAnalyst-Batch-${index + 1}`, ...techAnalysisResult } });
                const techAnalyses = techAnalysisResult?.response || {};

                const riskManagerResult = await riskManager.decideBatch(Object.values(techAnalyses) as Analysis[], macroAnalysis, sentimentAnalysis);
                sendEvent({ type: 'aiChat', data: { agent: `RiskManager-Batch-${index + 1}`, ...riskManagerResult } });
                const finalDecisions = riskManagerResult?.response || {};

                    const buySignals = [];
                    for (const symbol in finalDecisions) {
                        const decision = finalDecisions[symbol] as { decision?: string, confidence_score?: number, final_summary?: string };
                        if (decision.decision === 'BUY') {
                            buySignals.push({ symbol, ...decision });
                        } else if (decision.decision === 'AVOID') {
                            await opportunityLogger.log({
                                symbol,
                                priceChangePercent: 0, // Default since not tracked in batch
                                reason: 'AVOID decision by RiskManager',
                                confidenceScore: decision.confidence_score,
                                finalSummary: decision.final_summary,
                            });
                        }
                    }
                    sendEvent({ type: 'log', message: `Batch #${index + 1} analysis complete. Found ${buySignals.length} BUY signals.` });
                    return buySignals;
                });

                const results = await Promise.all(batchPromises);
                const allBuySignals = results.flat();

                if (allBuySignals.length > 0) {
                    sendEvent({ type: 'log', message: `Found ${allBuySignals.length} total BUY signals. Allocating portfolio...` });
                    const allocationResult = await portfolioAllocator.allocate(allBuySignals, portfolio, macroAnalysis, sentimentAnalysis, sharedContext);
                    sendEvent({ type: 'context', data: sharedContext.getContext() });
                    sendEvent({ type: 'aiChat', data: { agent: 'PortfolioAllocator', ...allocationResult } });
                    const allocations = allocationResult?.response || {};

                    console.log('[RUN ROUTE] Allocations received:', JSON.stringify(allocations, null, 2));

                    for (const symbol in allocations) {
                        const allocation = allocations[symbol] as { decision?: string; amount_to_buy_usd?: number };
                        if (allocation.decision === 'EXECUTE_BUY' && typeof allocation.amount_to_buy_usd === 'number') {
                            try {
                                const price = await binance.getCurrentPrice(symbol);
                                if (price) {
                                    const amountToBuy = allocation.amount_to_buy_usd / price;
                                    await portfolioService.buy(symbol, amountToBuy, price);
                                    sendEvent({ type: 'log', message: `BOUGHT ${amountToBuy.toFixed(5)} of ${symbol} for ${allocation.amount_to_buy_usd.toFixed(2)} USD` });
                                    portfolio = await portfolioService.getPortfolio(); // Refresh portfolio state for the next iteration
                                }
                            } catch (e) {
                                const errorMessage = e instanceof Error ? e.message : String(e);
                                sendEvent({ type: 'log', message: `Failed to buy ${symbol}: ${errorMessage}` });
                            }
                        }
                    }
                } else {
                    sendEvent({ type: 'log', message: 'No strong BUY signals found in this cycle.' });
                }

                sendEvent({ type: 'log', message: 'Bot cycle finished.' });
                controller.close();

            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                sendEvent({ type: 'error', message: errorMessage });
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\bot\status\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const statusFilePath = path.join(process.cwd(), 'bot-status.json');

async function getBotStatus() {
    try {
        const data = await fs.readFile(statusFilePath, 'utf-8');
        return JSON.parse(data).status;
    } catch {
        return 'inactive';
    }
}

async function setBotStatus(status: 'active' | 'inactive') {
    await fs.writeFile(statusFilePath, JSON.stringify({ status }));
}

export async function GET() {
    const status = await getBotStatus();
    return NextResponse.json({ status });
}

export async function POST(request: Request) {
    const { status } = await request.json();
    if (status === 'active' || status === 'inactive') {
        await setBotStatus(status);
        return NextResponse.json({ status });
    }
    return NextResponse.json({ error: 'Invalid status' }, { status: 400 });
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\chart-data\route.ts ---
import { NextRequest, NextResponse } from 'next/server';
import { BinanceService } from '@/core/binance';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const symbol = searchParams.get('symbol');

    if (!symbol) {
        return NextResponse.json({ error: 'Symbol parameter is required' }, { status: 400 });
    }

    try {
        const binanceService = new BinanceService();
        // Fetching 1-day interval data for a broader view
        const candles = await binanceService.getHistoricalData(symbol, '1d', 365); 
        
        const formattedData = candles.map(c => ({
            time: c.time,
            open: c.open,
            high: c.high,
            low: c.low,
            close: c.close,
        }));

        return NextResponse.json(formattedData);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error fetching chart data for ${symbol}: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\dashboard-data\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { PortfolioService } from '@/core/portfolio';
import { CoinMarketCapService } from '@/core/coinmarketcap';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext

export const dynamic = 'force-dynamic';

export async function GET() {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        console.error("[DashboardData API] Unauthorized access attempt: No session or username.");
        return NextResponse.json({ error: 'Unauthorized: Please log in.' }, { status: 401 });
    }

    try {
        const username = session.user.name;
        const binance = new BinanceService();
        const portfolioService = new PortfolioService(username);
        // const coinMarketCapService = new CoinMarketCapService(); // No longer needed here

        const topSymbols = await binance.getTopSymbols(50);
        const portfolio = await portfolioService.getPortfolio();
        // Get Fear and Greed Index from global context
        const fearAndGreedIndex = globalSharedContext.getContext().fearAndGreedIndex;

        console.log('[DashboardData API] Fear and Greed Index:', fearAndGreedIndex);

        const marketDataSymbols = new Set(topSymbols.map(s => s.symbol));
        const combinedMarketData = [...topSymbols];

        for (const position of portfolio.positions) {
            if (!marketDataSymbols.has(position.symbol)) {
                const currentPrice = await binance.getCurrentPrice(position.symbol);
                if (currentPrice !== null) {
                    // Create a Ticker object with available data and dummy values for others
                    combinedMarketData.push({
                        symbol: position.symbol,
                        lastPrice: currentPrice.toString(),
                        priceChange: '0', // Dummy
                        priceChangePercent: '0', // Dummy
                        weightedAvgPrice: '0', // Dummy
                        prevClosePrice: '0', // Dummy
                        lastQty: '0', // Dummy
                        bidPrice: '0', // Dummy
                        bidQty: '0', // Dummy
                        askPrice: '0', // Dummy
                        askQty: '0', // Dummy
                        openPrice: '0', // Dummy
                        highPrice: '0', // Dummy
                        lowPrice: '0', // Dummy
                        volume: '0', // Dummy
                        quoteVolume: '0', // Dummy
                        openTime: 0, // Dummy
                        closeTime: 0, // Dummy
                        firstId: 0, // Dummy
                        lastId: 0, // Dummy
                        count: 0, // Dummy
                    });
                    marketDataSymbols.add(position.symbol); // Add to set to avoid duplicates
                } else {
                    console.warn(`[DashboardData API] Could not fetch current price for portfolio symbol: ${position.symbol}`);
                }
            }
        }

        // console.log('[DashboardData API] Sending marketData to frontend:', combinedMarketData.map(d => d.symbol));
        return NextResponse.json({ marketData: combinedMarketData, portfolio, fearAndGreedIndex });

    } catch (error) {
        console.error("[DashboardData API] Error fetching dashboard data:", error);
        return NextResponse.json({ error: `Internal Server Error: ${(error as Error).message}` }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\decisions\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

// Define the interface for consistency with other parts of the app
interface DecisionLog {
    [symbol: string]: {
        timestamp: string;
        decision: string;
        justification: string;
        pnlPercent: number;
        currentPrice: number;
    }[];
}

const decisionLogPath = path.join(process.cwd(), 'decision_log.json');

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const data = await fs.readFile(decisionLogPath, 'utf-8');
        const decisionLog: DecisionLog = JSON.parse(data);
        return NextResponse.json(decisionLog);
    } catch (error) {
        // Check if the error is a file system error for a missing file
        if (error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === 'ENOENT') {
            return NextResponse.json({}); // Return empty object if file doesn't exist
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error fetching decision log: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\history\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';

export async function GET() {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const portfolioService = new PortfolioService(username);
        const tradeLogs = await portfolioService.getTradeLogs();
        return NextResponse.json(tradeLogs);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Error fetching trade history:", errorMessage);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\market-stream\route.ts ---
import WebSocket from 'ws';
import { OpportunityScanner } from '@/core/opportunity-scanner';
import { BinanceService } from '@/core/binance';
import { TechnicalAnalyst, RiskManager, PortfolioAllocator } from '@/core/agents';
import { SharedContext } from '@/core/context';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';
import { PortfolioService } from '@/core/portfolio';
import fs from 'fs/promises';
import path from 'path';

// Assuming a default username for now, as market-stream doesn't have session context
const DEFAULT_USERNAME = 'admin';

let ws: WebSocket | null = null;
const trackedSymbols: { [symbol: string]: { price: number; time: number } } = {};

const configFilePath = path.join(process.cwd(), 'config.json');

async function getConfig() {
    try {
        const data = await fs.readFile(configFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        console.error("Failed to read config.json:", error);
        // Return default values if config.json is not found or corrupted
        return {
            fastMoverTimeMinutes: 5,
            fastMoverPriceChangePercent: 5.0
        };
    }
}

async function connectAndStream(controller: ReadableStreamDefaultController<Uint8Array>) {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        console.log('[MarketStream] WebSocket is already connected.');
        return;
    }

    const config = await getConfig();
    const FAST_MOVER_TIME_MS = (config.fastMoverTimeMinutes || 5) * 60 * 1000;
    const FAST_MOVER_PRICE_CHANGE_PERCENT = config.fastMoverPriceChangePercent || 5.0;

    console.log('[MarketStream] Connecting to Binance WebSocket for client stream...');
    ws = new WebSocket('wss://stream.binance.com:9443/ws/!ticker@arr');
    const encoder = new TextEncoder();

    ws.on('open', () => {
        console.log('[MarketStream] Client stream connection established.');
    });

    ws.on('message', async (data: WebSocket.Data) => {
        const tickers = JSON.parse(data.toString());
        const opportunityScanner = OpportunityScanner.getInstance();
        const opportunityLogger = new OpportunityLogger(DEFAULT_USERNAME); // Moved declaration here
        
        // Send the raw ticker data to the client for real-time price updates
        // Check if the controller is still open before enqueuing
        if (controller.desiredSize !== null && controller.desiredSize > 0) {
            controller.enqueue(encoder.encode(`data: ${JSON.stringify(tickers)}\n\n`));
        } else {
            console.warn('[MarketStream] Controller is closed or full, cannot enqueue data.');
        }

        // Also, process for opportunities internally
        for (const ticker of tickers) {
            const symbol = ticker.s;
            const price = parseFloat(ticker.c);
            const now = Date.now();

            if (!trackedSymbols[symbol]) {
                trackedSymbols[symbol] = { price, time: now };
                continue;
            }

            const initialData = trackedSymbols[symbol];
            if (now - initialData.time > FAST_MOVER_TIME_MS) {
                trackedSymbols[symbol] = { price, time: now };
            } else {
                const priceChangePercent = ((price - initialData.price) / initialData.price) * 100;
                if (priceChangePercent > FAST_MOVER_PRICE_CHANGE_PERCENT) {
                    console.log(`[MarketStream] OPPORTUNITY DETECTED: ${symbol} increased by ${priceChangePercent.toFixed(2)}%`);
                    await opportunityScanner.addOpportunity({ symbol, priceChangePercent });
                    trackedSymbols[symbol] = { price, time: now };

                    // --- AI Analysis and Decision for Fast Mover ---
                    console.log(`[MarketStream] Triggering AI analysis for fast mover: ${symbol}`);
                    try {
                        const binanceService = new BinanceService();
                        const technicalAnalyst = new TechnicalAnalyst();
                        const riskManager = new RiskManager();
                        const portfolioAllocator = new PortfolioAllocator();
                        // const opportunityLogger = new OpportunityLogger(DEFAULT_USERNAME); // Removed from here
                        const decisionLogger = new DecisionLogger(DEFAULT_USERNAME);
                        const portfolioService = new PortfolioService(DEFAULT_USERNAME);
                        const sharedContext = new SharedContext(); // Assuming a new context for this specific analysis

                        // Fetch historical data for technical analysis
                        const candles = await binanceService.getHistoricalData(symbol, '1m', 100); // 1-minute candles for recent data
                        if (candles.length === 0) {
                            console.warn(`[MarketStream] No historical data for ${symbol}, skipping AI analysis.`);
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            continue;
                        }

                        // Perform technical analysis
                        const techAnalysisResult = await technicalAnalyst.analyze(symbol, candles, config);
                        if (!techAnalysisResult) {
                            console.warn(`[MarketStream] Technical analysis failed for ${symbol}, skipping AI analysis.`);
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            continue;
                        }

                        // For fast movers, we might not have fresh macro/sentiment.
                        // For simplicity, we'll use dummy or default values for now,
                        // or assume they are updated by the main bot cycle.
                        // In a real scenario, these would be passed from a global context or fetched.
                        const dummyMacroAnalysis = { marketMode: 'Risk-On' }; // Placeholder
                        const dummySentimentAnalysis = { sentiment: 'Bullish' }; // Placeholder

                        // Make a decision
                        // The Analysis object should contain MacroAnalyst, SentimentAnalyst, and then symbol-specific data
                        const analysisForRiskManager = {
                            MacroAnalyst: dummyMacroAnalysis,
                            SentimentAnalyst: dummySentimentAnalysis,
                            [symbol]: {
                                technicalAnalysis: techAnalysisResult.response,
                            }
                        };

                        const decisionResult = await riskManager.decideBatch(
                            [analysisForRiskManager], // Pass as an array of Analysis objects
                            dummyMacroAnalysis, // These are passed separately to the prompt, but also part of the Analysis object
                            dummySentimentAnalysis
                        );

                        if (decisionResult && decisionResult.response && typeof decisionResult.response === 'object') {
                            const decisionForSymbol = (decisionResult.response as Record<string, unknown>)[symbol];
                            if (decisionForSymbol && typeof decisionForSymbol === 'object') {
                                const decision = (decisionForSymbol as { decision: string }).decision;
                                console.log(`[MarketStream] AI Decision for ${symbol}:`, decisionForSymbol);

                                if (decision === 'BUY') {
                                    const buySignals = [{ symbol, price, analysis: techAnalysisResult.response }];
                                    const allocationResult = await portfolioAllocator.allocate(buySignals, await portfolioService.getPortfolio(), dummyMacroAnalysis, dummySentimentAnalysis, sharedContext);

                                    if (allocationResult && allocationResult.response && (allocationResult.response as { allocatedAmount: number }).allocatedAmount > 0) {
                                        const amountToBuy = (allocationResult.response as { allocatedAmount: number }).allocatedAmount;
                                        await portfolioService.buy(symbol, amountToBuy, price);
                                        await opportunityScanner.updateOpportunityStatus(symbol, 'bought');
                                        await decisionLogger.log({
                                            symbol,
                                            decision: 'BUY',
                                            currentPrice: price,
                                            amount: amountToBuy,
                                            reason: (allocationResult.response as { reason: string }).reason || 'Fast Mover Buy'
                                        });
                                        console.log(`[MarketStream] Successfully bought ${amountToBuy} of ${symbol}`);
                                    } else {
                                        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                        await opportunityLogger.log({
                                            symbol,
                                            priceChangePercent,
                                            reason: 'AI decided to BUY but allocation failed or was zero.'
                                        });
                                        console.warn(`[MarketStream] AI decided to BUY ${symbol}, but allocation was zero or failed.`);
                                    }
                                } else {
                                    await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                    await opportunityLogger.log({
                                        symbol,
                                        priceChangePercent,
                                        reason: (decisionForSymbol as { final_summary?: string; reason?: string }).final_summary || (decisionForSymbol as { final_summary?: string; reason?: string }).reason || `AI decided to ${decision}`
                                    });
                                    console.log(`[MarketStream] AI decided to ${decision} ${symbol}.`);
                                }
                            } else {
                                await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                await opportunityLogger.log({
                                    symbol,
                                    priceChangePercent,
                                    reason: 'AI decision for symbol not found in batch response.'
                                });
                                console.warn(`[MarketStream] AI decision for ${symbol} not found in batch response.`);
                            }
                        } else {
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            await opportunityLogger.log({
                                symbol,
                                priceChangePercent,
                                reason: 'AI decision process failed or returned no decision.'
                            });
                            console.warn(`[MarketStream] AI decision process failed for ${symbol}.`);
                        }

                    } catch (aiError) {
                        console.error(`[MarketStream] Error during AI analysis for ${symbol}:`, aiError);
                        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                        await opportunityLogger.log({
                            symbol,
                            priceChangePercent,
                            reason: `Error during AI analysis: ${(aiError as Error).message}`
                        });
                    }
                    // --- End AI Analysis and Decision for Fast Mover ---
                }
            }
        }
    });

    ws.on('close', () => {
        console.log('[MarketStream] Client stream closed.');
        ws = null;
        try {
            controller.close();
        } catch (e) {
            // Controller might already be closed
        }
    });

    ws.on('error', (error: unknown) => {
        console.error('[MarketStream] Client stream error:', error);
        try {
            controller.error(error);
            ws?.close();
        } catch (e) {
            // Controller might already be closed
        }
    });
}

export async function GET(req: Request) {
    const stream = new ReadableStream({
        start(controller) {
            connectAndStream(controller);
        },
        cancel() {
            console.log('[MarketStream] Client disconnected, closing WebSocket.');
            ws?.close();
            ws = null;
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\missed-opportunities\route.ts ---
// src/app/api/missed-opportunities/route.ts
import { NextResponse } from 'next/server';
import { OpportunityLogger } from '@/core/opportunity-logger';

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const opportunityLogger = new OpportunityLogger();
        const logs = await opportunityLogger.getLogs();
        return NextResponse.json(logs);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Failed to fetch missed opportunities:", errorMessage);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\news\route.ts ---
import { NextResponse } from 'next/server';
import { NewsService } from '@/core/news';

export async function GET() {
    try {
        const newsService = new NewsService();
        const articles = await newsService.getCryptoNews('crypto', 20);
        return NextResponse.json({ articles });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\opportunities\route.ts ---
import { NextResponse } from 'next/server';
import { OpportunityScanner } from '@/core/opportunity-scanner';

export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
    try {
        const scanner = OpportunityScanner.getInstance();
        const opportunities = scanner.getOpportunities();
        return NextResponse.json(opportunities);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\portfolio\sell\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';
import { BinanceService } from '@/core/binance';

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const { symbol, amount } = await req.json();
        if (!symbol || !amount) {
            return NextResponse.json({ error: 'Symbol and amount are required' }, { status: 400 });
        }

        const portfolioService = new PortfolioService(username);
        const binanceService = new BinanceService();

        const currentPrice = await binanceService.getCurrentPrice(symbol);
        if (!currentPrice) {
            return NextResponse.json({ error: 'Could not fetch current price' }, { status: 500 });
        }

        await portfolioService.sell(symbol, amount, currentPrice, { reason: 'Manual sell' });

        const updatedPortfolio = await portfolioService.getPortfolio();
        return NextResponse.json(updatedPortfolio);

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error in sell API: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\portfolio\update\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const { symbol, updates } = await req.json();
        if (!symbol || !updates) {
            return NextResponse.json({ error: 'Symbol and updates are required' }, { status: 400 });
        }

        const portfolioService = new PortfolioService(username);
        await portfolioService.updatePosition(symbol, updates);

        return NextResponse.json({ success: true });

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error in update API: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\reset-logs\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const logFiles = [
    'bot_logs.json',
    'buy_log.json',
    'decision_log.json',
    'missed_opportunities.json',
    'trades_log.json',
];

const initialPortfolio = { balance: 100000, positions: [] };

export async function POST(request: Request) {
    try {
        // Get username from request (assuming it's passed in the body or headers)
        // For now, I'll assume a default or extract from a common source if available.
        // Based on portfolio.ts, the log files are username-specific.
        // I need to ensure the reset targets the correct user's files.
        // For simplicity, I'll assume the request body will contain the username.
        // If not, I'll need to ask the user how the username is passed.
        const { username } = await request.json();

        if (!username) {
            return NextResponse.json({ error: 'Username is required for resetting logs.' }, { status: 400 });
        }

        // Clear log files
        for (const file of logFiles) {
            const filePath = path.join(process.cwd(), file.replace('.json', `_${username}.json`));
            try {
                await fs.writeFile(filePath, '[]', 'utf-8');
            } catch (error) {
                if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
                    console.warn(`Log file not found, creating: ${filePath}`);
                    await fs.writeFile(filePath, '[]', 'utf-8');
                } else {
                    console.error(`Failed to clear log file ${filePath}:`, error);
                    throw error;
                }
            }
        }

        // Reset portfolio.json
        const portfolioFilePath = path.join(process.cwd(), `portfolio_${username}.json`);
        try {
            await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2), 'utf-8');
        } catch (error) {
            if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
                console.warn(`Portfolio file not found, creating: ${portfolioFilePath}`);
                await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2), 'utf-8');
            } else {
                console.error(`Failed to reset portfolio file ${portfolioFilePath}:`, error);
                throw error;
            }
        }

        return NextResponse.json({ message: 'All logs and portfolio reset successfully.' });
    } catch (error) {
        console.error('Error resetting logs:', error);
        return NextResponse.json({ error: 'Failed to reset logs.' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\api\settings\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function GET() {
    try {
        const data = await fs.readFile(configFilePath, 'utf-8');
        return NextResponse.json(JSON.parse(data));
    } catch {
        return NextResponse.json({ error: 'Failed to read settings' }, { status: 500 });
    }
}

export async function POST(request: Request) {
    try {
        const settings = await request.json();
        await fs.writeFile(configFilePath, JSON.stringify(settings, null, 2));
        return NextResponse.json({ message: 'Settings saved' });
    } catch {
        return NextResponse.json({ error: 'Failed to save settings' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\auth\signin\page.tsx ---
"use client";

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';

export default function SignInPage() {
    const [isRegister, setIsRegister] = useState(false);
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const router = useRouter();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setIsLoading(true);

        if (isRegister) {
            try {
                const res = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password }),
                });

                if (res.ok) {
                    toast.success('Registration successful! Please sign in.');
                    setIsRegister(false);
                } else {
                    const data = await res.json();
                    toast.error(data.error || 'Registration failed.');
                }
            } catch (error) {
                toast.error('An error occurred during registration.');
            }
        } else {
            const result = await signIn('credentials', {
                redirect: false,
                username,
                password,
            });

            if (result?.ok) {
                router.push('/dashboard');
            } else {
                toast.error(result?.error || 'Invalid credentials.');
            }
        }
        setIsLoading(false);
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-lg shadow-lg">
                <h1 className="text-2xl font-bold text-center">
                    {isRegister ? 'Register' : 'Sign In'}
                </h1>
                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium">Username</label>
                        <input
                            type="text"
                            value={username}
                            onChange={(e) => setUsername(e.target.value)}
                            className="w-full px-3 py-2 mt-1 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring focus:ring-indigo-500"
                            required
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium">Password</label>
                        <input
                            type="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            className="w-full px-3 py-2 mt-1 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring focus:ring-indigo-500"
                            required
                        />
                    </div>
                    <button
                        type="submit"
                        disabled={isLoading}
                        className="w-full py-2 font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:opacity-50"
                    >
                        {isLoading ? 'Loading...' : (isRegister ? 'Register' : 'Sign In')}
                    </button>
                </form>
                <p className="text-sm text-center">
                    {isRegister ? 'Already have an account?' : "Don't have an account?"}
                    <button onClick={() => setIsRegister(!isRegister)} className="ml-1 font-semibold text-indigo-400 hover:underline">
                        {isRegister ? 'Sign In' : 'Register'}
                    </button>
                </p>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\layout.tsx ---
"use client";

import { useState } from 'react';
import { Sidebar } from '@/components/sidebar';
import { Header } from '@/components/header';
import { DashboardProvider } from '@/context/DashboardContext';

export default function DashboardLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const [sidebarOpen, setSidebarOpen] = useState(false);

    return (
        <DashboardProvider>
            <div className="flex h-screen bg-gray-800">
                <Sidebar sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
                <div className="flex-1 flex flex-col overflow-hidden">
                    <Header setSidebarOpen={setSidebarOpen} />
                    <main className="flex-1 p-4 md:p-8 overflow-y-auto">
                        {children}
                    </main>
                </div>
            </div>
        </DashboardProvider>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\page.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { MarketTable } from '@/components/market-table';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel } from '@/components/analysis-panel';
import { AiChatWindow } from '@/components/ai-chat-window';
import { NewsFeed } from '@/components/news-feed';
import { Chart } from '@/components/chart';
import { DecisionLog } from '@/components/decision-log';
import { SharedContextDisplay } from '@/components/shared-context-display';
import { DynamicRiskDisplay } from '@/components/dynamic-risk-display';
import { OpportunityLog } from '@/components/opportunity-log';
import { DollarSign, TrendingUp, Wallet } from 'lucide-react';

export default function Dashboard() {
    const { state } = useDashboard();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            {/* Row 1: KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <KpiCard title="Total Value" kpiKey="totalValue" icon={<Wallet size={24} />} />
                <KpiCard title="24h P/L" kpiKey="24h_pnl" icon={<TrendingUp size={24} />} />
                <KpiCard title="Free Collateral" kpiKey="freeCollateral" icon={<DollarSign size={24} />} />
            </div>

            {/* Row 2: Hive Mind & Risk Context */}
            <div className="space-y-6">
                <SharedContextDisplay context={state.sharedContext} />
                <DynamicRiskDisplay />
            </div>

            {/* Row 3: Main Grid */}
            <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                {/* Main Content Column */}
                <div className="xl:col-span-2 space-y-6">
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h2 className="text-lg font-semibold mb-4">{state.selectedSymbol} Price Chart</h2>
                        <Chart />
                    </div>
                    <div>
                        <h2 className="text-lg font-semibold mb-4">AI Analysis Cycle: Latest Buys</h2>
                        <AnalysisPanel />
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <AiChatWindow />
                    </div>
                    <DecisionLog />
                </div>

                {/* Side Column */}
                <div className="xl:col-span-1 space-y-6">
                    <MarketTable />
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h2 className="font-semibold text-md mb-2">Live Logs</h2>
                        <div className="bg-gray-900 text-white p-2 rounded-lg h-64 overflow-y-auto text-xs space-y-1 font-mono">
                            {state.logs.map((log, index) => (
                                <p key={index}>{log}</p>
                            ))}
                        </div>
                    </div>
                    <NewsFeed />
                    <OpportunityLog />
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\backtest\page.tsx ---
"use client";

import { useState, useEffect } from 'react';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel, Analysis } from '@/components/analysis-panel'; // Assuming this can be reused

// Define interfaces for our state
interface Trade {
    date: string;
    action: 'BUY' | 'SELL';
    price: number;
}

export default function BacktestPage() {
    const [symbol, setSymbol] = useState('BTCUSDT');
    const [startDate, setStartDate] = useState('2023-01-01');
    const [endDate, setEndDate] = useState('2023-01-31');
    const [interval, setInterval] = useState('1h');
    const [isLoading, setIsLoading] = useState(false);
    
    const [logs, setLogs] = useState<string[]>([]);
    const [trades, setTrades] = useState<Trade[]>([]);
    const [currentAnalysis, setCurrentAnalysis] = useState<Analysis | null>(null);
    const [pnl, setPnl] = useState(0);

    const runBacktest = async () => {
        setIsLoading(true);
        setLogs([]);
        setTrades([]);
        setCurrentAnalysis(null);
        setPnl(0);

        const response = await fetch('/api/bot/backtest', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ symbol, startDate, endDate, interval }),
        });

        if (!response.body) return;
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                setIsLoading(false);
                break;
            }
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
            
            for (const line of lines) {
                const json = JSON.parse(line.replace('data: ', ''));
                if (json.type === 'log') {
                    setLogs(prev => [...prev, json.message]);
                } else if (json.type === 'analysis') {
                    setCurrentAnalysis(json.data);
                } else if (json.type === 'trade') {
                    setTrades(prev => [...prev, json.data]);
                }
            }
        }
    };
    
    useEffect(() => {
        let calculatedPnl = 0;
        for (let i = 0; i < trades.length; i += 2) {
            if (trades[i+1]) {
                calculatedPnl += trades[i+1].price - trades[i].price;
            }
        }
        setPnl(calculatedPnl);
    }, [trades]);

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Strategy Backtesting</h1>
            
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Symbol</label>
                        <input type="text" value={symbol} onChange={(e) => setSymbol(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Start Date</label>
                        <input type="date" value={startDate} onChange={(e) => setStartDate(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">End Date</label>
                        <input type="date" value={endDate} onChange={(e) => setEndDate(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Interval</label>
                        <select value={interval} onChange={(e) => setInterval(e.target.value)} className="bg-gray-700 rounded p-2 w-full">
                            <option value="1m">1m</option>
                            <option value="5m">5m</option>
                            <option value="15m">15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                        </select>
                    </div>
                    <button onClick={runBacktest} disabled={isLoading} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full">
                        {isLoading ? 'Running...' : 'Run Backtest'}
                    </button>
                </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-2">
                    {currentAnalysis ? <AnalysisPanel analysis={currentAnalysis} /> : <div className="bg-gray-800 p-4 rounded-lg h-full"><h2 className="font-bold text-lg">AI Analysis</h2><p>Waiting for data...</p></div>}
                </div>
                <div className="lg:col-span-1">
                    <div className="bg-gray-800 p-4 rounded-lg mb-4">
                        <h2 className="text-xl font-bold mb-4">Backtest Results</h2>
                        <div className="grid grid-cols-3 gap-4">
                            <KpiCard title="Initial Balance" value={`€10000.00`} icon={<div />} />
                            <KpiCard title="Total P/L" value={`€${pnl.toFixed(2)}`} color={pnl > 0 ? 'text-green-400' : 'text-red-400'} icon={<div />} />
                            <KpiCard title="Total Trades" value={trades.length} icon={<div />} />
                        </div>
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h3 className="font-bold mb-2">Live Trades</h3>
                        <div className="h-48 overflow-y-auto">
                            {trades.map((trade, index) => (
                                <div key={index} className={`p-2 rounded mb-2 text-sm ${trade.action === 'BUY' ? 'bg-green-900' : 'bg-red-900'}`}>
                                    {trade.date}: {trade.action} @ {trade.price.toFixed(2)}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="mt-8 bg-gray-800 text-white p-4 rounded-lg h-[30vh] overflow-y-auto">
                <h2 className="font-bold text-lg mb-2">Live Logs</h2>
                <pre className="text-sm overflow-x-auto whitespace-pre-wrap">
                    {logs.map((log, index) => (
                        <p key={index} className="font-mono">{log}</p>
                    ))}
                </pre>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\history\page.tsx ---
"use client";

import { useEffect, useState } from 'react';
import toast from 'react-hot-toast';

interface TradeLog {
    symbol: string;
    entryPrice: number;
    exitPrice: number;
    pnl: number;
    analysisContext: {
        reason: string;
    };
}

export default function HistoryPage() {
    const [tradeHistory, setTradeHistory] = useState<TradeLog[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchHistory() {
            setIsLoading(true);
            try {
                const response = await fetch('/api/history');
                if (!response.ok) throw new Error('Failed to fetch trade history.');
                const data = await response.json();
                setTradeHistory(data);
            } catch (error) {
                toast.error("Could not load trade history.");
                console.error(error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchHistory();
    }, []);

    if (isLoading) {
        return <div>Loading trade history...</div>;
    }

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Trade History</h1>
            <div className="bg-gray-800 p-4 rounded-lg">
                <div className="overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr className="border-b border-gray-700">
                                <th className="text-left p-2">Symbol</th>
                                <th className="text-left p-2">Entry Price</th>
                                <th className="text-left p-2">Exit Price</th>
                                <th className="text-left p-2">P/L</th>
                                <th className="text-left p-2">Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            {tradeHistory.length > 0 ? (
                                tradeHistory.map((trade, index) => (
                                    <tr key={index} className="border-b border-gray-700">
                                        <td className="p-2">{trade.symbol}</td>
                                        <td className="p-2">€{trade.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className="p-2">€{trade.exitPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className={`p-2 ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            €{trade.pnl.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                        </td>
                                        <td className="p-2">{trade.analysisContext?.reason || 'N/A'}</td>
                                    </tr>
                                ))
                            ) : (
                                <tr>
                                    <td colSpan={5} className="text-center p-4">No trade history found.</td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\optimization\page.tsx ---
"use client";

import { useState, useEffect } from 'react';
import toast from 'react-hot-toast';
import { MissedOpportunity } from '@/core/opportunity-logger';

// Define interfaces for our state and props
interface Settings {
    [key: string]: string | number;
}

interface Analysis {
    analysis_summary: string;
    suggested_settings: Settings;
}

const SETTING_DESCRIPTIONS: { [key: string]: string } = {
    sellStrategy: "The strategy for selling assets (e.g., takeProfit).",
    takeProfitPercent: "The percentage gain at which to consider selling.",
    stopLossPercent: "The percentage loss at which to sell.",
    trailingStopPercent: "The percentage for the trailing stop loss.",
    riskAmountPercent: "The percentage of the balance to risk on a single trade.",
    rsiPeriod: "The period for the Relative Strength Index (RSI) calculation.",
    symbolsToAnalyze: "The number of top symbols to analyze each cycle.",
    batchSize: "The number of symbols to analyze in a single batch.",
    macroScoreThreshold: "The minimum macro score required to consider buying.",
    minimumBalance: "The minimum balance required to run the bot.",
    cycleIntervalMinutes: "The interval in minutes between buy cycles.",
    smaShortPeriod: "The short period for the Simple Moving Average (SMA).",
    smaLongPeriod: "The long period for the Simple Moving Average (SMA).",
    macdShortPeriod: "The short period for MACD.",
    macdLongPeriod: "The long period for MACD.",
    macdSignalPeriod: "The signal period for MACD."
};

export default function OptimizationPage() {
    const [analysis, setAnalysis] = useState<Analysis | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [currentSettings, setCurrentSettings] = useState<Settings | null>(null);
    const [missedOpportunities, setMissedOpportunities] = useState<MissedOpportunity[]>([]);

    useEffect(() => {
        async function fetchData() {
            try {
                const settingsResponse = await fetch('/api/settings');
                const settingsData = await settingsResponse.json();
                setCurrentSettings(settingsData);

                const opportunitiesResponse = await fetch('/api/missed-opportunities');
                const opportunitiesData = await opportunitiesResponse.json();
                setMissedOpportunities(opportunitiesData);

            } catch (error) {
                console.error("Failed to fetch page data:", error);
                toast.error("Could not load page data.");
            }
        }
        fetchData();
    }, []);

    const runOptimization = async () => {
        setIsLoading(true);
        setAnalysis(null);
        const toastId = toast.loading("AI is analyzing trade history...");
        try {
            const response = await fetch('/api/bot/optimize', {
                method: 'POST',
            });
            if (!response.ok) throw new Error('Optimization failed');
            const data = await response.json();
            setAnalysis(data.response);
            toast.success("AI analysis complete!", { id: toastId });
        } catch (error) {
            console.error(error);
            toast.error("Optimization analysis failed.", { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    const applyAiSettings = async () => {
        if (!analysis?.suggested_settings) return;
        const toastId = toast.loading("Applying AI-learned settings...");
        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(analysis.suggested_settings),
            });
            if (!response.ok) throw new Error('Failed to apply settings');
            const newSettings = await response.json();
            setCurrentSettings(newSettings);
            toast.success("AI settings applied successfully! The bot will use these on the next cycle.", { id: toastId });
        } catch (error) {
            console.error(error);
            toast.error("Failed to apply AI settings.", { id: toastId });
        }
    };

    const renderSettingsTable = (title: string, settings: Settings | null) => {
        if (!settings) return null;
        return (
            <div className="bg-gray-700 p-4 rounded-lg">
                <h3 className="text-lg font-bold mb-2">{title}</h3>
                <table className="min-w-full">
                    <tbody>
                        {Object.entries(settings).map(([key, value]) => (
                            <tr key={key} className="border-b border-gray-600">
                                <td className="p-2 font-semibold">{key}</td>
                                <td className="p-2">{String(value)}</td>
                                <td className="p-2 text-gray-400 text-sm">{SETTING_DESCRIPTIONS[key]}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );
    };

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Autonomous AI Optimization</h1>
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <p className="mb-4">
                    Click the button below to have the AI analyze all past trades from the trade log. It will identify patterns and propose a new, fully optimized set of parameters to improve its own profitability.
                </p>
                <button onClick={runOptimization} disabled={isLoading} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                    {isLoading ? 'AI is Thinking...' : 'Run AI Optimization Analysis'}
                </button>
            </div>

            {analysis && (
                <div className="space-y-8">
                    <div>
                        <h2 className="text-xl font-bold mb-4">AI Analysis Summary</h2>
                        <div className="bg-gray-800 p-4 rounded-lg">
                            <p>{analysis.analysis_summary}</p>
                        </div>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        {renderSettingsTable("Current Settings", currentSettings)}
                        {renderSettingsTable("AI's Proposed New Settings", analysis.suggested_settings)}
                    </div>
                    {renderMissedOpportunitiesTable()}
                    <div className="bg-gray-800 p-4 rounded-lg text-center">
                        <h2 className="text-xl font-bold mb-4">Authorize AI Self-Modification</h2>
                        <p className="mb-4">
                            Allow the AI to apply its learned settings. The bot will use this new configuration on its next trading cycle.
                        </p>
                        <button onClick={applyAiSettings} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
                            Apply AI Learned Settings
                        </button>
                    </div>
                </div>
            )}
        </div>
    );

    function renderMissedOpportunitiesTable() {
        if (missedOpportunities.length === 0) return null;
        return (
            <div className="bg-gray-700 p-4 rounded-lg">
                <h3 className="text-lg font-bold mb-2">Recent Missed Opportunities (for AI learning)</h3>
                <div className="overflow-y-auto h-48">
                    <table className="min-w-full text-sm">
                        <thead>
                            <tr className="text-left text-gray-400">
                                <th className="p-2">Symbol</th>
                                <th className="p-2">Reason</th>
                                <th className="p-2">Confidence</th>
                                <th className="p-2">Summary</th>
                            </tr>
                        </thead>
                        <tbody>
                            {missedOpportunities.map((opp, index) => (
                                <tr key={index} className="border-b border-gray-600">
                                    <td className="p-2 font-semibold">{opp.symbol}</td>
                                    <td className="p-2">{opp.reason}</td>
                                    <td className="p-2">{opp.confidenceScore?.toFixed(1)}</td>
                                    <td className="p-2 text-gray-400">{opp.finalSummary}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\portfolio\page.tsx ---
"use client";

import { useEffect, useState, useRef, useCallback } from 'react';
import { useDashboard } from '@/context/DashboardContext';
import toast from 'react-hot-toast';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

// Define interfaces for our state and props
interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPnlPercent?: number;
    takeProfitPercent?: number;
    holdCount?: number;
    stopLossPrice?: number;
}

interface Settings {
    trailingProfitPercent: number;
    takeProfitPercent: number;
    stopLossPercent: number;
    [key: string]: string | number; // Allow other properties
}

const playNotificationSound = () => {
    // const audio = new Audio('/sounds/notification.mp3');
    // audio.play().catch(error => console.error("Audio playback failed.", error));
};

export default function PortfolioPage() {
    const { state, dispatch } = useDashboard();
    const { portfolio, marketData } = state;
    const [settings, setSettings] = useState<Settings | null>(null);
    const triggeredSymbolsRef = useRef(new Set<string>());

    useEffect(() => {
        async function fetchSettings() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                setSettings(data);
            } catch (error) {
                console.error("Failed to fetch settings:", error);
            }
        }
        fetchSettings();
    }, []);

    const handleSell = useCallback(async (symbol: string, amount: number) => {
        const toastId = toast.loading(`Selling ${amount} of ${symbol}...`);
        try {
            const response = await fetch('/api/portfolio/sell', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ symbol, amount }),
            });
            if (!response.ok) throw new Error('Failed to sell.');
            
            const newPortfolio = await response.json();
            dispatch({ type: 'SET_PORTFOLIO', payload: newPortfolio });
            toast.success('Sell successful!', { id: toastId });
        } catch {
            toast.error('Sell failed.', { id: toastId });
        }
    }, [dispatch]);

    // This effect will now only handle the decision triggers, not data fetching
    useEffect(() => {
        if (!portfolio || portfolio.positions.length === 0 || !settings || marketData.length === 0) {
            return;
        }

        const positionsWithMarketData = portfolio.positions.map((pos: Position) => {
            const marketInfo = marketData.find((md: { symbol: string; lastPrice: string; }) => md.symbol === pos.symbol);
            const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
            const pnl = (currentPrice - pos.entryPrice) * pos.amount;
            const pnlPercent = (pos.entryPrice * pos.amount) === 0 ? 0 : (pnl / (pos.entryPrice * pos.amount)) * 100;
            return { ...pos, currentPrice, pnl, pnlPercent };
        });

        for (const pos of positionsWithMarketData) {
            const currentHigh = pos.highPnlPercent || 0;
            if (pos.pnlPercent > currentHigh) {
                fetch('/api/portfolio/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol: pos.symbol, updates: { highPnlPercent: pos.pnlPercent } }),
                });
            }

            const trailingStopPrice = (pos.highPnlPercent || 0) + settings.trailingProfitPercent;
            if (pos.highPnlPercent && pos.highPnlPercent > (pos.takeProfitPercent || settings.takeProfitPercent) && pos.pnlPercent < trailingStopPrice) {
                if (!triggeredSymbolsRef.current.has(pos.symbol)) {
                    triggeredSymbolsRef.current.add(pos.symbol);
                    playNotificationSound();
                    toast.success(`Selling ${pos.symbol} to lock in profit (Trailing Stop).`);
                    handleSell(pos.symbol, pos.amount);
                    continue;
                }
            }

            const atTakeProfit = pos.pnlPercent >= (pos.takeProfitPercent || settings.takeProfitPercent);
            const atStopLoss = pos.pnlPercent <= settings.stopLossPercent;

            if ((atTakeProfit || atStopLoss) && !triggeredSymbolsRef.current.has(pos.symbol)) {
                triggeredSymbolsRef.current.add(pos.symbol);
                const reason = atStopLoss ? 'stop-loss' : 'take-profit';
                playNotificationSound();
                toast(`Position ${pos.symbol} hit ${reason} target. Triggering AI decision...`);
                
                fetch('/api/bot/decision', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol: pos.symbol }),
                }).then(async (res) => {
                    if (res.ok) {
                        const result = await res.json();
                        if (result.decision === 'SOLD') {
                            playNotificationSound();
                            toast.success(`AI decided to sell ${pos.symbol} for ${result.reason}.`);
                        } else if (result.decision === 'HELD') {
                            playNotificationSound();
                            toast(`AI decided to hold ${pos.symbol}. New TP: ${result.new_tp}%.`, { icon: 'ℹ️' });
                        }
                    } else {
                        const errorData = await res.json();
                        const errorMessage = errorData.error || 'An unknown error occurred.';
                        playNotificationSound();
                        toast.error(`AI decision for ${pos.symbol} failed: ${errorMessage}`);
                    }
                }).finally(() => {
                    setTimeout(() => {
                        triggeredSymbolsRef.current.delete(pos.symbol);
                    }, 60000);
                });
            }
        }
    }, [portfolio, marketData, settings, handleSell]);

    if (!portfolio) {
        return <div>Loading portfolio...</div>;
    }

    const getPositionDisplayData = (pos: Position) => {
        const marketInfo = marketData.find((md: { symbol: string; lastPrice: string; }) => md.symbol === pos.symbol);
        const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
        const pnl = (currentPrice - pos.entryPrice) * pos.amount;
        const pnlPercent = (pos.entryPrice * pos.amount) === 0 ? 0 : (pnl / (pos.entryPrice * pos.amount)) * 100;
        return { currentPrice, pnl, pnlPercent };
    };

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">My Portfolio</h1>
            <div className="bg-gray-800 p-4 rounded-lg">
                <h2 className="text-xl font-bold mb-4">Open Positions</h2>
                {/* Mobile View - Cards */}
                <div className="md:hidden">
                    {portfolio.positions.map((pos: Position, index: number) => {
                        const { currentPrice, pnl, pnlPercent } = getPositionDisplayData(pos);
                        return (
                            <div key={index} className="bg-gray-700 rounded-lg p-4 mb-4">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="font-bold text-lg">{pos.symbol}</span>
                                    <span className={`font-bold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        {pnlPercent.toFixed(2)}%
                                    </span>
                                </div>
                                <div className="text-sm space-y-1">
                                    <p><strong>Amount:</strong> {pos.amount.toLocaleString('en-US', { minimumFractionDigits: 5, maximumFractionDigits: 5 })}</p>
                                    <p><strong>Entry Price:</strong> €{pos.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                                    <p><strong>Current Price:</strong> €{currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                                    <p><strong>P/L:</strong> <span className={pnl >= 0 ? 'text-green-400' : 'text-red-400'}>€{pnl.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span></p>
                                    {pos.holdCount && pos.holdCount > 0 && (
                                        <p><strong>AI Control:</strong> <span className="text-yellow-400">Held ({pos.holdCount}x)</span></p>
                                    )}
                                </div>
                                <button onClick={() => handleSell(pos.symbol, pos.amount)} className="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
                                    Sell
                                </button>
                            </div>
                        );
                    })}
                </div>
                {/* Desktop View - Table */}
                <div className="hidden md:block overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr>
                                <th className="text-left p-2">Symbol</th>
                                <th className="text-left p-2">Amount</th>
                                <th className="text-left p-2">Entry Price</th>
                                <th className="text-left p-2">Current Price</th>
                                <th className="text-left p-2">P/L</th>
                                <th className="text-left p-2">P/L (%)</th>
                                <th className="text-left p-2">AI Control</th>
                                <th className="text-left p-2">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {portfolio.positions.map((pos: Position, index: number) => {
                                const { currentPrice, pnl, pnlPercent } = getPositionDisplayData(pos);
                                return (
                                    <tr key={index} className="border-b border-gray-700">
                                        <td className="p-2">{pos.symbol}</td>
                                        <td className="p-2">{pos.amount.toLocaleString('en-US', { minimumFractionDigits: 5, maximumFractionDigits: 5 })}</td>
                                        <td className="p-2">€{pos.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className="p-2">€{currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className={`p-2 ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            €{pnl.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                        </td>
                                        <td className={`p-2 ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {pnlPercent.toFixed(2)}%
                                        </td>
                                        <td className="p-2">
                                            {pos.holdCount && pos.holdCount > 0 && (
                                                <TooltipProvider>
                                                    <Tooltip>
                                                        <TooltipTrigger>
                                                            <span className="text-yellow-400">Held ({pos.holdCount}x)</span>
                                                        </TooltipTrigger>
                                                        <TooltipContent>
                                                            <p>AI decided to hold this position {pos.holdCount} times. Current TP: {pos.takeProfitPercent}%, SL: €{pos.stopLossPrice?.toFixed(2)}</p>
                                                        </TooltipContent>
                                                    </Tooltip>
                                                </TooltipProvider>
                                            )}
                                        </td>
                                        <td className="p-2">
                                            <button onClick={() => handleSell(pos.symbol, pos.amount)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded">
                                                Sell
                                            </button>
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\app\dashboard\settings\page.tsx ---
"use client";

import { useState, useEffect } from 'react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { HelpCircle } from 'lucide-react';
import toast from 'react-hot-toast';

// Define an interface for the settings object
interface Settings {
    [key: string]: string | number | boolean;
}

const settingsConfig = [
    { name: 'sellStrategy', label: 'Sell Strategy', type: 'select', options: ['takeProfit', 'trailingStop'], tooltip: 'Choose the strategy for selling assets.' },
    { name: 'takeProfitPercent', label: 'Take Profit (%)', type: 'number', step: '0.1', condition: (s: Settings) => s.sellStrategy === 'takeProfit', tooltip: 'The percentage of profit at which to automatically sell an asset.' },
    { name: 'stopLossPercent', label: 'Stop Loss (%)', type: 'number', step: '0.1', tooltip: 'The percentage of loss at which to automatically sell an asset.' },
    { name: 'trailingStopPercent', label: 'Trailing Stop (%)', type: 'number', step: '0.1', condition: (s: Settings) => s.sellStrategy === 'trailingStop', tooltip: 'The percentage below the highest price at which to sell an asset.' },
    { name: 'enablePartialProfitTaking', label: 'Enable Partial Profit Taking', type: 'checkbox', tooltip: 'If enabled, the bot will sell a portion of the position when a profit target is hit, and let the rest run.' },
    { name: 'partialProfitPercent', label: 'Partial Profit (%)', type: 'number', step: '1', condition: (s: Settings) => s.enablePartialProfitTaking === true, tooltip: 'The percentage of the position to sell when partial profit taking is enabled.' },
    { name: 'riskAmountPercent', label: 'Risk Amount (%)', type: 'number', step: '0.1', tooltip: 'The percentage of your total balance to risk on a single trade.' },
    { name: 'rsiPeriod', label: 'RSI Period', type: 'number', tooltip: 'The number of periods to use for the Relative Strength Index (RSI) calculation.' },
    { name: 'symbolsToAnalyze', label: 'Symbols to Analyze', type: 'number', tooltip: 'The number of top symbols to analyze in each cycle.' },
    { name: 'batchSize', label: 'Batch Size', type: 'number', tooltip: 'The number of symbols to analyze in a single AI request.' },
    { name: 'macroScoreThreshold', label: 'Macro Score Threshold', type: 'number', tooltip: 'The minimum macroeconomic score required to consider buying.' },
    { name: 'minimumBalance', label: 'Minimum Balance to Trade', type: 'number', tooltip: 'The minimum balance required to start a new trading cycle.' },
    { name: 'cycleIntervalMinutes', label: 'Cycle Interval (Minutes)', type: 'number', tooltip: 'The time in minutes between each trading cycle.' },
    { name: 'smaShortPeriod', label: 'SMA (Short) Period', type: 'number', tooltip: 'The period for the short-term Simple Moving Average.' },
    { name: 'smaLongPeriod', label: 'SMA (Long) Period', type: 'number', tooltip: 'The period for the long-term Simple Moving Average.' },
    { name: 'macdShortPeriod', label: 'MACD (Short) Period', type: 'number', tooltip: 'The short period for the MACD calculation.' },
    { name: 'macdLongPeriod', label: 'MACD (Long) Period', type: 'number', tooltip: 'The long period for the MACD calculation.' },
    { name: 'macdSignalPeriod', label: 'MACD (Signal) Period', type: 'number', tooltip: 'The signal period for the MACD calculation.' },
    { name: 'fastMoverTimeMinutes', label: 'Fast Mover Time (Minutes)', type: 'number', tooltip: 'The time window in minutes to detect a fast price change.' },
    { name: 'fastMoverPriceChangePercent', label: 'Fast Mover Price Change (%)', type: 'number', step: '0.1', tooltip: 'The percentage price increase to qualify as a fast mover within the specified time.' },
];

export default function SettingsPage() {
    const [settings, setSettings] = useState<Settings>({});
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchSettings() {
            setIsLoading(true);
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                setSettings(data);
            } catch (error) {
                console.error("Failed to fetch settings", error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchSettings();
    }, []);

    const handleSave = async () => {
        const toastId = toast.loading('Saving settings...');
        try {
            await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings),
            });
            toast.success('Settings saved!', { id: toastId });
        } catch {
            toast.error('Failed to save settings.', { id: toastId });
        }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        setSettings({ ...settings, [name]: type === 'checkbox' ? (e.target as HTMLInputElement).checked : (name === 'sellStrategy' ? value : parseFloat(value)) });
    };

    if (isLoading) {
        return <div className="text-white p-6">Loading settings...</div>;
    }

    return (
        <div className="text-white p-6">
            <h1 className="text-2xl font-bold mb-6">Strategy Settings</h1>
            <div className="bg-gray-800 p-6 rounded-lg">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {settingsConfig.map((item) => (
                        (!item.condition || item.condition(settings)) && (
                            <div key={item.name}>
                                <label className="block text-sm font-medium text-gray-300 mb-1 flex items-center">
                                    {item.label}
                                    <TooltipProvider>
                                        <Tooltip>
                                            <TooltipTrigger asChild>
                                                <HelpCircle size={14} className="ml-2 text-gray-500" />
                                            </TooltipTrigger>
                                            <TooltipContent>
                                                <p>{item.tooltip}</p>
                                            </TooltipContent>
                                        </Tooltip>
                                    </TooltipProvider>
                                </label>
                                {item.type === 'select' ? (
                                    <select name={item.name} value={settings[item.name] || ''} onChange={handleChange} className="bg-gray-700 rounded p-2 w-full">
                                        {item.options?.map(opt => <option key={opt} value={opt}>{opt.replace(/([A-Z])/g, ' $1').trim()}</option>)}
                                    </select>
                                ) : item.type === 'checkbox' ? (
                                    <input type="checkbox" name={item.name} checked={!!settings[item.name]} onChange={(e) => setSettings({ ...settings, [item.name]: e.target.checked })} className="bg-gray-700 rounded p-2 w-full h-6 w-6" />
                                ) : (
                                    <input type="number" name={item.name} value={settings[item.name] || ''} onChange={handleChange} className="bg-gray-700 rounded p-2 w-full" step={item.step || '1'} />
                                )}
                            </div>
                        )
                    ))}
                </div>
                <div className="mt-8">
                    <button onClick={handleSave} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                        Save Settings
                    </button>
                    <button
                        onClick={async () => {
                            if (window.confirm('Are you sure you want to reset all logs and portfolio? This action cannot be undone.')) {
                                const toastId = toast.loading('Resetting logs...');
                                try {
                                    // Assuming username is available from a session context or similar
                                    // For now, I'll use a placeholder 'admin' as per README.md example
                                    // In a real app, this should come from authenticated user session
                                    const username = 'admin'; // Replace with actual username from session/context

                                    const response = await fetch('/api/reset-logs', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ username }),
                                    });

                                    if (response.ok) {
                                        toast.success('All logs and portfolio reset successfully!', { id: toastId });
                                        // Optionally, refetch settings or redirect after reset
                                        // window.location.reload();
                                    } else {
                                        const errorData = await response.json();
                                        toast.error(`Failed to reset logs: ${errorData.error || 'Unknown error'}`, { id: toastId });
                                    }
                                } catch (error) {
                                    console.error("Error resetting logs:", error);
                                    toast.error('Failed to reset logs due to a network or server error.', { id: toastId });
                                }
                            }
                        }}
                        className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors ml-4"
                    >
                        Reset All Logs
                    </button>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\ai-chat-window.tsx ---
"use client";

import { useDashboard, AiChat } from '@/context/DashboardContext';
import { ScrollArea } from '@/components/ui/scroll-area';

export function AiChatWindow() {
    const { state } = useDashboard();

    const renderContent = (chat: AiChat) => {
        const response = chat.response as { summary?: string };
        if (chat.agent === 'System') {
            return (
                <div className="p-2 rounded bg-gray-700">
                    <p className="text-sm text-yellow-300">{response.summary}</p>
                </div>
            );
        }
        // Add more custom renderings for other agents or types if needed
        return (
            <>
                <div className="p-2 rounded bg-gray-700">
                    <p className="font-bold text-blue-400">{chat.agent} Prompt:</p>
                    <pre className="text-xs whitespace-pre-wrap font-mono overflow-x-auto">{chat.prompt}</pre>
                </div>
                <div className="p-2 rounded bg-gray-600 mt-2">
                    <p className="font-bold text-green-400">{chat.agent} Response:</p>
                    <pre className="text-xs whitespace-pre-wrap font-mono overflow-x-auto">{JSON.stringify(chat.response, null, 2)}</pre>
                </div>
            </>
        );
    };

    return (
        <div>
            <h2 className="font-bold text-lg mb-4">AI Communication Log</h2>
            <ScrollArea className="bg-gray-900 text-white p-4 rounded-lg h-[40vh]">
                <div className="space-y-4">
                    {state.aiChat.map((chat, index) => (
                        <div key={index}>
                            {renderContent(chat)}
                        </div>
                    ))}
                </div>
            </ScrollArea>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\analysis-panel.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';

// Define interfaces for the component props and data structures
interface Decision {
    decision: string;
    amount_to_buy_usd: number;
    justification: string;
}

export interface Analysis {
    PortfolioAllocator?: {
        response: {
            [symbol: string]: Decision;
        };
    };
}

interface AnalysisPanelProps {
    analysis?: Analysis;
}

export function AnalysisPanel({ analysis }: AnalysisPanelProps) {
    const { state } = useDashboard();
    const lastRunAnalysis = analysis || state.lastRunAnalysis;

    if (!lastRunAnalysis || Object.keys(lastRunAnalysis).length === 0) {
        return (
            <div className="bg-gray-900 text-white p-4 rounded-lg h-full flex items-center justify-center col-span-full">
                <div className="text-center">
                    <h2 className="font-bold text-lg mb-2">AI Analysis</h2>
                    <p className="text-gray-400">Run a cycle to get AI analysis.</p>
                </div>
            </div>
        );
    }

    const portfolioAllocator = lastRunAnalysis.PortfolioAllocator;
    const allocations = 
        portfolioAllocator && 
        typeof portfolioAllocator === 'object' && 
        'response' in portfolioAllocator &&
        portfolioAllocator.response &&
        typeof portfolioAllocator.response === 'object'
            ? portfolioAllocator.response 
            : {};
    
    const allDecisions = Object.entries(allocations);

    if (allDecisions.length === 0) {
        return (
            <div className="bg-gray-900 text-white p-4 rounded-lg h-full flex items-center justify-center col-span-full">
                <p className="text-gray-400">Portfolio Allocator did not provide any decisions.</p>
            </div>
        );
    }

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {allDecisions.map(([symbol, dec]) => {
                const decision = dec as Decision;
                const isBuy = decision.decision === 'EXECUTE_BUY';
                
                return (
                    <div key={symbol} className={`bg-gray-900 text-white p-4 rounded-lg border-l-4 ${isBuy ? 'border-green-500' : 'border-gray-600'}`}>
                        <h3 className={`font-bold text-lg mb-2 ${isBuy ? 'text-blue-400' : 'text-gray-500'}`}>{symbol}</h3>
                        <div className="space-y-2 text-sm">
                            <p>
                                <span className="font-semibold">Decision:</span>
                                <span className={`font-bold ml-2 ${isBuy ? 'text-green-400' : 'text-yellow-400'}`}>{decision.decision.replace('_', ' ')}</span>
                            </p>
                            {isBuy && (
                                <p>
                                    <span className="font-semibold">Amount:</span>
                                    <span className="font-bold ml-2">€{decision.amount_to_buy_usd.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                                </p>
                            )}
                            <div>
                                <p className="font-semibold mb-1">Justification:</p>
                                <p className="text-gray-400 text-xs">{decision.justification}</p>
                            </div>
                        </div>
                    </div>
                );
            })}
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\chart.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';
import { useDashboard } from '@/context/DashboardContext';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Define interfaces for our data structures
interface Candle {
    time: number;
    close: number;
}

interface ChartData {
    labels: string[];
    datasets: {
        label: string;
        data: number[];
        borderColor: string;
        backgroundColor: string;
    }[];
}

export function Chart() {
    const { state } = useDashboard();
    const { selectedSymbol } = state;
    const [chartData, setChartData] = useState<ChartData>({
        labels: [],
        datasets: [],
    });

    useEffect(() => {
        async function fetchChartData() {
            if (!selectedSymbol) return;
            try {
                const response = await fetch(`/api/chart-data?symbol=${selectedSymbol}`);
                const data: Candle[] = await response.json();
                
                const labels = data.map((d: Candle) => new Date(d.time * 1000).toLocaleDateString());
                const prices = data.map((d: Candle) => d.close);

                setChartData({
                    labels,
                    datasets: [
                        {
                            label: `${selectedSymbol} Price`,
                            data: prices,
                            borderColor: 'rgb(59, 130, 246)',
                            backgroundColor: 'rgba(59, 130, 246, 0.5)',
                        },
                    ],
                });
            } catch (error) {
                console.error("Failed to fetch chart data", error);
            }
        }
        fetchChartData();
    }, [selectedSymbol]);

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'top' as const,
            },
        },
        scales: {
            y: {
                ticks: {
                    color: '#d1d5db',
                },
            },
            x: {
                ticks: {
                    color: '#d1d5db',
                },
            },
        },
    };

    return (
        <div className="h-[400px]">
            <Line data={chartData} options={options} />
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\dashboard-client.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { MarketTable } from '@/components/market-table';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel } from '@/components/analysis-panel';
import { AiChatWindow } from '@/components/ai-chat-window';
import { NewsFeed } from '@/components/news-feed';
import { Chart } from '@/components/chart';
import { DecisionLog } from '@/components/decision-log';
import { SharedContextDisplay } from '@/components/shared-context-display';
import { DynamicRiskDisplay } from '@/components/dynamic-risk-display';
import { DollarSign, TrendingUp, Wallet } from 'lucide-react';

export function DashboardClient() {
    const { state } = useDashboard();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            {/* Row 1: KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <KpiCard title="Total Value" kpiKey="totalValue" icon={<Wallet size={24} />} />
                <KpiCard title="24h P/L" kpiKey="24h_pnl" icon={<TrendingUp size={24} />} />
                <KpiCard title="Free Collateral" kpiKey="freeCollateral" icon={<DollarSign size={24} />} />
            </div>

            {/* Row 2: Hive Mind & Risk Context */}
            <div className="space-y-6">
                <SharedContextDisplay context={state.sharedContext} />
                <DynamicRiskDisplay />
            </div>

            {/* Row 3: Main Grid */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                {/* Main Content Column */}
                <div className="lg:col-span-2 space-y-6">
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h2 className="text-lg font-semibold mb-4">{state.selectedSymbol} Price Chart</h2>
                        <Chart />
                    </div>
                    <div>
                        <h2 className="text-lg font-semibold mb-4">AI Analysis Cycle: Latest Buys</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                            <AnalysisPanel />
                        </div>
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <AiChatWindow />
                    </div>
                    <DecisionLog />
                </div>

                {/* Side Column */}
                <div className="lg:col-span-1 space-y-6">
                    <MarketTable />
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h2 className="font-semibold text-md mb-2">Live Logs</h2>
                        <div className="bg-gray-900 text-white p-2 rounded-lg h-[25vh] overflow-y-auto text-xs space-y-1 font-mono">
                            {state.logs.map((log, index) => (
                                <p key={index}>{log}</p>
                            ))}
                        </div>
                    </div>
                    <NewsFeed />
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\decision-log.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { ChevronUp, ChevronDown } from 'lucide-react';
import toast from 'react-hot-toast';

interface Decision {
    timestamp: string;
    decision: string;
    justification: string;
    pnlPercent: number;
    currentPrice: number;
}

interface DecisionWithSymbol extends Decision {
    symbol: string;
}

interface DecisionData {
    [symbol: string]: Decision[];
}

export function DecisionLog() {
    const [allDecisions, setAllDecisions] = useState<DecisionWithSymbol[]>([]);
    const [currentIndex, setCurrentIndex] = useState(0);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchDecisions() {
            try {
                const response = await fetch('/api/decisions');
                if (!response.ok) throw new Error('Failed to fetch decisions.');
                const data: DecisionData = await response.json();
                const flattenedDecisions = Object.entries(data).flatMap(([symbol, decisionList]) => 
                    decisionList.map((d: Decision) => ({ ...d, symbol }))
                ).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
                
                setAllDecisions(flattenedDecisions);
                setCurrentIndex(0); // Reset to the latest decision on refresh
            } catch {
                toast.error("Could not load decision log.");
            } finally {
                setIsLoading(false);
            }
        }

        fetchDecisions(); // Initial fetch
        const intervalId = setInterval(fetchDecisions, 10000); // Refresh every 10 seconds
        return () => clearInterval(intervalId);
    }, []);

    useEffect(() => {
        if (allDecisions.length > 1) {
            const timer = setInterval(() => {
                setCurrentIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
            }, 10000); // Cycle to the newest every 10 seconds
            return () => clearInterval(timer);
        }
    }, [allDecisions]);

    const handleNext = () => {
        setCurrentIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
    };

    const handlePrev = () => {
        setCurrentIndex(prevIndex => (prevIndex < allDecisions.length - 1 ? prevIndex + 1 : allDecisions.length - 1));
    };

    const currentDecision = allDecisions[currentIndex];

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">Portfolio Manager Decisions</h2>
                {allDecisions.length > 1 && (
                    <div className="flex items-center space-x-2">
                        <button onClick={handlePrev} disabled={currentIndex === allDecisions.length - 1} className="p-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50">
                            <ChevronDown size={16} />
                        </button>
                        <span className="text-xs text-gray-400">{currentIndex + 1} / {allDecisions.length}</span>
                        <button onClick={handleNext} disabled={currentIndex === 0} className="p-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50">
                            <ChevronUp size={16} />
                        </button>
                    </div>
                )}
            </div>
            <div className="h-[10vh]">
                {isLoading ? (
                    <p>Loading decisions...</p>
                ) : currentDecision ? (
                    <div className="text-xs p-2 bg-gray-900 rounded-md">
                        <div className="flex justify-between items-center mb-1">
                            <span className="font-bold text-blue-400">{currentDecision.symbol}</span>
                            <span className="text-gray-400">{new Date(currentDecision.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <p>
                            <span className="font-semibold">Decision:</span>
                            <span className={`ml-2 font-bold ${currentDecision.decision === 'SELL_NOW' ? 'text-red-400' : 'text-yellow-400'}`}>
                                {currentDecision.decision.replace('_', ' ')}
                            </span>
                        </p>
                        <p className="text-gray-400 mt-1">{currentDecision.justification}</p>
                    </div>
                ) : (
                    <p className="text-gray-400">No decisions logged yet.</p>
                )}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\dynamic-risk-display.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { AlertTriangle, ShieldCheck } from 'lucide-react';

export function DynamicRiskDisplay() {
    const { state } = useDashboard();
    const { adjustedConfig, sharedContext } = state;

    if (!adjustedConfig || !sharedContext) {
        return null; // Don't render if there's no adjustment
    }

    const isAggressive = sharedContext.regimeScore > 7.5;
    const isDefensive = sharedContext.regimeScore < 4.0;

    if (!isAggressive && !isDefensive) {
        return null; // No significant adjustment, don't render
    }

    const title = isAggressive ? "Aggressive Stance Adopted" : "Defensive Stance Adopted";
    const Icon = isAggressive ? AlertTriangle : ShieldCheck;
    const color = isAggressive ? "text-yellow-400" : "text-blue-400";
    const reason = isAggressive 
        ? `Market regime is highly favorable (Score: ${sharedContext.regimeScore.toFixed(1)}). Increasing risk exposure.`
        : `Market regime is unfavorable (Score: ${sharedContext.regimeScore.toFixed(1)}). Reducing risk exposure.`;

    return (
        <div className={`bg-gray-800 p-4 rounded-lg border-l-4 ${isAggressive ? 'border-yellow-400' : 'border-blue-400'}`}>
            <div className="flex items-center">
                <Icon size={24} className={`${color} mr-3`} />
                <div>
                    <h3 className={`text-lg font-semibold ${color}`}>{title}</h3>
                    <p className="text-sm text-gray-300">{reason}</p>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\header.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { Power, Timer, Wallet, Menu } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dispatch, SetStateAction } from 'react';

interface HeaderProps {
    setSidebarOpen: Dispatch<SetStateAction<boolean>>;
}

export function Header({ setSidebarOpen }: HeaderProps) {
    const { state, dispatch } = useDashboard();

    const toggleBotStatus = async () => {
        const newStatus = state.botStatus === 'active' ? 'inactive' : 'active';
        try {
            const response = await fetch('/api/bot/status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: newStatus }),
            });
            if (response.ok) {
                dispatch({ type: 'SET_BOT_STATUS', payload: newStatus });
                dispatch({ type: 'ADD_LOG', payload: `Bot status set to ${newStatus}` });
            } else {
                dispatch({ type: 'ADD_LOG', payload: 'Error updating bot status' });
            }
        } catch {
            dispatch({ type: 'ADD_LOG', payload: 'Error updating bot status' });
        }
    };

    return (
        <header className="flex justify-between items-center p-4 bg-gray-900 text-white border-b border-gray-700">
            <div className="flex items-center">
                <button
                    onClick={() => setSidebarOpen(true)}
                    className="md:hidden mr-4 text-gray-400 hover:text-white"
                >
                    <Menu size={24} />
                </button>
                <h1 className="text-xl font-semibold hidden md:block">CryptoBot Dashboard</h1>
            </div>
            <div className="flex items-center space-x-2 md:space-x-6">
                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger>
                            <div className="flex items-center text-sm">
                                <Timer size={16} className="mr-2 text-gray-400" />
                                <span>Next cycle in: <strong>{state.nextCycleIn}</strong></span>
                            </div>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Time until the next automated trading cycle begins.</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>

                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger>
                            <div className="flex items-center text-sm">
                                <Wallet size={16} className="mr-2 text-gray-400" />
                                <span className="hidden sm:inline">Sandbox Balance: </span>
                                <strong className="ml-1">€{state.portfolio.balance.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</strong>
                            </div>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Your current virtual balance for simulated trading.</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>

                <button
                    onClick={toggleBotStatus}
                    className={`flex items-center px-4 py-2 rounded-md font-semibold text-sm transition-colors ${state.botStatus === 'active' 
                        ? 'bg-red-600 hover:bg-red-700 text-white' 
                        : 'bg-green-600 hover:bg-green-700 text-white'}`}
                >
                    <Power size={16} className="mr-2" />
                    {state.botStatus === 'active' ? 'Stop Bot' : 'Start Bot'}
                </button>
            </div>
        </header>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\kpi-card.tsx ---
"use client";

import { ReactNode, useMemo, useEffect, useState } from 'react';
import { useDashboard } from '@/context/DashboardContext';

interface KpiCardProps {
    title: string;
    icon: ReactNode;
    kpiKey?: 'totalValue' | '24h_pnl' | 'freeCollateral';
    value?: string | number;
    color?: string;
}

export function KpiCard({ title, icon, kpiKey, value, color: propColor }: KpiCardProps) {
    const { state } = useDashboard();
    const { portfolio, marketData } = state;
    const [tradeHistory, setTradeHistory] = useState([]);

    useEffect(() => {
        async function fetchTradeHistory() {
            try {
                const response = await fetch('/api/history');
                const data = await response.json();
                setTradeHistory(data);
            } catch (error) {
                console.error("Failed to fetch trade history:", error);
            }
        }
        fetchTradeHistory();
        const interval = setInterval(fetchTradeHistory, 10000); // Refetch every 10 seconds
        return () => clearInterval(interval);
    }, []);

    const kpiValue = useMemo(() => {
        if (value !== undefined) return value;
        if (!portfolio || !kpiKey) return 0;

        const positionsValue = portfolio.positions.reduce((acc, pos) => {
            const marketInfo = marketData.find(md => md.symbol === pos.symbol);
            const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
            return acc + (currentPrice * pos.amount);
        }, 0);

        const totalValue = portfolio.balance + positionsValue;

        switch (kpiKey) {
            case 'totalValue':
                return totalValue;
            case 'freeCollateral':
                return portfolio.balance;
            case '24h_pnl':
                const now = new Date().getTime();
                const twentyFourHoursAgo = now - 24 * 60 * 60 * 1000;
                const pnl24h = tradeHistory.reduce((acc, trade) => {
                    const tradeTimestamp = new Date((trade as { timestamp: string }).timestamp).getTime();
                    if (tradeTimestamp > twentyFourHoursAgo) {
                        return acc + (trade as { pnl: number }).pnl;
                    }
                    return acc;
                }, 0);
                return pnl24h;
            default:
                return 0;
        }
    }, [portfolio, marketData, kpiKey, value, tradeHistory]);

    const formattedValue = typeof kpiValue === 'number' 
        ? `€${kpiValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
        : kpiValue;
    
    let color = propColor || 'text-white';
    if (kpiKey === '24h_pnl' && typeof kpiValue === 'number') {
        if (kpiValue > 0) color = 'text-green-400';
        if (kpiValue < 0) color = 'text-red-400';
    }

    return (
        <div className="bg-gray-900 p-4 rounded-lg flex items-center">
            <div className={`mr-4 ${color}`}>
                {icon}
            </div>
            <div>
                <p className="text-sm text-gray-400">{title}</p>
                <p className={`text-2xl font-bold ${color}`}>{formattedValue}</p>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\market-table.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { Ticker } from '@/core/binance';

export function MarketTable() {
    const { state, dispatch } = useDashboard();

    const handleRowClick = (symbol: string) => {
        dispatch({ type: 'SET_SELECTED_SYMBOL', payload: symbol });
    };

    return (
        <div className="bg-gray-900 text-white p-4 rounded-lg">
            <h2 className="font-bold text-lg mb-2">Market Scanner</h2>
            <div className="overflow-y-auto h-[70vh]">
                <table className="w-full text-left">
                    <thead>
                        <tr className="border-b border-gray-700">
                            <th className="p-2">Symbol</th>
                            <th className="p-2">Price</th>
                            <th className="p-2">Change (24h)</th>
                            <th className="p-2">Volume (24h)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {state.marketData.map((ticker: Ticker) => (
                            <tr 
                                key={ticker.symbol} 
                                className={`border-b border-gray-800 hover:bg-gray-700 cursor-pointer ${state.selectedSymbol === ticker.symbol ? 'bg-gray-700' : ''}`}
                                onClick={() => handleRowClick(ticker.symbol)}
                            >
                                <td className="p-2 font-bold">{ticker.symbol}</td>
                                <td className="p-2">${parseFloat(ticker.lastPrice).toFixed(2)}</td>
                                <td className={`p-2 ${parseFloat(ticker.priceChangePercent) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    {parseFloat(ticker.priceChangePercent).toFixed(2)}%
                                </td>
                                <td className="p-2">${(parseFloat(ticker.quoteVolume) / 1_000_000).toFixed(2)}M</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\news-feed.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { Rss } from 'lucide-react';

interface Article {
    title: string;
    url: string;
    source: { name: string };
    publishedAt: string;
}

export function NewsFeed() {
    const [articles, setArticles] = useState<Article[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchNews() {
            setIsLoading(true);
            try {
                const response = await fetch('/api/news');
                const data = await response.json();
                setArticles(data.articles || []);
            } catch (error) {
                console.error("Failed to fetch news", error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchNews();
    }, []);

    if (isLoading) {
        return <div className="text-center p-4">Loading news...</div>;
    }

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="text-lg font-semibold mb-4 flex items-center">
                <Rss size={20} className="mr-2" />
                Latest Crypto News
            </h2>
            <div className="space-y-4 max-h-96 overflow-y-auto">
                {articles.map((article, index) => (
                    <a 
                        key={index} 
                        href={article.url} 
                        target="_blank" 
                        rel="noopener noreferrer" 
                        className="block p-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors"
                    >
                        <p className="font-semibold">{article.title}</p>
                        <div className="flex justify-between items-center mt-2 text-xs text-gray-400">
                            <span>{article.source.name}</span>
                            <span>{new Date(article.publishedAt).toLocaleDateString()}</span>
                        </div>
                    </a>
                ))}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\opportunity-log.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { useDashboard } from '@/context/DashboardContext';
import { Opportunity } from '@/core/opportunity-scanner';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { PlayCircle } from 'lucide-react';

export function OpportunityLog() {
    const { state, dispatch } = useDashboard();
    const [isLoading, setIsLoading] = useState<string | null>(null);

    const handleAnalyze = async (symbol: string) => {
        setIsLoading(symbol);
        try {
            const response = await fetch('/api/bot/decision', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ symbol }),
            });
            if (!response.ok) {
                throw new Error('Failed to analyze opportunity.');
            }
            // The dashboard context will update the opportunities list automatically
            // through its polling mechanism.
        } catch (error) {
            console.error("Analysis error:", error);
        } finally {
            setIsLoading(null);
        }
    };

    const getStatusVariant = (status: Opportunity['status']) => {
        switch (status) {
            case 'bought': return 'success';
            case 'ignored': return 'destructive';
            case 'analyzing': return 'secondary';
            default: return 'default';
        }
    };

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="font-semibold text-md mb-4">Opportunity Log (Fast Movers)</h2>
            <div className="space-y-3">
                {state.opportunities.length === 0 ? (
                    <p className="text-gray-400 text-sm">No significant price movements detected recently.</p>
                ) : (
                    state.opportunities.slice(0, 10).map((opp) => (
                        <div key={opp.timestamp} className="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                            <div>
                                <p className="font-bold">{opp.symbol}</p>
                                <p className={`text-sm ${opp.priceChangePercent && opp.priceChangePercent > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    +{ (opp.priceChangePercent || 0).toFixed(2) }%
                                </p>
                                <p className="text-xs text-gray-400">{new Date(opp.timestamp).toLocaleTimeString()}</p>
                            </div>
                            <div className="flex items-center space-x-2">
                                <Badge variant={getStatusVariant(opp.status)}>{opp.status}</Badge>
                                {opp.status === 'detected' && (
                                    <Button 
                                        size="sm" 
                                        onClick={() => handleAnalyze(opp.symbol)}
                                        disabled={isLoading === opp.symbol}
                                    >
                                        <PlayCircle size={16} />
                                        <span className="ml-2">{isLoading === opp.symbol ? 'Analyzing...' : 'Analyze'}</span>
                                    </Button>
                                )}
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\shared-context-display.tsx ---
"use client";

import { ISharedContext } from '@/core/context';
import { Badge } from '@/components/ui/badge'; // Assuming you have a Badge component
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

interface SharedContextDisplayProps {
    context: ISharedContext | null;
}

const RegimeBadge = ({ regime }: { regime: ISharedContext['marketRegime'] }) => {
    const color = regime === 'Risk-On' ? 'bg-green-600' : regime === 'Risk-Off' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{regime.replace('-', ' ')}</Badge>;
};

const SentimentBadge = ({ sentiment }: { sentiment: ISharedContext['sentiment'] }) => {
    const color = sentiment === 'Bullish' ? 'bg-green-600' : sentiment === 'Bearish' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{sentiment}</Badge>;
};

export function SharedContextDisplay({ context }: SharedContextDisplayProps) {
    if (!context) {
        return (
            <div className="bg-gray-800 p-4 rounded-lg text-center">
                <h2 className="text-lg font-semibold mb-2">Hive Mind Context</h2>
                <p className="text-gray-400">Waiting for first cycle...</p>
            </div>
        );
    }

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="text-lg font-semibold mb-3">Hive Mind Context</h2>
            <div className="grid grid-cols-2 gap-4 text-sm">
                <div className="flex justify-between items-center">
                    <span className="text-gray-400">Market Regime:</span>
                    <TooltipProvider>
                        <Tooltip>
                            <TooltipTrigger>
                                <RegimeBadge regime={context.marketRegime} />
                            </TooltipTrigger>
                            <TooltipContent>
                                <p>Score: {context.regimeScore.toFixed(1)} / 10.0</p>
                            </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                </div>
                <div className="flex justify-between items-center">
                    <span className="text-gray-400">Market Sentiment:</span>
                     <TooltipProvider>
                        <Tooltip>
                            <TooltipTrigger>
                                <SentimentBadge sentiment={context.sentiment} />
                            </TooltipTrigger>
                            <TooltipContent>
                                <p>Score: {context.sentimentScore.toFixed(2)} / 1.0</p>
                            </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                </div>
                <div className="col-span-2">
                     <span className="text-gray-400">Key Topics:</span>
                     <div className="flex flex-wrap gap-2 mt-1">
                        {context.keyTopics.length > 0 ? context.keyTopics.map(topic => (
                            <Badge key={topic} variant="secondary">{topic}</Badge>
                        )) : <span className="text-xs text-gray-500">None detected</span>}
                     </div>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\sidebar.tsx ---
"use client";

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Bot, Settings, BarChart, Wallet, LineChart, FlaskConical, History, X } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dispatch, SetStateAction } from 'react';

const navItems = [
    { href: '/dashboard', icon: BarChart, label: 'Dashboard', tooltip: 'View key performance indicators and market data.' },
    { href: '/dashboard/portfolio', icon: Wallet, label: 'Portfolio', tooltip: 'Manage your open positions and view your balance.' },
    { href: '/dashboard/history', icon: History, label: 'History', tooltip: 'View your past trade history.' },
    { href: '/dashboard/backtest', icon: FlaskConical, label: 'Backtesting', tooltip: 'Test your strategies against historical data.' },
    { href: '/dashboard/optimization', icon: LineChart, label: 'Optimization', tooltip: 'Optimize your strategy parameters for better performance.' },
    { href: '/dashboard/settings', icon: Settings, label: 'Settings', tooltip: 'Configure your trading bot and strategies.' },
];

interface SidebarProps {
    sidebarOpen: boolean;
    setSidebarOpen: Dispatch<SetStateAction<boolean>>;
}

export function Sidebar({ sidebarOpen, setSidebarOpen }: SidebarProps) {
    const pathname = usePathname();

    return (
        <>
            {/* Mobile Sidebar */}
            <div className={`fixed inset-0 z-40 flex md:hidden ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'} transition-transform duration-300 ease-in-out`}>
                <div className="w-64 bg-gray-900 text-white border-r border-gray-700 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-8">
                        <div className="flex items-center space-x-2">
                            <Bot size={28} className="text-blue-400" />
                            <h1 className="text-2xl font-bold">CryptoBot</h1>
                        </div>
                        <button onClick={() => setSidebarOpen(false)} className="text-gray-400 hover:text-white">
                            <X size={24} />
                        </button>
                    </div>
                    <nav className="flex-grow space-y-2">
                        {navItems.map((item) => (
                            <Link
                                key={item.href}
                                href={item.href}
                                onClick={() => setSidebarOpen(false)}
                                className={`flex items-center p-3 rounded-lg transition-colors ${
                                    pathname === item.href
                                        ? 'bg-blue-600 text-white'
                                        : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                                }`}
                            >
                                <item.icon className="mr-4" size={20} />
                                <span className="font-medium">{item.label}</span>
                            </Link>
                        ))}
                    </nav>
                    <div className="mt-auto">
                        <p className="text-xs text-gray-500">© 2025 CryptoBot Inc.</p>
                    </div>
                </div>
                <div className="flex-shrink-0 w-14" onClick={() => setSidebarOpen(false)}></div>
            </div>

            {/* Desktop Sidebar */}
            <div className="hidden md:flex md:flex-shrink-0">
                <div className="w-64 flex flex-col p-4 bg-gray-900 text-white border-r border-gray-700">
                    <div className="mb-8 flex items-center space-x-2">
                        <Bot size={28} className="text-blue-400" />
                        <h1 className="text-2xl font-bold">CryptoBot</h1>
                    </div>
                    <nav className="flex-grow space-y-2">
                        <TooltipProvider>
                            {navItems.map((item) => (
                                <Tooltip key={item.href}>
                                    <TooltipTrigger asChild>
                                        <Link
                                            href={item.href}
                                            className={`flex items-center p-3 rounded-lg transition-colors ${
                                                pathname === item.href
                                                    ? 'bg-blue-600 text-white'
                                                    : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                                            }`}
                                        >
                                            <item.icon className="mr-4" size={20} />
                                            <span className="font-medium">{item.label}</span>
                                        </Link>
                                    </TooltipTrigger>
                                    <TooltipContent side="right">
                                        <p>{item.tooltip}</p>
                                    </TooltipContent>
                                </Tooltip>
                            ))}
                        </TooltipProvider>
                    </nav>
                    <div className="mt-auto">
                        <p className="text-xs text-gray-500">© 2025 CryptoBot Inc.</p>
                    </div>
                </div>
            </div>
        </>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\ui\badge.tsx ---
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success: "border-transparent bg-green-500 text-white",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\ui\button.tsx ---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\ui\scroll-area.tsx ---
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Scrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Scrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.Scrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-gray-700" />
  </ScrollAreaPrimitive.Scrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.Scrollbar.displayName

export { ScrollArea, ScrollBar }

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\components\ui\tooltip.tsx ---
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\context\DashboardContext.tsx ---
"use client";

import { createContext, useContext, useReducer, ReactNode, useEffect, useRef, useState } from 'react';
import { Ticker } from '@/core/binance';
import { ISharedContext } from '@/core/context';
import { Opportunity } from '@/core/opportunity-scanner';
import toast from 'react-hot-toast';

// --- STATE AND TYPES ---
interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

interface BinanceTickerEvent {
    s: string; // Symbol
    c: string; // Last price
    P: string; // Price change percent
    q: string; // Quote volume
}

export interface AiChat {
    agent: string;
    prompt: string;
    response: Record<string, unknown>;
}

// More specific type for analysis data
interface Analysis {
    [key: string]: unknown;
}

interface DashboardState {
    logs: string[];
    marketData: Ticker[];
    portfolio: Portfolio;
    isLoading: boolean;
    selectedSymbol: string;
    analysis: Analysis | null;
    botStatus: 'active' | 'inactive';
    aiChat: AiChat[];
    nextCycleIn: string;
    lastRunAnalysis: Analysis | null;
    sharedContext: ISharedContext | null;
    adjustedConfig: Config | null;
    opportunities: Opportunity[];
}

type Action =
    | { type: 'ADD_LOG'; payload: string }
    | { type: 'ADD_AI_CHAT'; payload: AiChat }
    | { type: 'SET_MARKET_DATA'; payload: Ticker[] }
    | { type: 'UPDATE_MARKET_PRICES'; payload: Ticker[] }
    | { type: 'SET_PORTFOLIO'; payload: Portfolio }
    | { type: 'SET_LOADING'; payload: boolean }
    | { type: 'SET_SELECTED_SYMBOL'; payload: string }
    | { type: 'SET_ANALYSIS'; payload: Analysis | null }
    | { type: 'SET_BOT_STATUS'; payload: 'active' | 'inactive' }
    | { type: 'SET_TIMER'; payload: string }
    | { type: 'SET_LAST_RUN_ANALYSIS'; payload: Analysis | null }
    | { type: 'SET_SHARED_CONTEXT'; payload: ISharedContext }
    | { type: 'SET_ADJUSTED_CONFIG'; payload: Config }
    | { type: 'SET_OPPORTUNITIES'; payload: Opportunity[] };

const initialState: DashboardState = {
    logs: [],
    aiChat: [],
    marketData: [],
    portfolio: { balance: 0, positions: [] },
    isLoading: true,
    selectedSymbol: 'BTCUSDT',
    analysis: null,
    botStatus: 'inactive',
    nextCycleIn: 'N/A',
    lastRunAnalysis: null,
    sharedContext: null,
    adjustedConfig: null,
    opportunities: [],
};

// --- REDUCER ---
function dashboardReducer(state: DashboardState, action: Action): DashboardState {
    switch (action.type) {
        case 'ADD_LOG':
            const newLogs = [...state.logs, `[${new Date().toLocaleTimeString()}] ${action.payload}`];
            return { ...state, logs: newLogs.slice(-100) };
        case 'ADD_AI_CHAT':
            const newChats = [...state.aiChat, action.payload];
            return { ...state, aiChat: newChats.slice(-100) };
        case 'SET_MARKET_DATA':
            // console.log('[DashboardReducer] SET_MARKET_DATA payload:', action.payload.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
            return { ...state, marketData: action.payload };
        case 'UPDATE_MARKET_PRICES':
            // console.log('[DashboardReducer] UPDATE_MARKET_PRICES payload:', action.payload.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
            const updatedMarketData = state.marketData.map(ticker => {
                const update = action.payload.find(u => u.symbol === ticker.symbol);
                return update ? { ...ticker, ...update } : ticker;
            });
            // console.log('[DashboardReducer] UPDATE_MARKET_PRICES new state.marketData:', updatedMarketData.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
            return { ...state, marketData: updatedMarketData };
        case 'SET_PORTFOLIO':
            return { ...state, portfolio: action.payload };
        case 'SET_LOADING':
            return { ...state, isLoading: action.payload };
        case 'SET_SELECTED_SYMBOL':
            return { ...state, selectedSymbol: action.payload };
        case 'SET_ANALYSIS':
            return { ...state, analysis: action.payload };
        case 'SET_BOT_STATUS':
            return { ...state, botStatus: action.payload };
        case 'SET_TIMER':
            return { ...state, nextCycleIn: action.payload };
        case 'SET_LAST_RUN_ANALYSIS':
            return { ...state, lastRunAnalysis: action.payload };
        case 'SET_SHARED_CONTEXT':
            return { ...state, sharedContext: action.payload };
        case 'SET_ADJUSTED_CONFIG':
            return { ...state, adjustedConfig: action.payload };
        case 'SET_OPPORTUNITIES':
            // To avoid re-rendering the entire list every time, we can be a bit smarter
            // and only update if the data has actually changed.
            if (JSON.stringify(state.opportunities) !== JSON.stringify(action.payload)) {
                return { ...state, opportunities: action.payload };
            }
            return state;
        default:
            return state;
    }
}

// --- CONTEXT ---
const DashboardContext = createContext<{ state: DashboardState; dispatch: React.Dispatch<Action>; } | undefined>(undefined);

// --- PROVIDER ---
interface Config {
    cycleIntervalMinutes: number;
    [key: string]: unknown;
}

export function DashboardProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(dashboardReducer, initialState);
    const [config, setConfig] = useState<Config | null>(null);
    const timerIdRef = useRef<NodeJS.Timeout | null>(null);
    const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const isCycleRunningRef = useRef(false);

    useEffect(() => {
        async function fetchInitialData() {
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_MARKET_DATA', payload: data.marketData });
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch initial dashboard data:", error);
            }
        }

        fetchInitialData();

        const eventSource = new EventSource('/api/market-stream');
        
        eventSource.onmessage = (event) => {
            try {
                const data: BinanceTickerEvent[] = JSON.parse(event.data);
                // Log raw data for debugging
                // console.log('[DashboardContext] Raw market stream data:', data.map(d => ({ s: d.s, c: d.c })));

                const transformedData: Ticker[] = data.map((item) => ({
                    symbol: item.s,
                    lastPrice: item.c,
                    priceChangePercent: item.P,
                    quoteVolume: item.q,
                    // --- Adding dummy data to satisfy the Ticker type ---
                    priceChange: '',
                    weightedAvgPrice: '',
                    prevClosePrice: '',
                    lastQty: '',
                    bidPrice: '',
                    bidQty: '',
                    askPrice: '',
                    askQty: '',
                    openPrice: '',
                    highPrice: '',
                    lowPrice: '',
                    volume: '',
                    openTime: 0,
                    closeTime: 0,
                    firstId: 0,
                    lastId: 0,
                    count: 0,
                }));
                // Log transformed data for debugging
                // console.log('[DashboardContext] Transformed market stream data:', transformedData.map(d => ({ symbol: d.symbol, lastPrice: d.lastPrice })));
                dispatch({ type: 'UPDATE_MARKET_PRICES', payload: transformedData });
            } catch (error) {
                console.error("Failed to parse market stream data:", error);
            }
        };

        eventSource.onerror = (error) => {
            console.error('EventSource failed:', error);
            dispatch({ type: 'ADD_LOG', payload: 'Market data stream disconnected.' });
            eventSource.close();
        };

        const portfolioInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch updated portfolio data:", error);
            }
        }, 1000);

        const opportunityInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/opportunities');
                if (!response.ok) throw new Error('Failed to fetch opportunities');
                const data = await response.json();
                dispatch({ type: 'SET_OPPORTUNITIES', payload: data });
            } catch (error) {
                // This can fail if the file doesn't exist yet, which is fine.
            }
        }, 2000); // Poll every 2 seconds for responsiveness

        return () => {
            eventSource.close();
            clearInterval(portfolioInterval);
            clearInterval(opportunityInterval);
        };
    }, []);

    useEffect(() => {
        async function fetchConfig() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                setConfig(data);
            } catch {
                console.error("Failed to fetch config");
            }
        }
        fetchConfig();
    }, []);

    const CYCLE_INTERVAL = (config?.cycleIntervalMinutes || 20) * 60 * 1000;

    const runCycle = async () => {
        if (isCycleRunningRef.current) {
            dispatch({ type: 'ADD_LOG', payload: 'Cycle already in progress. Skipping.' });
            return;
        }
        isCycleRunningRef.current = true;
        dispatch({ type: 'ADD_LOG', payload: 'Bot cycle started... Attempting to fetch API.' });

        try {
            const res = await fetch('/api/bot/run');
            dispatch({ type: 'ADD_LOG', payload: `API response received. Status: ${res.status}` });

            if (!res.ok || !res.body) {
                const errorText = await res.text();
                dispatch({ type: 'ADD_LOG', payload: `API Error: Response not OK or no body. Details: ${errorText}` });
                throw new Error(`API request failed with status ${res.status}`);
            }
            
            dispatch({ type: 'ADD_LOG', payload: 'Response body is valid. Starting to read stream...' });
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            const currentAnalysis: Analysis = {};

            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    dispatch({ type: 'ADD_LOG', payload: 'Bot cycle finished.' });
                    dispatch({ type: 'SET_LAST_RUN_ANALYSIS', payload: currentAnalysis });
                    break;
                }
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
                for (const line of lines) {
                    try {
                        const json = JSON.parse(line.replace('data: ', ''));
                        const { type, message, data } = json;
                        if (type === 'log') {
                            if (message.startsWith('BOUGHT') || message.startsWith('SOLD')) {
                                toast.success(message);
                            }
                            dispatch({ type: 'ADD_LOG', payload: message });
                        } else if (type === 'analysis') {
                            dispatch({ type: 'SET_ANALYSIS', payload: data });
                        } else if (type === 'context') {
                            dispatch({ type: 'SET_SHARED_CONTEXT', payload: data });
                        } else if (type === 'adjusted_config') {
                            dispatch({ type: 'SET_ADJUSTED_CONFIG', payload: data });
                        } else if (type === 'aiChat' && data) {
                            dispatch({ type: 'ADD_AI_CHAT', payload: data });
                            if (data.agent.startsWith('PortfolioAllocator')) {
                                currentAnalysis.PortfolioAllocator = data;
                            }
                        }
                    } catch {
                        dispatch({ type: 'ADD_LOG', payload: 'Failed to parse stream data.' });
                    }
                }
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            dispatch({ type: 'ADD_LOG', payload: `[CYCLE ERROR] ${errorMessage}` });
        } finally {
            isCycleRunningRef.current = false;
            // Fetch the latest portfolio data after a cycle run
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch updated portfolio data:", error);
            }

            if (state.botStatus === 'active') {
                scheduleNextCycle();
            }
        }
    };

    const scheduleNextCycle = (immediate = false) => {
        if (timerIdRef.current) clearTimeout(timerIdRef.current);
        if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);

        if (immediate) {
            runCycle();
            return;
        }

        let timeLeft = CYCLE_INTERVAL;
        const updateTimer = () => {
            if (timeLeft <= 0) {
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
                return;
            }
            timeLeft -= 1000;
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.round((timeLeft % 60000) / 1000);
            dispatch({ type: 'SET_TIMER', payload: `${minutes}:${seconds < 10 ? '0' : ''}${seconds}` });
        };
        
        updateTimer();
        timerIntervalRef.current = setInterval(updateTimer, 1000);
        timerIdRef.current = setTimeout(runCycle, CYCLE_INTERVAL);
    };

    useEffect(() => {
        if (state.botStatus === 'active') {
            dispatch({ type: 'ADD_LOG', payload: "Bot activated. Starting first cycle immediately..." });
            scheduleNextCycle(true);
        } else {
            dispatch({ type: 'ADD_LOG', payload: "Bot stopped." });
            if (timerIdRef.current) clearTimeout(timerIdRef.current);
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
            dispatch({ type: 'SET_TIMER', payload: 'N/A' });
        }

        return () => {
            if (timerIdRef.current) clearTimeout(timerIdRef.current);
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [state.botStatus]);

    return (
        <DashboardContext.Provider value={{ state, dispatch }}>
            {children}
        </DashboardContext.Provider>
    );
}

// --- HOOK ---
export function useDashboard() {
    const context = useContext(DashboardContext);
    if (context === undefined) {
        throw new Error('useDashboard must be used within a DashboardProvider');
    }
    return context;
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\agents.ts ---
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold, GenerativeModel } from "@google/generative-ai";
import { Candle } from "./binance";
import { SharedContext } from "./context";
import { calculateRSI, calculateMACD, calculateSMAExported } from "./indicators";
class KeyRotator {
    private keys: string[];
    public currentIndex: number;

    constructor() {
        this.keys = process.env.GEMINI_API_KEYS?.split(',') || [];
        if (this.keys.length === 0) {
            throw new Error("GEMINI_API_KEYS not found or empty in .env.local");
        }
        this.currentIndex = 0;
        console.log(`Found ${this.keys.length} Gemini API keys. Starting with key #0.`);
    }

    getKey(): string {
        return this.keys[this.currentIndex];
    }

    getNextKey(): string {
        this.currentIndex = (this.currentIndex + 1) % this.keys.length;
        console.warn(`Switching Gemini API key to #${this.currentIndex}`);
        return this.getKey();
    }
}

export class AIAgent {
    private keyRotator: KeyRotator;
    private genAI: GoogleGenerativeAI;
    private model: GenerativeModel;

    constructor() {
        const modelName = process.env.GEMINI_MODEL_NAME || 'gemini-1.5-flash';
        this.keyRotator = new KeyRotator();
        this.genAI = new GoogleGenerativeAI(this.keyRotator.getKey());
        this.model = this.genAI.getGenerativeModel({ model: modelName });
    }

    private reinitializeModel() {
        this.genAI = new GoogleGenerativeAI(this.keyRotator.getKey());
        this.model = this.genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
    }

    async safeGenerate(prompt: string, retries = 3): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                const safetySettings = [
                    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
                    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
                    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
                    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
                ];

                const result = await this.model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    safetySettings,
                });
                const response = result.response;
                let jsonText = response.text().replace(/```json/g, "").replace(/```/g, "").trim();
                
                // Find the first '{' and the last '}' to ensure we get a valid JSON object
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');
                if (firstBrace === -1 || lastBrace === -1) {
                    throw new Error("No valid JSON object found in the response.");
                }
                jsonText = jsonText.substring(firstBrace, lastBrace + 1);

                const jsonResponse = JSON.parse(jsonText) as Record<string, unknown>;
                return { prompt, response: jsonResponse };

            } catch (error) {
                const errorMessage = (error as Error).message;
                // Check for rate limit errors (429, RESOURCE_EXHAUSTED, quota)
                if (errorMessage.includes('429') || errorMessage.includes('Too Many Requests') || errorMessage.includes('RESOURCE_EXHAUSTED') || errorMessage.includes('quota')) {
                    console.error(`AI Agent Error (Key #${this.keyRotator.currentIndex}): Rate limit or resource exhaustion. Switching key.`);
                    this.keyRotator.getNextKey();
                    this.reinitializeModel();
                    if (attempt < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retrying with new key
                        continue;
                    } else {
                        console.error("All keys have exhausted their limits or are invalid after retries.");
                        return null;
                    }
                }
                console.error(`AI Agent generation error: ${errorMessage}. Prompt: ${prompt.substring(0, 100)}...`);
                return null;
            }
        }
        return null;
    }

    // Placeholder for a more complex consultation mechanism
    async consult(agentName: string, query: Record<string, unknown>): Promise<Record<string, unknown> | null> {
        console.log(`Consultation requested from ${agentName} with query:`, query);
        // In a real implementation, this would dynamically call another agent instance.
        // For now, it's a conceptual placeholder for the architecture.
        return { response: `Consultation response placeholder for ${agentName}.` };
    }
}

export class MacroAnalyst extends AIAgent {
    async analyze(btcData: Record<string, unknown>, newsHeadlines: string[], fearAndGreedIndex: { value: string; classification: string } | null, sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Macroeconomic and Crypto Market Cycle Analyst. Your task is to assess the overall market environment.
        **Data:**
        1.  **Bitcoin (4H TF) Last Candle:** ${JSON.stringify(btcData)}
        2.  **Top News Headlines:** ${JSON.stringify(newsHeadlines)}
        3.  **Simulated On-Chain Data:** "Exchange Netflow: -1500 BTC (Neutral), Stablecoin Supply Ratio: Rising (Bullish)"
        4.  **CoinMarketCap Fear and Greed Index:** ${JSON.stringify(fearAndGreedIndex)}

        **Task:** Provide a critical market assessment in JSON format.
        - \`market_regime\`: "Risk-On" (favorable for risky assets) or "Risk-Off" (avoid risk).
        - \`regime_score\`: A number from 0.0 (extreme fear) to 10.0 (extreme greed).
        - \`reasoning\`: A brief explanation of why you chose this regime, referencing the provided data (e.g., "BTC price action is bullish, but news sentiment is neutral, leading to a cautiously optimistic score.").
        - \`summary\`: A one-sentence, actionable summary for the portfolio manager.
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const { market_regime, regime_score } = result.response;
            if (typeof market_regime === 'string' && (market_regime === 'Risk-On' || market_regime === 'Risk-Off') && typeof regime_score === 'number') {
                sharedContext.updateContext({
                    marketRegime: market_regime,
                    regimeScore: regime_score,
                    fearAndGreedIndex: fearAndGreedIndex
                });
            }
        }
        return result;
    }
}

// Define interfaces for agent method parameters
interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPrice?: number; // Added to match PortfolioService
    takeProfitPercent?: number;
    technicals?: Record<string, unknown>;
}

interface Config {
    sellStrategy: "takeProfit" | "trailing Stop";
    takeProfitPercent: number;
    stopLossPercent: number;
    trailingStopPercent: number;
    trailingProfitPercent: number;
    enablePartialProfitTaking: boolean; // Added
    partialProfitPercent: number; // Added
    riskAmountPercent: number;
    rsiPeriod: number;
    macdShortPeriod: number;
    macdLongPeriod: number;
    macdSignalPeriod: number;
    smaShortPeriod: number;
    smaLongPeriod: number;
}

interface DecisionHistory {
    timestamp: string;
    decision: string;
    justification: string;
}

export class PositionManager extends AIAgent {
    // Placeholder for a more complex consultation mechanism
    async consult(agentName: string, query: Record<string, unknown>): Promise<Record<string, unknown> | null> {
        console.log(`Consultation requested from ${agentName} with query:`, query);
        // In a real implementation, this would dynamically call another agent.
        // For now, it's a conceptual placeholder.
        return { response: "Consultation response placeholder." };
    }

    async decide(position: Position, currentPrice: number, macroAnalysis: unknown, sentimentAnalysis: unknown, config: Config, decisionHistory: DecisionHistory[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const pnlPercent = (currentPrice - position.entryPrice) / position.entryPrice * 100;
        const atTakeProfit = pnlPercent >= (position.takeProfitPercent || config.takeProfitPercent);
        const atStopLoss = pnlPercent <= config.stopLossPercent;

        let taskDescription = '';
        let trailingStopTriggered = false;

        if (config.sellStrategy === "trailing Stop" && position.highPrice) {
            const trailingStopPrice = position.highPrice * (1 + config.trailingStopPercent / 100);
            if (currentPrice <= trailingStopPrice) {
                trailingStopTriggered = true;
                taskDescription = `The position has triggered a trailing stop-loss. Current price (${currentPrice.toFixed(2)}) is below the trailing stop price (${trailingStopPrice.toFixed(2)}), which is ${Math.abs(config.trailingStopPercent)}% below the highest price (${position.highPrice.toFixed(2)}). You MUST sell to protect profits. Your only valid decision is "SELL_NOW".`;
            }
        }

        if (atStopLoss && !trailingStopTriggered) { // Stop loss is primary if trailing stop not triggered
            taskDescription = `The position has hit its stop-loss of ${config.stopLossPercent}%. You MUST sell to prevent further losses. Your only valid decision is "SELL_NOW".`;
        } else if (atTakeProfit && !trailingStopTriggered) {
            taskDescription = `The position has reached its take-profit target of ${config.takeProfitPercent}%. Decide whether to sell now or let the profit run by increasing the take-profit target. Consider the macro/sentiment environment, the asset's momentum, and your own past decisions on this asset.`;
        } else if (!atStopLoss && !atTakeProfit && !trailingStopTriggered) {
            taskDescription = `The position is currently active. Decide whether to hold or sell based on current market conditions and your strategy.`;
        }

        // If a trailing stop or hard stop loss is triggered, the AI must sell.
        const forceSell = atStopLoss || trailingStopTriggered;

        let partialSellOption = '';
        if (!forceSell && atTakeProfit && config.enablePartialProfitTaking) {
            partialSellOption = `
            - **"PARTIAL_SELL_AND_HOLD"**: Sell ${config.partialProfitPercent}% of the position now to lock in some profit, and hold the remaining ${100 - config.partialProfitPercent}% to let profits run further. If choosing this, you must also provide a \`new_take_profit_percent\` for the remaining position.
            `;
            taskDescription = `The position has reached its take-profit target of ${config.takeProfitPercent}%. Decide whether to sell all now, sell a portion and hold the rest, or let the profit run by increasing the take-profit target. Consider the macro/sentiment environment, the asset's momentum, and your own past decisions on this asset.`;
        }

        const prompt = `
        **Persona:** You are a professional, stateful trader managing a profitable position. Your goal is to maximize gains while intelligently protecting profits.

        **Current Context:**
        - **Position:** ${JSON.stringify(position, null, 2)}
        - **Current Price:** ${currentPrice}
        - **Current P/L (%):** ${pnlPercent.toFixed(2)}%
        - **Take-Profit Target (%):** ${position.takeProfitPercent || config.takeProfitPercent}%
        - **Stop-Loss Target (%):** ${config.stopLossPercent}%
        - **Trailing Stop Percent (%):** ${config.trailingStopPercent}% (if applicable)
        - **Highest Price Reached (since entry):** ${position.highPrice?.toFixed(2) || 'N/A'}
        - **Macro Environment:** ${JSON.stringify(macroAnalysis, null, 2)}
        - **Market Sentiment:** ${JSON.stringify(sentimentAnalysis, null, 2)}
        - **Asset's Technical Indicators:** ${JSON.stringify(position.technicals, null, 2)}
        - **Partial Profit Taking Enabled:** ${config.enablePartialProfitTaking}
        - **Partial Profit Percentage:** ${config.partialProfitPercent}%

        **Your Decision History For This Asset (Memory):**
        ${JSON.stringify(decisionHistory, null, 2)}

        **Task:** ${taskDescription}
        Critically evaluate the situation. Your primary goal is to protect capital and maximize profit.
        ${forceSell ? `
        **IMPORTANT:** A stop-loss or trailing stop has been triggered. You MUST make the decision "SELL_NOW". Do not attempt to hold.
        ` : `
        1.  **Review Initial Thesis:** Was the original reason for buying this asset still valid, based on the current macro and sentiment data?
        2.  **Analyze Technical Health:** Do the technical indicators (RSI, MACD) show strength, or are they suggesting the trend is exhausted (e.g., bearish divergence)?
        3.  **Make a Prudent Decision:** Decide between:
            - **"SELL_NOW"**: To lock in all profits.
            - **"HOLD_AND_INCREASE_TP"**: To let profits run by increasing the take-profit target. If choosing this, the new take-profit must be realistic.
            ${partialSellOption}
            Be a disciplined profit-taker, not a greedy gambler.
        `}

        **Format (JSON):**
        - \`decision\`: "SELL_NOW", "HOLD_AND_INCREASE_TP", or "PARTIAL_SELL_AND_HOLD".
        - \`new_take_profit_percent\`: (Only if holding or partial selling) The new take-profit percentage (e.g., if current is ${config.takeProfitPercent}%, new could be ${config.takeProfitPercent + 1}%).
        - \`justification\`: A brief reason for your decision.
        `;
        return await this.safeGenerate(prompt);
    }
}

interface BuySignal {
    symbol: string;
    [key: string]: unknown;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

export class PortfolioAllocator extends AIAgent {
    async allocate(buySignals: BuySignal[], portfolio: Portfolio, macroAnalysis: unknown, sentimentAnalysis: unknown, sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Chief Investment Officer managing a high-risk, high-reward crypto portfolio. Your primary goal is to maximize returns while managing risk.

        **Context:**
        - **Current Portfolio:** ${JSON.stringify(portfolio, null, 2)}
        - **Macro Environment:** ${JSON.stringify(macroAnalysis, null, 2)}
        - **Market Sentiment:** ${JSON.stringify(sentimentAnalysis, null, 2)}
        - **Candidate Assets with "BUY" Signals:**
        ${JSON.stringify(buySignals, null, 2)}

        **Task & Rules:**
        1.  **Holistic Review:** Synthesize all available data. A high technical score is not enough if the macro environment is poor.
        2.  **Risk Management First:**
            - Do not deploy more than 50% of the available \`portfolio.balance\` in a single cycle.
            - Do not allocate more than 25% of the *deployable capital* to a single asset to ensure diversification.
        3.  **Strategic Capital Allocation:** Based on the rules above, decide on the total capital to deploy. Then, allocate this capital across the opportunities with the highest conviction (strong alignment between macro, sentiment, and technicals).
        4.  **Prioritize and Justify:** You must prioritize. If no signal is strong enough to meet your high standards, it is mandatory to "PASS" on all of them to preserve capital.

        **Format (JSON):** An object where each key is the symbol. The value should be an object with:
        - \`decision\`: "EXECUTE_BUY" or "PASS".
        - \`amount_to_buy_usd\`: The amount in USD to invest. Must be a number.
        - \`justification\`: A professional, concise reason for your decision, referencing the provided data.
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const allocations = result.response;
            const executedBuys = Object.entries(allocations)
                .filter(([, decision]) => (decision as { decision: string }).decision === 'EXECUTE_BUY')
                .map(([symbol]) => symbol);
            
            if (executedBuys.length > 0) {
                sharedContext.updateContext({ activeOpportunities: executedBuys });
            }
        }
        return result;
    }
}

export class SentimentAnalyst extends AIAgent {
    async analyze(newsArticles: { title?: string }[], sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const headlines = newsArticles.map(article => article.title || '');
        const prompt = `
        **Persona:** You are an AI that analyzes text sentiment.
        **Data:** These news headlines: ${JSON.stringify(headlines.slice(0, 10))}
        **Task:** Evaluate the overall sentiment from the headlines and provide a structured analysis in JSON format.
        - \`sentiment\`: "Bullish", "Bearish", or "Neutral".
        - \`sentiment_score\`: A number from -1.0 (extremely negative) to 1.0 (extremely positive).
        - \`dominant_narrative\`: A short phrase describing the main story in the news (e.g., "Regulatory concerns" or "Bitcoin ETF hype").
        - \`key_topics\`: [List, of, key, topics, driving, the, narrative].
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const { sentiment, sentiment_score, key_topics } = result.response;
            if (typeof sentiment === 'string' && (sentiment === 'Bullish' || sentiment === 'Bearish' || sentiment === 'Neutral') && typeof sentiment_score === 'number' && Array.isArray(key_topics)) {
                sharedContext.updateContext({
                    sentiment: sentiment,
                    sentimentScore: sentiment_score,
                    keyTopics: key_topics as string[]
                });
            }
        }
        return result;
    }
}

export class TechnicalAnalyst extends AIAgent {
    async analyze(symbol: string, candles: Candle[], config: Config): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        return this.analyzeBatch([{ symbol, candles }], config);
    }

    async analyzeBatch(batchData: { symbol: string, candles: Candle[] }[], config: Config): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const formattedData = batchData.map(data => {
            const { symbol, candles } = data;
            const rsi = calculateRSI(candles, config.rsiPeriod);
            const macd = calculateMACD(candles, config.macdShortPeriod, config.macdLongPeriod, config.macdSignalPeriod);
            const sma20 = calculateSMAExported(candles, config.smaShortPeriod);
            const sma50 = calculateSMAExported(candles, config.smaLongPeriod);
            return {
                symbol,
                lastClose: candles[candles.length - 1].close,
                sma20: sma20?.toFixed(2),
                sma50: sma50?.toFixed(2),
                rsi: rsi?.toFixed(2),
                macdHistogram: macd?.histogram?.toFixed(4)
            };
        });

        const prompt = `
        **Persona:** You are a world-class quantitative analyst. Analyze the following batch of assets.
        **Data:**
        ${JSON.stringify(formattedData, null, 2)}

        **Task:** For each asset, provide a concise technical analysis and a score.
        **Format (JSON):** An object where each key is the symbol (e.g., "BTCUSDT"). The value should be an object with:
        - \`technical_score\`: 0.0 (strong sell) to 10.0 (strong buy).
        - \`trend\`: "Uptrend", "Downtrend", "Sideways".
        - \`momentum\`: "Bullish", "Bearish", "Neutral".
        - \`summary\`: A one-sentence summary, including any warning signs like potential trend exhaustion or divergence.
        `;
        return await this.safeGenerate(prompt);
    }
}

export interface Analysis {
    MacroAnalyst: unknown;
    SentimentAnalyst: unknown;
    [key: string]: unknown;
}

export class RiskManager extends AIAgent {
    determineRiskParameters(baseConfig: Config, sharedContext: SharedContext): Config {
        const { regimeScore } = sharedContext.getContext();
        const newConfig = { ...baseConfig };

        // Example of dynamic adjustment:
        // If market regime is very bullish (e.g., score > 7.5), slightly increase risk.
        if (regimeScore > 7.5) {
            newConfig.riskAmountPercent = baseConfig.riskAmountPercent * 1.25; // Risk 25% more
            newConfig.takeProfitPercent = baseConfig.takeProfitPercent * 0.9; // Take profit sooner
        } 
        // If market regime is bearish (e.g., score < 4.0), decrease risk significantly.
        else if (regimeScore < 4.0) {
            newConfig.riskAmountPercent = baseConfig.riskAmountPercent * 0.5; // Risk 50% less
            newConfig.stopLossPercent = baseConfig.stopLossPercent * 0.8; // Tighter stop loss
        }
        
        return newConfig;
    }

    async decide(analysis: Analysis): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        return this.decideBatch([analysis], analysis.MacroAnalyst, analysis.SentimentAnalyst);
    }

    async decideBatch(batchAnalyses: Analysis[], macroAnalysis: unknown, sentimentAnalysis: unknown): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        // Conceptual example of using consultation
        // if (some_condition_of_uncertainty) {
        //     const deeperAnalysis = await this.consult('TechnicalAnalyst', { query: 'Re-analyze BTCUSDT on 1D timeframe' });
        //     // ... incorporate deeperAnalysis into the decision prompt
        // }

        const prompt = `
        **Persona:** You are a seasoned Portfolio Manager. Make final decisions for the following batch of assets.
        **Macro Environment:** ${JSON.stringify(macroAnalysis, null, 2)}
        **Market Sentiment:** ${JSON.stringify(sentimentAnalysis, null, 2)}
        **Batch Technical Analysis:**
        ${JSON.stringify(batchAnalyses, null, 2)}

        **Task:** Act as the final decision-maker. For each asset, synthesize all analysis layers (Macro, Sentiment, Technical) to make a final, risk-assessed trading decision.
        **Your Thought Process:**
        1.  Is the **Macro Environment** favorable for this trade? (\`regime_score\`)
        2.  Does the **Market Sentiment** support this trade? (\`sentiment_score\`)
        3.  Is the **Technical Score** high enough and does the summary indicate a good entry point?
        4.  A "BUY" signal requires a strong alignment across ALL THREE layers. Do not issue a BUY if one layer is strongly negative.

        **Format (JSON):** An object where each key is the symbol. The value should be an object with:
        - \`decision\`: "BUY", "HOLD", or "AVOID".
        - \`confidence_score\`: 0.0 (low) to 10.0 (high). This score must reflect the alignment of all three analysis layers.
        - \`final_summary\`: A one-sentence justification that explicitly references why the macro, sentiment, and technical data support your decision.
        `;
        return await this.safeGenerate(prompt);
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\binance.ts ---
import axios from 'axios';

// Type for a single candle
export type Candle = {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
};

// Type for the daily ticker stats
export type Ticker = {
    symbol: string;
    priceChange: string;
    priceChangePercent: string;
    weightedAvgPrice: string;
    prevClosePrice: string;
    lastPrice: string;
    lastQty: string;
    bidPrice: string;
    bidQty: string;
    askPrice: string;
    askQty: string;
    openPrice: string;
    highPrice: string;
    lowPrice: string;
    volume: string;
    quoteVolume: string;
    openTime: number;
    closeTime: number;
    firstId: number;
    lastId: number;
    count: number;
};

export class BinanceService {
    private baseUrl = 'https://api.binance.com/api/v3';

    private async fetchApi(endpoint: string, params: Record<string, string> = {}) {
        try {
            const response = await axios.get(`${this.baseUrl}/${endpoint}`, { params });
            return response.data;
        } catch (error) {
            console.error(`Failed to fetch from Binance API: ${endpoint}`, error);
            throw error;
        }
    }

    async getHistoricalData(symbol: string, interval: string, limit = 100): Promise<Candle[]> {
        // Define the raw candle type from Binance API
        type BinanceCandle = [number, string, string, string, string, string, ...unknown[]];
        try {
            const data = await this.fetchApi('klines', { symbol, interval, limit: String(limit) });
            return data.map((d: BinanceCandle) => ({
                time: d[0] / 1000,
                open: parseFloat(d[1]),
                high: parseFloat(d[2]),
                low: parseFloat(d[3]),
                close: parseFloat(d[4]),
                volume: parseFloat(d[5]),
            }));
        } catch {
            return [];
        }
    }

    async getCurrentPrice(symbol: string): Promise<number | null> {
        try {
            const data = await this.fetchApi('ticker/price', { symbol });
            return parseFloat(data.price);
        } catch {
            return null;
        }
    }

    async getTopSymbols(limit = 200): Promise<Ticker[]> {
        try {
            const data: Ticker[] = await this.fetchApi('ticker/24hr');
            // Filter for USDT pairs and exclude leveraged tokens or other special assets
            const usdtPairs = data.filter(t => 
                t.symbol.endsWith('USDT') && 
                !t.symbol.includes('UP') && 
                !t.symbol.includes('DOWN') &&
                !t.symbol.includes('BULL') &&
                !t.symbol.includes('BEAR') &&
                !t.symbol.match(/^\d/) // Exclude symbols that start with a number
            );
            const sorted = usdtPairs.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            return sorted.slice(0, limit);
        } catch {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\coinmarketcap.ts ---
interface FearAndGreedData {
    value: string;
    value_classification: string;
    update_time: string;
}

interface FearAndGreedResponse {
    data: FearAndGreedData | null;
    status: {
        timestamp: string;
        error_code: number | string; // Allow error_code to be string or number
        error_message: string | null;
        elapsed: number;
        credit_count: number;
        notice: string | null;
    };
}

export class CoinMarketCapService {
    private apiKey: string;
    private baseUrl: string = 'https://pro-api.coinmarketcap.com/v3/fear-and-greed/latest';

    constructor() {
        this.apiKey = process.env.CMC_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('CMC_API_KEY is not defined in the environment variables.');
        }
    }

    async getFearAndGreedIndex(): Promise<FearAndGreedData | null> {
        try {
            const url = this.baseUrl;
            const response = await fetch(url, {
                headers: {
                    'X-CMC_PRO_API_KEY': this.apiKey,
                },
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch Fear and Greed Index: ${response.statusText}`);
            }

            const data: FearAndGreedResponse = await response.json();
            if (Number(data.status.error_code) !== 0) { // Explicitly convert to number for comparison
                console.error('CoinMarketCap API full error status:', data.status);
                throw new Error(`CoinMarketCap API error: ${data.status.error_message || 'Unknown error'}`);
            }

            return data.data;
        } catch (error) {
            console.error('Error fetching Fear and Greed Index:', error);
            return null;
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\context.ts ---
// src/core/context.ts

/**
 * Defines the structure for the shared context that all AI agents can access.
 * This acts as a "hive mind" or a central nervous system for the trading bot,
 * allowing agents to be aware of the broader state discovered by other agents.
 */
export interface ISharedContext {
    marketRegime: 'Risk-On' | 'Risk-Off' | 'Neutral';
    regimeScore: number; // 0.0 to 10.0
    sentiment: 'Bullish' | 'Bearish' | 'Neutral';
    sentimentScore: number; // -1.0 to 1.0
    fearAndGreedIndex: { value: string; classification: string } | null; // Added Fear and Greed Index
    keyTopics: string[];
    activeThreats: string[]; // e.g., ["High volatility", "Low liquidity"]
    activeOpportunities: string[]; // e.g., ["Strong narrative in AI tokens"]
}

/**
 * Manages the shared state (the "hive mind") for a single trading cycle.
 * An instance of this class will be created at the start of each cycle
 * and passed to each agent.
 */
export class SharedContext {
    private context: ISharedContext;

    constructor() {
        this.context = {
            marketRegime: 'Neutral',
            regimeScore: 5.0,
            sentiment: 'Neutral',
            sentimentScore: 0.0,
            fearAndGreedIndex: null, // Initialize Fear and Greed Index
            keyTopics: [],
            activeThreats: [],
            activeOpportunities: [],
        };
    }

    /**
     * Updates one or more properties of the shared context.
     * @param updates A partial object of the ISharedContext to update.
     */
    public updateContext(updates: Partial<ISharedContext>): void {
        this.context = { ...this.context, ...updates };
        console.log('SharedContext updated:', updates);
    }

    /**
     * Retrieves the current state of the shared context.
     * @returns The full shared context object.
     */
    public getContext(): ISharedContext {
        return { ...this.context };
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\decision-logger.ts ---
import fs from 'fs/promises';
import path from 'path';

const getDecisionLogPath = (username: string) => path.join(process.cwd(), `decision_log_${username}.json`);

export interface DecisionLogEntry {
    symbol: string;
    decision: 'SELL_NOW' | 'HOLD_AND_INCREASE_TP' | 'BUY' | 'AVOID'; // Added BUY and AVOID
    pnlPercent?: number; // Made optional as it might not apply to BUY/AVOID
    currentPrice?: number; // Made optional
    newTakeProfitPercent?: number;
    amount?: number; // Added for BUY decisions
    reason?: string; // Changed from justification to reason for consistency with other logs
    justification?: string; // Kept for backward compatibility if needed, but prefer 'reason'
    timestamp: string;
}

export class DecisionLogger {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to DecisionLogger.");
        }
        this.username = username;
    }

    private getFilePath(): string {
        return getDecisionLogPath(this.username);
    }

    public async log(entry: Omit<DecisionLogEntry, 'timestamp'>): Promise<void> {
        const logFilePath = this.getFilePath();
        let logs: DecisionLogEntry[] = [];
        try {
            const data = await fs.readFile(logFilePath, 'utf-8');
            logs = JSON.parse(data);
        } catch (error) {
            // File might not exist yet, which is fine.
        }

        const newLog: DecisionLogEntry = {
            ...entry,
            timestamp: new Date().toISOString(),
        };

        logs.unshift(newLog); // Add to the beginning
        await fs.writeFile(logFilePath, JSON.stringify(logs, null, 2));
    }

    public async getLogs(): Promise<DecisionLogEntry[]> {
        try {
            const data = await fs.readFile(this.getFilePath(), 'utf-8');
            return JSON.parse(data);
        } catch (error) {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\global-context.ts ---
import { SharedContext } from './context';

// Create a single, global instance of SharedContext
export const globalSharedContext = new SharedContext();

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\indicators.ts ---
import { Candle } from './binance';

// Helper to calculate Simple Moving Average (SMA)
function calculateSMA(data: number[], period: number): number[] {
    const sma: number[] = [];
    for (let i = 0; i <= data.length - period; i++) {
        const chunk = data.slice(i, i + period);
        const sum = chunk.reduce((a, b) => a + b, 0);
        sma.push(sum / period);
    }
    return sma;
}

// Helper to calculate Exponential Moving Average (EMA)
function calculateEMA(data: number[], period: number): number[] {
    const ema: number[] = [];
    const multiplier = 2 / (period + 1);
    let prevEma = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
    ema.push(prevEma);

    for (let i = period; i < data.length; i++) {
        const currentEma = (data[i] - prevEma) * multiplier + prevEma;
        ema.push(currentEma);
        prevEma = currentEma;
    }
    return ema;
}

export function calculateSMAExported(candles: Candle[], period: number): number | null {
    if (candles.length < period) return null;
    const prices = candles.map(c => c.close);
    const smaValues = calculateSMA(prices, period);
    return smaValues[smaValues.length - 1];
}

export function calculateRSI(candles: Candle[], period: number = 14): number | null {
    if (candles.length < period) return null;
    const prices = candles.map(c => c.close);
    let gains = 0;
    let losses = 0;

    for (let i = 1; i < prices.length; i++) {
        const diff = prices[i] - prices[i - 1];
        if (diff > 0) {
            gains += diff;
        } else {
            losses -= diff;
        }
    }

    const avgGain = gains / period;
    const avgLoss = losses / period;

    if (avgLoss === 0) return 100;

    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}

export function calculateMACD(candles: Candle[], shortPeriod: number = 12, longPeriod: number = 26, signalPeriod: number = 9) {
    if (candles.length < longPeriod) return null;
    const prices = candles.map(c => c.close);
    
    const emaShort = calculateEMA(prices, shortPeriod);
    const emaLong = calculateEMA(prices, longPeriod);
    
    const macdLine = emaShort.slice(emaLong.length - emaShort.length).map((val, index) => val - emaLong[index]);
    const signalLine = calculateEMA(macdLine, signalPeriod);
    
    const histogram = macdLine.slice(signalLine.length - macdLine.length).map((val, index) => val - signalLine[index]);

    return {
        macd: macdLine[macdLine.length - 1],
        signal: signalLine[signalLine.length - 1],
        histogram: histogram[histogram.length - 1],
    };
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\news.ts ---
// Define the Article interface based on NewsAPI response
interface Article {
    source: {
        id: string | null;
        name: string;
    };
    author: string | null;
    title: string;
    description: string | null;
    url: string;
    urlToImage: string | null;
    publishedAt: string;
    content: string | null;
}

export class NewsService {
    private apiKey: string;
    private baseUrl: string = 'https://newsapi.org/v2/everything';

    constructor() {
        this.apiKey = process.env.NEWS_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('NEWS_API_KEY is not defined in the environment variables.');
        }
    }

    async getCryptoNews(query: string = 'crypto', pageSize: number = 10): Promise<Article[]> {
        try {
            const url = `${this.baseUrl}?q=${query}&apiKey=${this.apiKey}&pageSize=${pageSize}&sortBy=publishedAt&language=en`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch news: ${response.statusText}`);
            }
            const data = await response.json();
            return data.articles || [];
        } catch (error) {
            console.error('Error fetching crypto news:', error);
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\opportunity-logger.ts ---
// src/core/opportunity-logger.ts
import fs from 'fs/promises';
import path from 'path';

const getMissedOpportunitiesPath = (username: string) => path.join(process.cwd(), `missed_opportunities_${username}.json`);

export interface MissedOpportunity {
    timestamp: string;
    symbol: string;
    priceChangePercent: number; // Added this field
    reason: string; // e.g., "AVOID decision by RiskManager"
    confidenceScore?: number;
    finalSummary?: string;
}

export class OpportunityLogger {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to OpportunityLogger.");
        }
        this.username = username;
    }

    private getFilePath(): string {
        return getMissedOpportunitiesPath(this.username);
    }

    public async getLogs(): Promise<MissedOpportunity[]> {
        try {
            const data = await fs.readFile(this.getFilePath(), 'utf-8');
            return JSON.parse(data);
        } catch {
            // If file doesn't exist or is invalid, start with an empty array
            return [];
        }
    }

    async log(opportunity: Omit<MissedOpportunity, 'timestamp'>): Promise<void> {
        try {
            const logs = await this.getLogs();
            const newLog: MissedOpportunity = {
                timestamp: new Date().toISOString(),
                ...opportunity,
            };
            logs.push(newLog);
            // Keep the log from growing indefinitely
            const trimmedLogs = logs.slice(-500); 
            await fs.writeFile(this.getFilePath(), JSON.stringify(trimmedLogs, null, 2));
        } catch (error) {
            console.error("Failed to log missed opportunity:", error);
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\opportunity-scanner.ts ---
import fs from 'fs/promises';
import path from 'path';

const opportunitiesLogPath = path.join(process.cwd(), 'opportunities.json');

export interface Opportunity {
    symbol: string;
    priceChangePercent: number;
    timestamp: string;
    status: 'detected' | 'analyzing' | 'bought' | 'ignored' | 'sold' | 'held';
}

export class OpportunityScanner {
    private static instance: OpportunityScanner;
    private opportunities: Opportunity[] = [];

    private constructor() {
        this.loadOpportunities();
    }

    public static getInstance(): OpportunityScanner {
        if (!OpportunityScanner.instance) {
            OpportunityScanner.instance = new OpportunityScanner();
        }
        return OpportunityScanner.instance;
    }

    private async loadOpportunities(): Promise<void> {
        try {
            const data = await fs.readFile(opportunitiesLogPath, 'utf-8');
            this.opportunities = JSON.parse(data);
        } catch (error) {
            // File might not exist yet, which is fine.
            this.opportunities = [];
        }
    }

    private async saveOpportunities(): Promise<void> {
        await fs.writeFile(opportunitiesLogPath, JSON.stringify(this.opportunities, null, 2));
    }

    public async addOpportunity(opportunity: Omit<Opportunity, 'timestamp' | 'status'>): Promise<void> {
        const newOpportunity: Opportunity = {
            ...opportunity,
            timestamp: new Date().toISOString(),
            status: 'detected',
        };
        this.opportunities.unshift(newOpportunity); // Add to the beginning of the array
        await this.saveOpportunities();
    }

    public getOpportunities(): Opportunity[] {
        return this.opportunities;
    }

    public async updateOpportunityStatus(symbol: string, status: Opportunity['status']): Promise<void> {
        const opportunity = this.opportunities.find(o => o.symbol === symbol);
        if (opportunity) {
            opportunity.status = status;
            await this.saveOpportunities();
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\optimizer.ts ---
import { AIAgent } from './agents';
import { DecisionLogEntry } from './decision-logger';
import { MissedOpportunity } from './opportunity-logger';

// Define the Trade interface
export interface Trade {
    symbol: string;
    amount: number;
    entryPrice: number;
    exitPrice: number;
    pnl: number;
    timestamp: string;
    reason: string;
}

export class StrategyOptimizer extends AIAgent {
    async analyze(trades: Trade[], missedOpportunities: MissedOpportunity[], decisionLogs: DecisionLogEntry[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Quantitative Analyst and AI Strategist. Your core function is to evolve this trading bot by learning from its complete performance history.

        **You have three data sources:**
        1.  **Executed Trades Log:** The final outcome of each trade (profit or loss).
        ${JSON.stringify(trades, null, 2)}

        2.  **Missed Opportunities Log:** Assets the bot decided to "AVOID".
        ${JSON.stringify(missedOpportunities, null, 2)}

        3.  **Position Management Decisions Log:** Records of when the bot decided to "HOLD" a winning position instead of selling immediately.
        ${JSON.stringify(decisionLogs, null, 2)}

        **CRITICAL TASK: Perform a holistic, data-driven analysis and generate a new, superior configuration.**

        1.  **Analyze Executed Trades:** What are the common characteristics of winning trades vs. losing trades? Look for patterns in technical indicators, market regime, etc.
        2.  **Analyze Missed Opportunities:** Were there any "AVOID" decisions that turned out to be highly profitable? Does this suggest the bot's entry criteria are too strict?
        3.  **Analyze Position Management (MOST IMPORTANT):** This is key to maximizing profit. For each "HOLD_AND_INCREASE_TP" decision in the log, compare the price at the time of the decision to the final exit price in the "Executed Trades Log".
            - Was holding the position, on average, more profitable than selling immediately?
            - Does the data suggest the \`takeProfitPercent\` should be higher or lower? Should it be more dynamic?
        4.  **Propose & Justify:** Based on your complete analysis, generate a new, fully optimized configuration. Your summary must explain *why* you are making each key change, referencing your findings from all three data logs.

        **Format (JSON):**
        - \`analysis_summary\`: A brief summary of your key findings from the trade history.
        - \`suggested_settings\`: A complete JSON object containing the full, new configuration. This object must include values for all of these keys: "sellStrategy", "takeProfitPercent", "stopLossPercent", "trailingStopPercent", "riskAmountPercent", "rsiPeriod", "symbolsToAnalyze", "batchSize", "macroScoreThreshold", "minimumBalance", "cycleIntervalMinutes", "smaShortPeriod", "smaLongPeriod", "macdShortPeriod", "macdLongPeriod", "macdSignalPeriod".
        `;
        return await this.safeGenerate(prompt);
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\core\portfolio.ts ---
import fs from 'fs/promises';
import path from 'path';
import { setTimeout } from 'timers/promises';
import { Trade } from './optimizer';

// DYNAMIC FILE PATHS BASED ON USERNAME
const getPortfolioFilePath = (username: string) => path.join(process.cwd(), `portfolio_${username}.json`);
const getLockFilePath = (username: string) => path.join(process.cwd(), `portfolio_${username}.lock`);
const getTradesLogFilePath = (username: string) => path.join(process.cwd(), `trades_log_${username}.json`);
const getBuyLogFilePath = (username: string) => path.join(process.cwd(), `buy_log_${username}.json`);

interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPrice?: number; // Added to track the highest price reached by the position
    takeProfitPercent?: number;
    holdCount?: number;
    stopLossPrice?: number;
    highPnlPercent?: number;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

interface BuyLog extends Position {
    timestamp: string;
}

export class PortfolioService {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to PortfolioService.");
        }
        this.username = username;
    }

    private getFilePaths() {
        return {
            portfolioFilePath: getPortfolioFilePath(this.username),
            lockFilePath: getLockFilePath(this.username),
            tradesLogFilePath: getTradesLogFilePath(this.username),
            buyLogFilePath: getBuyLogFilePath(this.username),
        };
    }

    private async withPortfolio(worker: (portfolio: Portfolio) => Promise<void> | void): Promise<void> {
        const { lockFilePath, portfolioFilePath } = this.getFilePaths();
        // console.log(`[PortfolioService] Attempting to acquire lock for ${this.username}...`);
        const lockAcquired = await this.acquireLock(lockFilePath);
        if (!lockAcquired) {
            console.error('[PortfolioService] Failed to acquire portfolio lock.');
            throw new Error('Failed to acquire portfolio lock after multiple retries.');
        }
        // console.log('[PortfolioService] Lock acquired.');

        let portfolio: Portfolio;
        try {
            try {
                const data = await fs.readFile(portfolioFilePath, 'utf-8');
                portfolio = JSON.parse(data);
                // console.log(`[PortfolioService] Read portfolio for ${this.username}:`, JSON.stringify(portfolio));
            } catch (error) {
                if (error instanceof Error && (error as NodeJS.ErrnoException).code === 'ENOENT') {
                    // console.log(`Portfolio file for ${this.username} not found. Creating a new one.`);
                    portfolio = { balance: 100000, positions: [] };
                } else {
                    console.error("Failed to read or parse portfolio.json:", error);
                    throw new Error("Portfolio file is corrupted or unreadable.");
                }
            }

            await worker(portfolio);

            // console.log(`[PortfolioService] Portfolio for ${this.username} after worker:`, JSON.stringify(portfolio));
            await fs.writeFile(portfolioFilePath, JSON.stringify(portfolio, null, 2));
            // console.log(`[PortfolioService] Successfully wrote to portfolio for ${this.username}.`);
        } finally {
            await this.releaseLock(lockFilePath);
            // console.log(`[PortfolioService] Lock for ${this.username} released.`);
        }
    }

    private async acquireLock(lockFilePath: string, retries = 20, delay = 200): Promise<boolean> { // Increased retries and delay
        for (let i = 0; i < retries; i++) {
            try {
                await fs.writeFile(lockFilePath, process.pid.toString(), { flag: 'wx' });
                return true;
            } catch (error) {
                if (error instanceof Error && (error as NodeJS.ErrnoException).code === 'EEXIST') {
                    // Check if the lock file is stale (e.g., process died without releasing lock)
                    try {
                        const lockPid = parseInt(await fs.readFile(lockFilePath, 'utf-8'));
                        // In a real system, you'd check if lockPid is still a running process.
                        // For simplicity here, we'll assume if it's old enough, it's stale.
                        const stats = await fs.stat(lockFilePath);
                        const now = new Date();
                        const lockAgeMinutes = (now.getTime() - stats.mtime.getTime()) / (1000 * 60);
                        if (lockAgeMinutes > 5) { // If lock file is older than 5 minutes, consider it stale
                            console.warn(`[PortfolioService] Stale lock file detected for ${lockFilePath}. Attempting to remove.`);
                            await fs.unlink(lockFilePath); // Remove stale lock
                            continue; // Retry acquiring lock immediately
                        }
                    } catch (readError) {
                        // Ignore errors reading or stat-ing the lock file, just proceed with delay
                    }
                    await setTimeout(delay);
                } else {
                    throw error;
                }
            }
        }
        return false;
    }

    private async releaseLock(lockFilePath: string): Promise<void> {
        try {
            await fs.unlink(lockFilePath);
        } catch (error) {
            if (error instanceof Error && (error as NodeJS.ErrnoException).code !== 'ENOENT') {
                console.error(`Failed to release portfolio lock for ${this.username}:`, error);
            }
        }
    }

    async getPortfolio(): Promise<Portfolio> {
        const { portfolioFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(portfolioFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return { balance: 100000, positions: [] };
        }
    }

    async buy(symbol: string, amount: number, price: number): Promise<void> {
        await this.withPortfolio(async (portfolio) => {
            const cost = amount * price;
            const fee = cost * 0.001; // 0.1% fee
            if (portfolio.balance < cost + fee) {
                throw new Error('Insufficient balance for cost + fee');
            }
            portfolio.balance -= (cost + fee);

            const logEntry = { symbol, amount, entryPrice: price, highPrice: price }; // Initialize highPrice on buy

            const existingPosition = portfolio.positions.find(p => p.symbol === symbol);
            if (existingPosition) {
                const totalAmount = existingPosition.amount + amount;
                const newEntryPrice = ((existingPosition.entryPrice * existingPosition.amount) + (price * amount)) / totalAmount;
                existingPosition.entryPrice = newEntryPrice;
                existingPosition.amount = totalAmount;
                // When adding to an existing position, update highPrice if current price is higher
                if (price > (existingPosition.highPrice || 0)) {
                    existingPosition.highPrice = price;
                }
            } else {
                portfolio.positions.push(logEntry);
            }
            
            await this.logBuy(logEntry);
        });
    }

    async logBuy(position: Position): Promise<void> {
        const { buyLogFilePath } = this.getFilePaths();
        const buyLogs = await this.getBuyLogs();
        const logEntry = {
            timestamp: new Date().toISOString(),
            ...position
        };
        buyLogs.push(logEntry);
        await fs.writeFile(buyLogFilePath, JSON.stringify(buyLogs, null, 2));
    }

    async updatePosition(symbol: string, updates: Partial<Position>): Promise<void> {
        await this.withPortfolio((portfolio) => {
            const position = portfolio.positions.find(p => p.symbol === symbol);
            if (position) {
                // Update highPrice if the new currentPrice is higher
                if (updates.highPrice && (updates.highPrice > (position.highPrice || 0))) {
                    position.highPrice = updates.highPrice;
                }
                Object.assign(position, updates);
            } else {
                // We no longer throw an error, just log it.
                // This prevents crashes if the frontend has a stale view of the portfolio.
                console.warn(`Position with symbol ${symbol} not found for update. It might have been sold.`);
            }
        });
    }

    async sell(symbol: string, amount: number, price: number, fullAnalysis: Record<string, unknown>): Promise<void> {
        await this.withPortfolio(async (portfolio) => {
            const positionIndex = portfolio.positions.findIndex(p => p.symbol === symbol);
            if (positionIndex === -1) {
                throw new Error('Position not found to sell.');
            }
            const position = portfolio.positions[positionIndex];

            if (position.amount < amount) {
                throw new Error('Insufficient position amount to sell.');
            }

            const revenue = amount * price;
            const fee = revenue * 0.001; // 0.1% fee
            const pnl = (price - position.entryPrice) * amount - fee;
            portfolio.balance += (revenue - fee);

            const tradeLog: Trade = {
                symbol,
                amount,
                entryPrice: position.entryPrice,
                exitPrice: price,
                pnl,
                timestamp: new Date().toISOString(),
                reason: (fullAnalysis.reason as string) || 'Unknown',
            };

            const { tradesLogFilePath } = this.getFilePaths();
            const tradeLogs = await this.getTradeLogs();
            tradeLogs.push(tradeLog);
            await fs.writeFile(tradesLogFilePath, JSON.stringify(tradeLogs, null, 2));

            portfolio.positions.splice(positionIndex, 1);
        });
    }

    async getTradeLogs(): Promise<Trade[]> {
        const { tradesLogFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(tradesLogFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return [];
        }
    }

    async getBuyLogs(): Promise<BuyLog[]> {
        const { buyLogFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(buyLogFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\lib\auth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import fs from 'fs/promises';
import path from 'path';
import bcrypt from 'bcryptjs';

const usersFilePath = path.join(process.cwd(), 'users.json');

async function getUsers() {
    try {
        const data = await fs.readFile(usersFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        return {};
    }
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials) {
            return null;
        }
        const users = await getUsers();
        const user = users[credentials.username];

        if (user && await bcrypt.compare(credentials.password, user.password)) {
          return { id: credentials.username, name: credentials.username };
        }
        return null;
      }
    })
  ],
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.name = user.name;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.name = token.name;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  }
};

--- END FILE: {relative_filepath} ---

--- FILE: src - Copy\lib\utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- END FILE: {relative_filepath} ---

