--- FILE: CODE EXPORT.py ---
import os

def export_project_code(output_filename="project_code_export.txt"):
    """
    Exports all relevant project code files into a single text file,
    excluding Next.js specific files and other non-code assets.
    """
    root_dir = os.getcwd()
    output_filepath = os.path.join(root_dir, output_filename)

    # Directories and files to exclude
    exclude_dirs = [
        ".git",
        ".next",
        "node_modules",
        "public",
        "__pycache__",
    ]
    exclude_files = [
        ".gitignore",
        "package.json",
        "package-lock.json",
        "tsconfig.json",
        "next.config.ts",
        "postcss.config.mjs",
        "eslint.config.mjs",
        "README.md",
        "bot_logs_admin.json",
        "bot-status.json",
        "buy_log_admin.json",
        "buy_log_demo.json",
        "buy_log.json",
        "decision_log_admin.json",
        "decision_log_demo.json",
        "decision_log.json",
        "missed_opportunities_admin.json",
        "missed_opportunities_demo.json",
        "missed_opportunities.json",
        "opportunities.json",
        "portfolio_admin.json",
        "portfolio_demo.json",
        "portfolio.json",
        "trades_log_admin.json",
        "trades_log_demo.json",
        "trades_log.json",
        "users.json",
        "config.json",
        output_filename, # Exclude the output file itself
        "export_project_code.py", # Exclude the script itself
    ]
    
    # File extensions to include (common code files)
    include_extensions = [
        ".ts", ".tsx", ".js", ".jsx", ".py", ".css", ".html", ".json" # Include .json for config/data files that are part of the project structure
    ]

    with open(output_filepath, "w", encoding="utf-8") as outfile:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude directories
            dirnames[:] = [d for d in dirnames if d not in exclude_dirs]

            for filename in filenames:
                if filename in exclude_files:
                    continue
                
                # Check if file extension is in the include list
                _, ext = os.path.splitext(filename)
                if ext not in include_extensions:
                    continue

                filepath = os.path.join(dirpath, filename)
                relative_filepath = os.path.relpath(filepath, root_dir)

                try:
                    with open(filepath, "r", encoding="utf-8") as infile:
                        content = infile.read()
                        outfile.write(f"--- FILE: {relative_filepath} ---\n")
                        outfile.write(content)
                        outfile.write("\n--- END FILE: {relative_filepath} ---\n\n")
                except Exception as e:
                    print(f"Could not read file {relative_filepath}: {e}")

    print(f"Project code exported to {output_filepath}")

if __name__ == "__main__":
    export_project_code()

--- END FILE: {relative_filepath} ---

--- FILE: next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

--- END FILE: {relative_filepath} ---

--- FILE: src\middleware.ts ---
export { default } from "next-auth/middleware"

export const config = { matcher: ["/dashboard/:path*"] }

--- END FILE: {relative_filepath} ---

--- FILE: src\app\globals.css ---
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\layout.tsx ---
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import { Toaster } from "react-hot-toast";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Crypto Bot",
  description: "The world's best crypto trading bot",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers>
          <Toaster position="top-right" />
          {children}
        </Providers>
      </body>
    </html>
  );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\page.tsx ---
import Image from "next/image";

export default function Home() {
  return (
    <div className="font-sans grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="font-mono list-inside list-decimal text-sm/6 text-center sm:text-left">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] font-mono font-semibold px-1 py-0.5 rounded">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\providers.tsx ---
"use client";

import { SessionProvider } from "next-auth/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\auth\register\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';
import bcrypt from 'bcryptjs';

const usersFilePath = path.join(process.cwd(), 'users.json');
const getPortfolioFilePath = (username: string) => path.join(process.cwd(), `portfolio_${username}.json`);

async function getUsers() {
    try {
        const data = await fs.readFile(usersFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        return {};
    }
}

export async function POST(req: Request) {
    try {
        const { username, password } = await req.json();

        if (!username || !password) {
            return NextResponse.json({ error: 'Username and password are required' }, { status: 400 });
        }

        const users = await getUsers();

        if (users[username]) {
            return NextResponse.json({ error: 'User already exists' }, { status: 409 });
        }

        const hashedPassword = await bcrypt.hash(password, 10);
        users[username] = { password: hashedPassword };

        await fs.writeFile(usersFilePath, JSON.stringify(users, null, 2));

        // Create a new portfolio for the user
        const portfolioFilePath = getPortfolioFilePath(username);
        const initialPortfolio = {
            balance: 100000,
            positions: [],
        };
        await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2));

        return NextResponse.json({ message: 'User registered successfully' }, { status: 201 });

    } catch (error) {
        console.error("Registration error:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\auth\[...nextauth]\route.ts ---
import NextAuth from "next-auth"
import { authOptions } from "@/lib/auth"

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST }

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\backtest\route.ts ---
// src/app/api/bot/backtest/route.ts

import { BinanceService } from '@/core/binance';
import { AgentService } from '@/core/agent-service';
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, Analysis } from '@/core/agents';
import { SharedContext } from '@/core/context';
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function POST(request: Request) {
    const { symbol, interval } = await request.json();

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const sendEvent = (data: object) => {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
            };

            sendEvent({ type: 'log', message: 'Backtest started...' });

            try {
                const binance = new BinanceService();
                
                // THE FIX IS HERE: Create AgentService and pass it to all agents
                const agentService = new AgentService();
                const macroAnalyst = new MacroAnalyst(agentService);
                const sentimentAnalyst = new SentimentAnalyst(agentService);
                const techAnalyst = new TechnicalAnalyst(agentService);
                const riskManager = new RiskManager(agentService);

                agentService.register(macroAnalyst);
                agentService.register(sentimentAnalyst);
                agentService.register(techAnalyst);
                agentService.register(riskManager);

                const configData = await fs.readFile(configFilePath, 'utf-8');
                const config = JSON.parse(configData);

                const historicalData = await binance.getHistoricalData(symbol, interval, 200); 

                if (historicalData.length === 0) {
                    sendEvent({ type: 'error', message: `Could not fetch historical data for ${symbol}.` });
                    controller.close();
                    return;
                }

                let positionOpen = false;

                for (let i = 20; i < historicalData.length; i++) { // Start with enough data for indicators
                    const currentCandle = historicalData[i];
                    const dataSlice = historicalData.slice(0, i + 1);
                    sendEvent({ type: 'log', message: `Analyzing data for ${new Date(currentCandle.time * 1000).toISOString()}` });

                    const dummyContext = new SharedContext();
                    const mockNews = ["Market is stable", "Bitcoin price holds steady"];
                    const mockFearAndGreed = { value: "50", classification: "Neutral" };
                    const mockGlobalMetrics = { btc_dominance: 50, quote: { USD: { total_market_cap: 2.5e12 } } };
                    const mockTrending = [{ name: "Bitcoin", symbol: "BTC" }];

                    const macroAnalysisResult = await macroAnalyst.analyze(currentCandle, mockNews, mockFearAndGreed, mockGlobalMetrics, dummyContext);
                    const sentimentAnalysisResult = await sentimentAnalyst.analyze(mockNews.map(title => ({title})), mockTrending, dummyContext);
                    const techAnalysisResult = await techAnalyst.analyzeBatch([{ symbol, candles: dataSlice }], config);

                    const macroAnalysis = macroAnalysisResult?.response;
                    const sentimentAnalysis = sentimentAnalysisResult?.response;
                    const techAnalyses = techAnalysisResult?.response || {};
                    const symbolTechAnalysis = (techAnalyses as any)[symbol];

                    const fullAnalysis: Analysis = {
                        [symbol]: symbolTechAnalysis,
                        MacroAnalyst: macroAnalysis,
                        SentimentAnalyst: sentimentAnalysis
                    };
                    
                    sendEvent({ type: 'analysis', data: fullAnalysis });
                    
                    const mockFundamentalData: Record<string, any> = { [symbol.replace('USDT', '')]: { tags: ['test'], description: 'Backtesting asset', urls: {} } };

                    const finalDecisionResult = await riskManager.decideBatch(techAnalyses, macroAnalysis, sentimentAnalysis, mockFundamentalData);
                    const finalDecisions = finalDecisionResult?.response as any;
                    const finalDecision = finalDecisions ? finalDecisions[symbol] : null;

                    sendEvent({ type: 'aiChat', data: { agent: 'RiskManager', ...finalDecisionResult } });

                    if (finalDecision?.decision === 'BUY' && !positionOpen) {
                        sendEvent({ type: 'trade', data: { date: new Date(currentCandle.time * 1000).toISOString(), action: 'BUY', price: currentCandle.close } });
                        positionOpen = true;
                    } else if (finalDecision?.decision === 'AVOID' && positionOpen) { // In a simple backtest, AVOID can act as a SELL signal
                        sendEvent({ type: 'trade', data: { date: new Date(currentCandle.time * 1000).toISOString(), action: 'SELL', price: currentCandle.close } });
                        positionOpen = false;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                sendEvent({ type: 'log', message: 'Backtest finished.' });
                controller.close();

            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                sendEvent({ type: 'error', message: errorMessage });
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\decision\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { NewsService } from '@/core/news'; // Import NewsService
import { CoinMarketCapService } from '@/core/coinmarketcap'; // Import CoinMarketCapService
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, Analysis, PositionManager } from '@/core/agents'; // Import MacroAnalyst, SentimentAnalyst, PositionManager
import { SharedContext } from '@/core/context';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext
import { OpportunityScanner } from '@/core/opportunity-scanner';
import { PortfolioService } from '@/core/portfolio'; // Import PortfolioService
import { DecisionLogger } from '@/core/decision-logger'; // Import DecisionLogger
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { symbol } = await req.json();
    if (!symbol) {
        return NextResponse.json({ error: 'Symbol is required' }, { status: 400 });
    }

    try {
        const opportunityScanner = OpportunityScanner.getInstance();
        await opportunityScanner.updateOpportunityStatus(symbol, 'analyzing');

        // Initialize services and agents
        const binance = new BinanceService();
        const newsService = new NewsService(); // Initialize NewsService
        const coinMarketCapService = new CoinMarketCapService(); // Initialize CoinMarketCapService
        const macroAnalyst = new MacroAnalyst(); // Initialize MacroAnalyst
        const sentimentAnalyst = new SentimentAnalyst(); // Initialize SentimentAnalyst
        const techAnalyst = new TechnicalAnalyst();
        const riskManager = new RiskManager();
        const positionManager = new PositionManager(); // Initialize PositionManager
        const portfolioService = new PortfolioService(session.user.name); // Initialize PortfolioService
        const decisionLogger = new DecisionLogger(session.user.name); // Initialize DecisionLogger
        // Use the global shared context
        const sharedContext = globalSharedContext;

        // Load config
        const configData = await fs.readFile(configFilePath, 'utf-8');
        const config = JSON.parse(configData);

        // Fetch necessary data for AI decision
        const candles = await binance.getHistoricalData(symbol, '5m', 100);
        if (candles.length === 0) {
            throw new Error(`Could not fetch historical data for ${symbol}`);
        }

        const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
        const newsArticles = await newsService.getCryptoNews();
        // Get Fear and Greed Index from global context
        const fearAndGreedIndex = sharedContext.getContext().fearAndGreedIndex;

        // Perform real macro and sentiment analysis
        const macroAnalysisResult = await macroAnalyst.analyze(
            btcData[0] || {},
            newsArticles.map(a => a.title),
            fearAndGreedIndex, // Pass directly from shared context
            sharedContext
        );
        const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, sharedContext);

        const macroAnalysis = macroAnalysisResult?.response;
        const sentimentAnalysis = sentimentAnalysisResult?.response;

        // Get current position details
        const portfolio = await portfolioService.getPortfolio();
        const position = portfolio.positions.find(p => p.symbol === symbol);

        if (!position) {
            throw new Error(`Position for ${symbol} not found in portfolio.`);
        }

        const currentPrice = await binance.getCurrentPrice(symbol);
        if (!currentPrice) {
            throw new Error(`Could not fetch current price for ${symbol}`);
        }

        // Invoke PositionManager for decision
        const decisionResult = await positionManager.decide(position, currentPrice, macroAnalysis, sentimentAnalysis, config, []);
        const decisionData = decisionResult?.response as { decision?: string; new_take_profit_percent?: number; justification?: string };

        if (decisionData?.decision) {
            await decisionLogger.log({
                symbol: position.symbol,
                decision: decisionData.decision as 'SELL_NOW' | 'HOLD_AND_INCREASE_TP',
                pnlPercent: (currentPrice - position.entryPrice) / position.entryPrice * 100,
                currentPrice,
                newTakeProfitPercent: decisionData.new_take_profit_percent,
                justification: decisionData.justification || 'N/A',
            });

            if (decisionData.decision === 'SELL_NOW') {
                await portfolioService.sell(position.symbol, position.amount, currentPrice, { reason: 'PositionManager decision' });
                await opportunityScanner.updateOpportunityStatus(symbol, 'sold'); // Update status if sold
                return NextResponse.json({ symbol, decision: 'SOLD', reason: decisionData.justification });
            } else if (decisionData.decision === 'HOLD_AND_INCREASE_TP' && decisionData.new_take_profit_percent) {
                await portfolioService.updatePosition(position.symbol, { takeProfitPercent: decisionData.new_take_profit_percent });
                await opportunityScanner.updateOpportunityStatus(symbol, 'held'); // Update status if held
                return NextResponse.json({ symbol, decision: 'HELD', new_tp: decisionData.new_take_profit_percent, reason: decisionData.justification });
            }
        }

        // Fallback if no decision or unexpected decision
        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
        return NextResponse.json({ symbol, decision: 'AVOID', reason: 'AI decision inconclusive or unexpected.' });

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`[Decision API] Error analyzing ${symbol}:`, errorMessage);
        // If analysis fails, mark as ignored to prevent retries
        const opportunityScanner = OpportunityScanner.getInstance();
        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\optimize\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';
import { StrategyOptimizer } from '@/core/optimizer';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';

export async function POST() {
    try {
        const session = await getServerSession(authOptions);
        if (!session || !session.user?.name) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        const username = session.user.name;

        const portfolioService = new PortfolioService(username);
        const opportunityLogger = new OpportunityLogger(username);
        const decisionLogger = new DecisionLogger(username);
        const optimizer = new StrategyOptimizer();

        const trades = await portfolioService.getTradeLogs();
        const missedOpportunities = await opportunityLogger.getLogs();
        const decisionLogs = await decisionLogger.getLogs();

        if (trades.length === 0 && missedOpportunities.length === 0 && decisionLogs.length === 0) {
            return NextResponse.json({ error: 'No data available to analyze.' }, { status: 400 });
        }

        const analysis = await optimizer.analyze(trades, missedOpportunities, decisionLogs);
        return NextResponse.json(analysis);

    } catch (error) {
        console.error("An error occurred during optimization:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\run\route.ts ---
// src/app/api/bot/run/route.ts

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService, Ticker } from '@/core/binance';
import { NewsService } from '@/core/news';
import { CoinMarketCapService } from '@/core/coinmarketcap';
import { PortfolioService } from '@/core/portfolio';
import { AgentService } from '@/core/agent-service';
import { MacroAnalyst, SentimentAnalyst, TechnicalAnalyst, RiskManager, PortfolioAllocator, PositionManager, DEX_ScoutAgent, MasterAgent, StrategyOptimizer } from '@/core/agents';
import { SharedContext, ISharedContext } from '@/core/context';
import fs from 'fs/promises';
import path from 'path';

export const dynamic = 'force-dynamic';

const statusFilePath = path.join(process.cwd(), 'bot-status.json');
const mainConfigPath = path.join(process.cwd(), 'config.json');

async function getBotStatus() {
    try {
        const data = await fs.readFile(statusFilePath, 'utf-8');
        return JSON.parse(data).status;
    } catch {
        return 'inactive';
    }
}

async function findCategoryId(cmcService: CoinMarketCapService, narrativeName: string): Promise<string | null> {
    if (!narrativeName) return null;
    const categories = await cmcService.getCategories();
    if (!categories) return null;
    const searchTerm = narrativeName.toLowerCase().split(' ')[0];
    const found = categories.find(cat => cat.name.toLowerCase().includes(searchTerm));
    return found ? found.id : null;
}

export async function GET(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return new Response(null, { status: 401 });
    }
    const username = session.user.name;

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const sendEvent = (data: object) => controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));

            const agentService = new AgentService();
            const binance = new BinanceService();
            const newsService = new NewsService();
            const coinMarketCapService = new CoinMarketCapService();
            
            agentService.register(new MacroAnalyst(agentService));
            agentService.register(new SentimentAnalyst(agentService));
            agentService.register(new TechnicalAnalyst(agentService));
            agentService.register(new RiskManager(agentService));
            agentService.register(new PortfolioAllocator(agentService));
            agentService.register(new PositionManager(agentService));
            agentService.register(new DEX_ScoutAgent(agentService));
            agentService.register(new StrategyOptimizer(agentService));
            agentService.register(new MasterAgent(agentService));

            const executeTradeCycle = async (config: any, portfolioService: PortfolioService, mode: 'main' | 'shadow') => {
                const prefix = `[${mode.toUpperCase()}]`;
                sendEvent({ type: 'log', message: `${prefix} Starting trade cycle...` });

                const sharedContext = new SharedContext();
                let portfolio = await portfolioService.getPortfolio();
                
                const macroAnalyst = agentService.getAgent('MacroAnalyst') as MacroAnalyst;
                const sentimentAnalyst = agentService.getAgent('SentimentAnalyst') as SentimentAnalyst;
                const techAnalyst = agentService.getAgent('TechnicalAnalyst') as TechnicalAnalyst;
                const riskManager = agentService.getAgent('RiskManager') as RiskManager;
                const portfolioAllocator = agentService.getAgent('PortfolioAllocator') as PortfolioAllocator;
                const positionManager = agentService.getAgent('PositionManager') as PositionManager;
                const dexScout = agentService.getAgent('DEX_ScoutAgent') as DEX_ScoutAgent;

                if (mode === 'main') {
                    for (const position of portfolio.positions) {
                        const currentPrice = await binance.getCurrentPrice(position.symbol);
                        if (!currentPrice) continue;

                        const pnlPercent = (currentPrice - position.entryPrice) * position.amount === 0 ? 0 : ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
                        const takeProfit = position.takeProfitPercent || config.takeProfitPercent;
                        const stopLoss = config.stopLossPercent;

                        if (pnlPercent <= stopLoss) {
                            await portfolioService.sell(position.symbol, position.amount, currentPrice, 'Automatic Stop Loss', sharedContext.getContext());
                            sendEvent({ type: 'log', message: `${prefix} SOLD ${position.symbol} due to Stop Loss.` });
                        } else if (pnlPercent >= takeProfit) {
                            sendEvent({ type: 'log', message: `${prefix} Position ${position.symbol} hit TAKE PROFIT. Invoking PositionManager...` });
                            const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
                            const newsArticles = await newsService.getCryptoNews();
                            const fearAndGreedIndex = await coinMarketCapService.getFearAndGreedIndex();
                            const globalMetrics = await coinMarketCapService.getGlobalMetrics();
                            const trendingTokens = await coinMarketCapService.getTrendingTokens();
                            
                            const tempMacroContext = new SharedContext();
                            const macroResult = await macroAnalyst.analyze(btcData[0] || {}, newsArticles.map(a => a.title), fearAndGreedIndex, globalMetrics, tempMacroContext);
                            const sentimentResult = await sentimentAnalyst.analyze(newsArticles, trendingTokens, tempMacroContext);
                    
                            const decisionResult = await positionManager.decide(position, currentPrice, macroResult?.response, sentimentResult?.response, config, []);
                            const decisionData = decisionResult?.response as { decision?: string; new_take_profit_percent?: number; justification?: string };

                            if (decisionData?.decision === 'SELL_NOW') {
                                await portfolioService.sell(position.symbol, position.amount, currentPrice, decisionData.justification || 'PositionManager decision', tempMacroContext.getContext());
                                sendEvent({ type: 'log', message: `${prefix} SOLD ${position.symbol} based on PositionManager decision.` });
                            } else if (decisionData?.decision === 'HOLD_AND_INCREASE_TP') {
                                await portfolioService.updatePosition(position.symbol, { takeProfitPercent: decisionData.new_take_profit_percent });
                                sendEvent({ type: 'log', message: `${prefix} HOLDING ${position.symbol}, new take-profit is ${decisionData.new_take_profit_percent}%.` });
                            }
                        }
                    }
                    portfolio = await portfolioService.getPortfolio();
                }

                if (portfolio.balance < (config.minimumBalance || 1000)) {
                    sendEvent({ type: 'log', message: `${prefix} Balance below minimum. Skipping new trades.` });
                    return;
                }

                if (config.enableDexHunting) {
                    sendEvent({ type: 'log', message: `${prefix} DEX Scout is hunting...`});
                    const latestDexPairs = await coinMarketCapService.getLatestDexPairs();
                    await dexScout.analyze(latestDexPairs || [], sharedContext);
                }

                let analysisCandidates: Partial<Ticker>[] = await binance.getTopSymbols();
                const uniqueSymbols = new Set(analysisCandidates.map(s => s.symbol));
                const addCandidate = (symbol: string) => {
                    const fullSymbol = symbol.endsWith('USDT') ? symbol : symbol + 'USDT';
                    if (!uniqueSymbols.has(fullSymbol)) {
                        analysisCandidates.push({ symbol: fullSymbol, quoteVolume: '0' });
                        uniqueSymbols.add(fullSymbol);
                    }
                };
                const gainersData = await coinMarketCapService.getTrendingGainersAndLosers();
                if (gainersData?.gainers) gainersData.gainers.forEach((g: any) => addCandidate(g.symbol));

                const btcData = await binance.getHistoricalData('BTCUSDT', '4h', 1);
                const newsArticles = await newsService.getCryptoNews();
                const fearAndGreedIndex = await coinMarketCapService.getFearAndGreedIndex();
                const globalMetrics = await coinMarketCapService.getGlobalMetrics();
                const trendingTokens = await coinMarketCapService.getTrendingTokens();
                
                const macroAnalysisResult = await macroAnalyst.analyze(btcData?.[0] || {}, newsArticles.map(a => a.title), fearAndGreedIndex, globalMetrics, sharedContext);
                const sentimentAnalysisResult = await sentimentAnalyst.analyze(newsArticles, trendingTokens, sharedContext);
                const macroAnalysis = macroAnalysisResult?.response;
                const sentimentAnalysis = sentimentAnalysisResult?.response;

                let narrativeContext;
                const currentContext = sharedContext.getContext();
                // @ts-ignore
                const dominantNarrative = currentContext.dominantNarrative;

                if (dominantNarrative && config.enableNarrativeTrading) {
                    const categoryId = await findCategoryId(coinMarketCapService, dominantNarrative);
                    if (categoryId) {
                        const categoryDetails = await coinMarketCapService.getCategoryById(categoryId);
                        const narrativeAssets = categoryDetails?.coins?.map((c: any) => c.symbol) || [];
                        if (narrativeAssets.length > 0) {
                            narrativeContext = { narrative: dominantNarrative, assets: narrativeAssets };
                            narrativeAssets.forEach((symbol: string) => addCandidate(symbol));
                        }
                    }
                }

                const macroScore = (macroAnalysis?.regime_score as number) || 0;
                if (macroScore < config.macroScoreThreshold) {
                    sendEvent({ type: 'log', message: `${prefix} Market is 'Risk-Off' (Score: ${macroScore}). Holding off.` });
                    return;
                }

                const symbolsToAnalyze = Array.from(uniqueSymbols).map(s => ({ symbol: s as string })).slice(0, config.symbolsToAnalyze);
                const BATCH_SIZE = config.batchSize;
                const batches = [];
                for (let i = 0; i < symbolsToAnalyze.length; i += BATCH_SIZE) {
                    batches.push(symbolsToAnalyze.slice(i, i + BATCH_SIZE));
                }

                const allBuySignals = (await Promise.all(batches.map(async (batch) => {
                    const batchData = (await Promise.all(batch.map(t => binance.getHistoricalData(t.symbol!, '5m', 100).then(c => ({ symbol: t.symbol!, candles: c }))))).filter(d => d.candles.length > 0);
                    if (batchData.length === 0) return [];
                    const techAnalyses = (await techAnalyst.analyzeBatch(batchData, config))?.response || {};
                    const infoSymbols = Object.keys(techAnalyses).map(s => s.replace('USDT', ''));
                    const fundamentalData = await coinMarketCapService.getCryptocurrencyInfo(infoSymbols) || {};
                    const finalDecisions = (await riskManager.decideBatch(techAnalyses, macroAnalysis, sentimentAnalysis, fundamentalData))?.response || {};
                    return Object.entries(finalDecisions).filter(([, d]) => (d as any).decision === 'BUY').map(([s, d]) => ({ symbol: s, ...(d as object) }));
                }))).flat();
                
                if (allBuySignals.length > 0) {
                    sendEvent({ type: 'log', message: `${prefix} Found ${allBuySignals.length} BUY signals. Allocating portfolio...` });
                    const allocationResult = await portfolioAllocator.allocate(allBuySignals, portfolio, macroAnalysis, sentimentAnalysis, sharedContext, narrativeContext, currentContext.dexOpportunities);
                    const allocations = allocationResult?.response || {};
                    for (const symbol in allocations) {
                        const alloc = allocations[symbol] as { decision?: string; amount_to_buy_usd?: number };
                        if (alloc.decision === 'EXECUTE_BUY' && (alloc.amount_to_buy_usd || 0) > 0) {
                            const price = await binance.getCurrentPrice(symbol);
                            if (price) {
                                const amount = alloc.amount_to_buy_usd! / price;
                                await portfolioService.buy(symbol, amount, price);
                                sendEvent({ type: 'log', message: `${prefix} BOUGHT ${amount.toFixed(5)} ${symbol}` });
                            }
                        }
                    }
                } else {
                    sendEvent({ type: 'log', message: `${prefix} No strong BUY signals found.` });
                }
                sendEvent({ type: 'log', message: `${prefix} Trade cycle finished.` });
            };

            // Main Execution Block
            try {
                sendEvent({ type: 'log', message: 'Cycle starting...' });
                const status = await getBotStatus();
                if (status !== 'active') {
                    sendEvent({ type: 'log', message: 'Bot is not active. Halting.' });
                    controller.close(); return;
                }

                const mainConfigData = await fs.readFile(mainConfigPath, 'utf-8');
                const mainConfig = JSON.parse(mainConfigData);
                const mainPortfolioService = new PortfolioService(username, 'main');
                await executeTradeCycle(mainConfig, mainPortfolioService, 'main');
                
                let shadowPortfolio = null;
                const shadowConfigPath = path.join(process.cwd(), `shadow_config_${username}.json`);
                try {
                    const shadowConfigData = await fs.readFile(shadowConfigPath, 'utf-8');
                    const shadowConfig = JSON.parse(shadowConfigData);
                    if (mainConfig.enableAutoImprovement) {
                        sendEvent({ type: 'log', message: '--- Running Shadow Mode Cycle ---' });
                        const shadowPortfolioService = new PortfolioService(username, 'shadow');
                        await executeTradeCycle(shadowConfig, shadowPortfolioService, 'shadow');
                        shadowPortfolio = await shadowPortfolioService.getPortfolio();
                    }
                } catch (e) {
                    sendEvent({ type: 'log', message: 'No active shadow config. MasterAgent will check if a new one should be generated.' });
                }

                if (mainConfig.enableAutoImprovement) {
                    sendEvent({ type: 'log', message: '--- Master Agent is reviewing performance ---' });
                    const masterAgent = agentService.getAgent('MasterAgent') as MasterAgent;
                    const finalMainPortfolio = await mainPortfolioService.getPortfolio();
                    await masterAgent.manageOptimizationCycle(finalMainPortfolio, shadowPortfolio, mainConfig, username);
                }

                sendEvent({ type: 'log', message: 'Full cycle finished.' });
                controller.close();
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
                sendEvent({ type: 'error', message: errorMessage });
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' },
    });
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\bot\status\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const statusFilePath = path.join(process.cwd(), 'bot-status.json');

async function getBotStatus() {
    try {
        const data = await fs.readFile(statusFilePath, 'utf-8');
        return JSON.parse(data).status;
    } catch {
        return 'inactive';
    }
}

async function setBotStatus(status: 'active' | 'inactive') {
    await fs.writeFile(statusFilePath, JSON.stringify({ status }));
}

export async function GET() {
    const status = await getBotStatus();
    return NextResponse.json({ status });
}

export async function POST(request: Request) {
    const { status } = await request.json();
    if (status === 'active' || status === 'inactive') {
        await setBotStatus(status);
        return NextResponse.json({ status });
    }
    return NextResponse.json({ error: 'Invalid status' }, { status: 400 });
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\chart-data\route.ts ---
// src/app/api/chart-data/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { BinanceService } from '@/core/binance';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const symbol = searchParams.get('symbol');

    if (!symbol) {
        return NextResponse.json({ error: 'Symbol parameter is required' }, { status: 400 });
    }

    try {
        const binanceService = new BinanceService();
        // Fetching 1-day interval data for a broader view
        const candles = await binanceService.getHistoricalData(symbol, '1d', 365); 
        
        // Ensure that we only proceed if candles is an array with data
        if (!Array.isArray(candles) || candles.length === 0) {
            return NextResponse.json({ error: `No historical data found for symbol: ${symbol}` }, { status: 404 });
        }
        
        const formattedData = candles.map(c => ({
            time: c.time,
            open: c.open,
            high: c.high,
            low: c.low,
            close: c.close,
        }));

        return NextResponse.json(formattedData);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error fetching chart data for ${symbol}: ${errorMessage}`);
        // Ensure a proper JSON error response is always sent on failure
        return NextResponse.json({ error: `Failed to fetch data from Binance API: ${errorMessage}` }, { status: 500 });
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\dashboard-data\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { BinanceService } from '@/core/binance';
import { PortfolioService } from '@/core/portfolio';
import { CoinMarketCapService } from '@/core/coinmarketcap';
import { globalSharedContext } from '@/core/global-context'; // Import globalSharedContext

export const dynamic = 'force-dynamic';

export async function GET() {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        console.error("[DashboardData API] Unauthorized access attempt: No session or username.");
        return NextResponse.json({ error: 'Unauthorized: Please log in.' }, { status: 401 });
    }

    try {
        const username = session.user.name;
        const binance = new BinanceService();
        const portfolioService = new PortfolioService(username);
        // const coinMarketCapService = new CoinMarketCapService(); // No longer needed here

        const topSymbols = await binance.getTopSymbols(50);
        const portfolio = await portfolioService.getPortfolio();
        // Get Fear and Greed Index from global context
        const fearAndGreedIndex = globalSharedContext.getContext().fearAndGreedIndex;

        console.log('[DashboardData API] Fear and Greed Index:', fearAndGreedIndex);

        const marketDataSymbols = new Set(topSymbols.map(s => s.symbol));
        const combinedMarketData = [...topSymbols];

        for (const position of portfolio.positions) {
            if (!marketDataSymbols.has(position.symbol)) {
                const currentPrice = await binance.getCurrentPrice(position.symbol);
                if (currentPrice !== null) {
                    // Create a Ticker object with available data and dummy values for others
                    combinedMarketData.push({
                        symbol: position.symbol,
                        lastPrice: currentPrice.toString(),
                        priceChange: '0', // Dummy
                        priceChangePercent: '0', // Dummy
                        weightedAvgPrice: '0', // Dummy
                        prevClosePrice: '0', // Dummy
                        lastQty: '0', // Dummy
                        bidPrice: '0', // Dummy
                        bidQty: '0', // Dummy
                        askPrice: '0', // Dummy
                        askQty: '0', // Dummy
                        openPrice: '0', // Dummy
                        highPrice: '0', // Dummy
                        lowPrice: '0', // Dummy
                        volume: '0', // Dummy
                        quoteVolume: '0', // Dummy
                        openTime: 0, // Dummy
                        closeTime: 0, // Dummy
                        firstId: 0, // Dummy
                        lastId: 0, // Dummy
                        count: 0, // Dummy
                    });
                    marketDataSymbols.add(position.symbol); // Add to set to avoid duplicates
                } else {
                    console.warn(`[DashboardData API] Could not fetch current price for portfolio symbol: ${position.symbol}`);
                }
            }
        }

        // console.log('[DashboardData API] Sending marketData to frontend:', combinedMarketData.map(d => d.symbol));
        return NextResponse.json({ marketData: combinedMarketData, portfolio, fearAndGreedIndex });

    } catch (error) {
        console.error("[DashboardData API] Error fetching dashboard data:", error);
        return NextResponse.json({ error: `Internal Server Error: ${(error as Error).message}` }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\decisions\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

// Define the interface for consistency with other parts of the app
interface DecisionLog {
    [symbol: string]: {
        timestamp: string;
        decision: string;
        justification: string;
        pnlPercent: number;
        currentPrice: number;
    }[];
}

const decisionLogPath = path.join(process.cwd(), 'decision_log.json');

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const data = await fs.readFile(decisionLogPath, 'utf-8');
        const decisionLog: DecisionLog = JSON.parse(data);
        return NextResponse.json(decisionLog);
    } catch (error) {
        // Check if the error is a file system error for a missing file
        if (error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === 'ENOENT') {
            return NextResponse.json({}); // Return empty object if file doesn't exist
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error fetching decision log: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\history\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';

export async function GET() {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const portfolioService = new PortfolioService(username);
        const tradeLogs = await portfolioService.getTradeLogs();
        return NextResponse.json(tradeLogs);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Error fetching trade history:", errorMessage);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\intel-data\route.ts ---
// src/app/api/intel-data/route.ts

import { NextResponse } from 'next/server';
import { CoinMarketCapService } from '@/core/coinmarketcap';

export const dynamic = 'force-dynamic'; // Ensure the response is not cached

export async function GET() {
    try {
        const cmc = new CoinMarketCapService();

        // Fetch all data points in parallel for efficiency
        const [
            globalMetrics,
            topNarratives,
            airdrops,
            gainersLosers,
            trendingTokens
        ] = await Promise.all([
            cmc.getGlobalMetrics(),
            cmc.getCategories(),
            cmc.getAirdrops(),
            cmc.getTrendingGainersAndLosers(),
            cmc.getTrendingTokens()
        ]);

        const intelData = {
            globalMetrics: globalMetrics?.quote?.USD,
            topNarratives,
            catalystCalendar: airdrops,
            dailyMovers: {
                gainers: gainersLosers?.gainers,
                losers: gainersLosers?.losers,
            },
            communityPulse: {
                trendingTokens,
            },
        };

        return NextResponse.json(intelData);

    } catch (error) {
        console.error("[Intel-Data API] Error fetching market intelligence data:", error);
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
        return NextResponse.json({ error: `Internal Server Error: ${errorMessage}` }, { status: 500 });
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\market-stream\route.ts ---
// src/app/api/market-stream/route.ts

import WebSocket from 'ws';
import { OpportunityScanner } from '@/core/opportunity-scanner';
import { BinanceService } from '@/core/binance';
import { TechnicalAnalyst, RiskManager, PortfolioAllocator, Analysis } from '@/core/agents'; // Import 'Analysis'
import { SharedContext } from '@/core/context';
import { OpportunityLogger } from '@/core/opportunity-logger';
import { DecisionLogger } from '@/core/decision-logger';
import { PortfolioService } from '@/core/portfolio';
import fs from 'fs/promises';
import path from 'path';

const DEFAULT_USERNAME = 'admin'; // Assume a default username for now

let ws: WebSocket | null = null;
const trackedSymbols: { [symbol: string]: { price: number; time: number } } = {};

const configFilePath = path.join(process.cwd(), 'config.json');
// *** PATAISYMAS: Pridėtas kelias į talpyklos failą ***
const contextCachePath = path.join(process.cwd(), 'market_context_cache.json');

async function getConfig() {
    try {
        const data = await fs.readFile(configFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        console.error("Failed to read config.json:", error);
        return {
            fastMoverTimeMinutes: 5,
            fastMoverPriceChangePercent: 5.0
        };
    }
}

async function connectAndStream(controller: ReadableStreamDefaultController<Uint8Array>) {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        console.log('[MarketStream] WebSocket is already connected.');
        return;
    }

    const config = await getConfig();
    const FAST_MOVER_TIME_MS = (config.fastMoverTimeMinutes || 5) * 60 * 1000;
    const FAST_MOVER_PRICE_CHANGE_PERCENT = config.fastMoverPriceChangePercent || 5.0;

    console.log('[MarketStream] Connecting to Binance WebSocket for client stream...');
    ws = new WebSocket('wss://stream.binance.com:9443/ws/!ticker@arr');
    const encoder = new TextEncoder();

    ws.on('open', () => {
        console.log('[MarketStream] Client stream connection established.');
    });

    ws.on('message', async (data: WebSocket.Data) => {
        const tickers = JSON.parse(data.toString());
        const opportunityScanner = OpportunityScanner.getInstance();
        const opportunityLogger = new OpportunityLogger(DEFAULT_USERNAME);
        
        if (controller.desiredSize !== null && controller.desiredSize > 0) {
            controller.enqueue(encoder.encode(`data: ${JSON.stringify(tickers)}\n\n`));
        } else {
            console.warn('[MarketStream] Controller is closed or full, cannot enqueue data.');
        }

        for (const ticker of tickers) {
            const symbol = ticker.s;
            const price = parseFloat(ticker.c);
            const now = Date.now();

            if (!trackedSymbols[symbol]) {
                trackedSymbols[symbol] = { price, time: now };
                continue;
            }

            const initialData = trackedSymbols[symbol];
            if (now - initialData.time > FAST_MOVER_TIME_MS) {
                trackedSymbols[symbol] = { price, time: now };
            } else {
                const priceChangePercent = ((price - initialData.price) / initialData.price) * 100;
                if (priceChangePercent > FAST_MOVER_PRICE_CHANGE_PERCENT) {
                    console.log(`[MarketStream] OPPORTUNITY DETECTED: ${symbol} increased by ${priceChangePercent.toFixed(2)}%`);
                    await opportunityScanner.addOpportunity({ symbol, priceChangePercent });
                    trackedSymbols[symbol] = { price, time: now };

                    console.log(`[MarketStream] Triggering AI analysis for fast mover: ${symbol}`);
                    try {
                        const binanceService = new BinanceService();
                        const technicalAnalyst = new TechnicalAnalyst();
                        const riskManager = new RiskManager();
                        const portfolioAllocator = new PortfolioAllocator();
                        const decisionLogger = new DecisionLogger(DEFAULT_USERNAME);
                        const portfolioService = new PortfolioService(DEFAULT_USERNAME);
                        const sharedContext = new SharedContext();

                        const candles = await binanceService.getHistoricalData(symbol, '1m', 100);
                        if (candles.length === 0) {
                            console.warn(`[MarketStream] No historical data for ${symbol}, skipping AI analysis.`);
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            continue;
                        }

                        const techAnalysisResult = await technicalAnalyst.analyze(symbol, candles, config);
                        if (!techAnalysisResult?.response) {
                            console.warn(`[MarketStream] Technical analysis failed for ${symbol}, skipping AI analysis.`);
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            continue;
                        }

                        // *** PATAISYMAS: Įkeliame tikrus makro ir sentimento duomenis iš talpyklos ***
                        let macroAnalysis, sentimentAnalysis;
                        try {
                            const cacheData = await fs.readFile(contextCachePath, 'utf-8');
                            const cachedContext = JSON.parse(cacheData);
                            macroAnalysis = cachedContext.macroAnalysis;
                            sentimentAnalysis = cachedContext.sentimentAnalysis;
                            console.log(`[MarketStream] Successfully loaded cached market context for ${symbol}.`);
                        } catch (error) {
                            console.warn(`[MarketStream] Could not load cached market context for ${symbol}. Falling back to neutral defaults.`);
                            macroAnalysis = { market_regime: 'Neutral', regime_score: 5.0, summary: 'Cache not available' };
                            sentimentAnalysis = { sentiment: 'Neutral', sentiment_score: 0.0, dominant_narrative: 'Cache not available' };
                        }
                        // *** PATAISYMO PABAIGA ***
                        
                        // Sudarome analizės objektą su tikrais (arba numatytais) duomenimis
                        const analysisForRiskManager: Analysis = {
                            MacroAnalyst: macroAnalysis,
                            SentimentAnalyst: sentimentAnalysis,
                            [symbol]: {
                                technicalAnalysis: techAnalysisResult.response,
                            }
                        };
                        
                        // Perduodame tikrus duomenis
                        const decisionResult = await riskManager.decideBatch(
                            [analysisForRiskManager],
                            macroAnalysis,
                            sentimentAnalysis
                        );
                        
                        // Tolesnė logika lieka tokia pati...
                        if (decisionResult && decisionResult.response && typeof decisionResult.response === 'object') {
                            const decisionForSymbol = (decisionResult.response as Record<string, unknown>)[symbol];
                            if (decisionForSymbol && typeof decisionForSymbol === 'object') {
                                const decision = (decisionForSymbol as { decision: string }).decision;
                                console.log(`[MarketStream] AI Decision for ${symbol}:`, decisionForSymbol);

                                if (decision === 'BUY') {
                                    const buySignals = [{ symbol, price, analysis: techAnalysisResult.response }];
                                    const allocationResult = await portfolioAllocator.allocate(buySignals, await portfolioService.getPortfolio(), macroAnalysis, sentimentAnalysis, sharedContext);

                                    const allocationResponse = allocationResult?.response as Record<string, { decision?: string, amount_to_buy_usd?: number, justification?: string }>;

                                    if (allocationResponse && allocationResponse[symbol]?.decision === 'EXECUTE_BUY' && allocationResponse[symbol].amount_to_buy_usd! > 0) {
                                        const amountToBuyUsd = allocationResponse[symbol].amount_to_buy_usd!;
                                        const amountToBuy = amountToBuyUsd / price;
                                        await portfolioService.buy(symbol, amountToBuy, price);
                                        await opportunityScanner.updateOpportunityStatus(symbol, 'bought');
                                        await decisionLogger.log({
                                            symbol,
                                            decision: 'BUY',
                                            currentPrice: price,
                                            amount: amountToBuy,
                                            reason: allocationResponse[symbol].justification || 'Fast Mover Buy'
                                        });
                                        console.log(`[MarketStream] Successfully bought ${amountToBuy} of ${symbol}`);
                                    } else {
                                        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                        await opportunityLogger.log({
                                            symbol,
                                            priceChangePercent,
                                            reason: 'AI decided to BUY but allocation failed or was zero.'
                                        });
                                        console.warn(`[MarketStream] AI decided to BUY ${symbol}, but allocation was zero or failed.`);
                                    }
                                } else {
                                    await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                    await opportunityLogger.log({
                                        symbol,
                                        priceChangePercent,
                                        reason: (decisionForSymbol as { final_summary?: string; reason?: string }).final_summary || (decisionForSymbol as { final_summary?: string; reason?: string }).reason || `AI decided to ${decision}`
                                    });
                                    console.log(`[MarketStream] AI decided to ${decision} ${symbol}.`);
                                }
                            } else {
                                await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                                await opportunityLogger.log({
                                    symbol,
                                    priceChangePercent,
                                    reason: 'AI decision for symbol not found in batch response.'
                                });
                                console.warn(`[MarketStream] AI decision for ${symbol} not found in batch response.`);
                            }
                        } else {
                            await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                            await opportunityLogger.log({
                                symbol,
                                priceChangePercent,
                                reason: 'AI decision process failed or returned no decision.'
                            });
                            console.warn(`[MarketStream] AI decision process failed for ${symbol}.`);
                        }

                    } catch (aiError) {
                        console.error(`[MarketStream] Error during AI analysis for ${symbol}:`, aiError);
                        await opportunityScanner.updateOpportunityStatus(symbol, 'ignored');
                        await opportunityLogger.log({
                            symbol,
                            priceChangePercent,
                            reason: `Error during AI analysis: ${(aiError as Error).message}`
                        });
                    }
                }
            }
        }
    });

    ws.on('close', () => {
        console.log('[MarketStream] Client stream closed.');
        ws = null;
        try {
            controller.close();
        } catch (e) {
            // Controller might already be closed
        }
    });

    ws.on('error', (error: unknown) => {
        console.error('[MarketStream] Client stream error:', error);
        try {
            controller.error(error);
            ws?.close();
        } catch (e) {
            // Controller might already be closed
        }
    });
}

export async function GET(req: Request) {
    const stream = new ReadableStream({
        start(controller) {
            connectAndStream(controller);
        },
        cancel() {
            console.log('[MarketStream] Client disconnected, closing WebSocket.');
            ws?.close();
            ws = null;
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\missed-opportunities\route.ts ---
// src/app/api/missed-opportunities/route.ts
import { NextResponse } from 'next/server';
import { OpportunityLogger } from '@/core/opportunity-logger';

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const opportunityLogger = new OpportunityLogger();
        const logs = await opportunityLogger.getLogs();
        return NextResponse.json(logs);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Failed to fetch missed opportunities:", errorMessage);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\news\route.ts ---
import { NextResponse } from 'next/server';
import { NewsService } from '@/core/news';

export async function GET() {
    try {
        const newsService = new NewsService();
        const articles = await newsService.getCryptoNews('crypto', 20);
        return NextResponse.json({ articles });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\opportunities\route.ts ---
import { NextResponse } from 'next/server';
import { OpportunityScanner } from '@/core/opportunity-scanner';

export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
    try {
        const scanner = OpportunityScanner.getInstance();
        const opportunities = scanner.getOpportunities();
        return NextResponse.json(opportunities);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\portfolio\sell\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';
import { BinanceService } from '@/core/binance';

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const { symbol, amount } = await req.json();
        if (!symbol || !amount) {
            return NextResponse.json({ error: 'Symbol and amount are required' }, { status: 400 });
        }

        const portfolioService = new PortfolioService(username);
        const binanceService = new BinanceService();

        const currentPrice = await binanceService.getCurrentPrice(symbol);
        if (!currentPrice) {
            return NextResponse.json({ error: 'Could not fetch current price' }, { status: 500 });
        }

        await portfolioService.sell(symbol, amount, currentPrice, { reason: 'Manual sell' });

        const updatedPortfolio = await portfolioService.getPortfolio();
        return NextResponse.json(updatedPortfolio);

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error in sell API: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\portfolio\update\route.ts ---
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { PortfolioService } from '@/core/portfolio';

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.name) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const username = session.user.name;

    try {
        const { symbol, updates } = await req.json();
        if (!symbol || !updates) {
            return NextResponse.json({ error: 'Symbol and updates are required' }, { status: 400 });
        }

        const portfolioService = new PortfolioService(username);
        await portfolioService.updatePosition(symbol, updates);

        return NextResponse.json({ success: true });

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Error in update API: ${errorMessage}`);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\reset-logs\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const logFiles = [
    'bot_logs.json',
    'buy_log.json',
    'decision_log.json',
    'missed_opportunities.json',
    'trades_log.json',
];

const initialPortfolio = { balance: 100000, positions: [] };

export async function POST(request: Request) {
    try {
        // Get username from request (assuming it's passed in the body or headers)
        // For now, I'll assume a default or extract from a common source if available.
        // Based on portfolio.ts, the log files are username-specific.
        // I need to ensure the reset targets the correct user's files.
        // For simplicity, I'll assume the request body will contain the username.
        // If not, I'll need to ask the user how the username is passed.
        const { username } = await request.json();

        if (!username) {
            return NextResponse.json({ error: 'Username is required for resetting logs.' }, { status: 400 });
        }

        // Clear log files
        for (const file of logFiles) {
            const filePath = path.join(process.cwd(), file.replace('.json', `_${username}.json`));
            try {
                await fs.writeFile(filePath, '[]', 'utf-8');
            } catch (error) {
                if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
                    console.warn(`Log file not found, creating: ${filePath}`);
                    await fs.writeFile(filePath, '[]', 'utf-8');
                } else {
                    console.error(`Failed to clear log file ${filePath}:`, error);
                    throw error;
                }
            }
        }

        // Reset portfolio.json
        const portfolioFilePath = path.join(process.cwd(), `portfolio_${username}.json`);
        try {
            await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2), 'utf-8');
        } catch (error) {
            if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
                console.warn(`Portfolio file not found, creating: ${portfolioFilePath}`);
                await fs.writeFile(portfolioFilePath, JSON.stringify(initialPortfolio, null, 2), 'utf-8');
            } else {
                console.error(`Failed to reset portfolio file ${portfolioFilePath}:`, error);
                throw error;
            }
        }

        return NextResponse.json({ message: 'All logs and portfolio reset successfully.' });
    } catch (error) {
        console.error('Error resetting logs:', error);
        return NextResponse.json({ error: 'Failed to reset logs.' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\api\settings\route.ts ---
import { NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';

const configFilePath = path.join(process.cwd(), 'config.json');

export async function GET() {
    try {
        const data = await fs.readFile(configFilePath, 'utf-8');
        return NextResponse.json(JSON.parse(data));
    } catch {
        return NextResponse.json({ error: 'Failed to read settings' }, { status: 500 });
    }
}

export async function POST(request: Request) {
    try {
        const settings = await request.json();
        await fs.writeFile(configFilePath, JSON.stringify(settings, null, 2));
        return NextResponse.json({ message: 'Settings saved' });
    } catch {
        return NextResponse.json({ error: 'Failed to save settings' }, { status: 500 });
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\auth\signin\page.tsx ---
"use client";

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';

export default function SignInPage() {
    const [isRegister, setIsRegister] = useState(false);
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const router = useRouter();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setIsLoading(true);

        if (isRegister) {
            try {
                const res = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password }),
                });

                if (res.ok) {
                    toast.success('Registration successful! Please sign in.');
                    setIsRegister(false);
                } else {
                    const data = await res.json();
                    toast.error(data.error || 'Registration failed.');
                }
            } catch (error) {
                toast.error('An error occurred during registration.');
            }
        } else {
            const result = await signIn('credentials', {
                redirect: false,
                username,
                password,
            });

            if (result?.ok) {
                router.push('/dashboard');
            } else {
                toast.error(result?.error || 'Invalid credentials.');
            }
        }
        setIsLoading(false);
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-lg shadow-lg">
                <h1 className="text-2xl font-bold text-center">
                    {isRegister ? 'Register' : 'Sign In'}
                </h1>
                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label className="block text-sm font-medium">Username</label>
                        <input
                            type="text"
                            value={username}
                            onChange={(e) => setUsername(e.target.value)}
                            className="w-full px-3 py-2 mt-1 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring focus:ring-indigo-500"
                            required
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium">Password</label>
                        <input
                            type="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            className="w-full px-3 py-2 mt-1 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring focus:ring-indigo-500"
                            required
                        />
                    </div>
                    <button
                        type="submit"
                        disabled={isLoading}
                        className="w-full py-2 font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:opacity-50"
                    >
                        {isLoading ? 'Loading...' : (isRegister ? 'Register' : 'Sign In')}
                    </button>
                </form>
                <p className="text-sm text-center">
                    {isRegister ? 'Already have an account?' : "Don't have an account?"}
                    <button onClick={() => setIsRegister(!isRegister)} className="ml-1 font-semibold text-indigo-400 hover:underline">
                        {isRegister ? 'Sign In' : 'Register'}
                    </button>
                </p>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\layout.tsx ---
"use client";

import { useState } from 'react';
import { Sidebar } from '@/components/sidebar';
import { Header } from '@/components/header';
import { DashboardProvider } from '@/context/DashboardContext';

export default function DashboardLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const [sidebarOpen, setSidebarOpen] = useState(false);

    return (
        <DashboardProvider>
            <div className="flex h-screen bg-gray-800">
                <Sidebar sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
                <div className="flex-1 flex flex-col overflow-hidden">
                    <Header setSidebarOpen={setSidebarOpen} />
                    <main className="flex-1 p-4 md:p-8 overflow-y-auto">
                        {children}
                    </main>
                </div>
            </div>
        </DashboardProvider>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\page.tsx ---
// src/app/dashboard/page.tsx

"use client";

import { useDashboard } from '@/context/DashboardContext';
import { MarketTable } from '@/components/market-table';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel } from '@/components/analysis-panel';
import { AiChatWindow } from '@/components/ai-chat-window';
import { NewsFeed } from '@/components/news-feed';
import { Chart } from '@/components/chart';
import { DecisionLog } from '@/components/decision-log';
import { HiveMindDisplay } from '@/components/HiveMindDisplay';
import { DynamicRiskDisplay } from '@/components/dynamic-risk-display';
import { OpportunityLog } from '@/components/opportunity-log';
import { DollarSign, TrendingUp, Wallet } from 'lucide-react';
import { ActivityFeed } from '@/components/ActivityFeed'; // 1. IMPORTUOTI NAUJĄ KOMPONENTĄ

export default function Dashboard() {
    const { state } = useDashboard();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            {/* Row 1: KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <KpiCard title="Total Value" kpiKey="totalValue" icon={<Wallet size={24} />} />
                <KpiCard title="24h P/L" kpiKey="24h_pnl" icon={<TrendingUp size={24} />} />
                <KpiCard title="Free Collateral" kpiKey="freeCollateral" icon={<DollarSign size={24} />} />
            </div>

            {/* Row 2: Hive Mind & Risk Context */}
            <div className="space-y-6">
                <HiveMindDisplay /> 
                <DynamicRiskDisplay />
            </div>

            {/* Row 3: Main Grid */}
            <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                {/* Main Content Column */}
                <div className="xl:col-span-2 space-y-6">
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h2 className="text-lg font-semibold mb-4">{state.selectedSymbol} Price Chart</h2>
                        <Chart />
                    </div>
                    <div>
                        <h2 className="text-lg font-semibold mb-4">AI Analysis Cycle: Latest Buys</h2>
                        <AnalysisPanel />
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <AiChatWindow />
                    </div>
                    <DecisionLog />
                </div>

                {/* Side Column */}
                <div className="xl:col-span-1 space-y-6">
                    <MarketTable />
                    
                    {/* 2. PAKEISTI SENĄ "LIVE LOGS" BLOKĄ NAUJU KOMPONENTU */}
                    <ActivityFeed />
                    
                    <NewsFeed />
                    <OpportunityLog />
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\backtest\page.tsx ---
"use client";

import { useState, useEffect } from 'react';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel, Analysis } from '@/components/analysis-panel'; // Assuming this can be reused

// Define interfaces for our state
interface Trade {
    date: string;
    action: 'BUY' | 'SELL';
    price: number;
}

export default function BacktestPage() {
    const [symbol, setSymbol] = useState('BTCUSDT');
    const [startDate, setStartDate] = useState('2023-01-01');
    const [endDate, setEndDate] = useState('2023-01-31');
    const [interval, setInterval] = useState('1h');
    const [isLoading, setIsLoading] = useState(false);
    
    const [logs, setLogs] = useState<string[]>([]);
    const [trades, setTrades] = useState<Trade[]>([]);
    const [currentAnalysis, setCurrentAnalysis] = useState<Analysis | null>(null);
    const [pnl, setPnl] = useState(0);

    const runBacktest = async () => {
        setIsLoading(true);
        setLogs([]);
        setTrades([]);
        setCurrentAnalysis(null);
        setPnl(0);

        const response = await fetch('/api/bot/backtest', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ symbol, startDate, endDate, interval }),
        });

        if (!response.body) return;
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                setIsLoading(false);
                break;
            }
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
            
            for (const line of lines) {
                const json = JSON.parse(line.replace('data: ', ''));
                if (json.type === 'log') {
                    setLogs(prev => [...prev, json.message]);
                } else if (json.type === 'analysis') {
                    setCurrentAnalysis(json.data);
                } else if (json.type === 'trade') {
                    setTrades(prev => [...prev, json.data]);
                }
            }
        }
    };
    
    useEffect(() => {
        let calculatedPnl = 0;
        for (let i = 0; i < trades.length; i += 2) {
            if (trades[i+1]) {
                calculatedPnl += trades[i+1].price - trades[i].price;
            }
        }
        setPnl(calculatedPnl);
    }, [trades]);

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Strategy Backtesting</h1>
            
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Symbol</label>
                        <input type="text" value={symbol} onChange={(e) => setSymbol(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Start Date</label>
                        <input type="date" value={startDate} onChange={(e) => setStartDate(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">End Date</label>
                        <input type="date" value={endDate} onChange={(e) => setEndDate(e.target.value)} className="bg-gray-700 rounded p-2 w-full" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300">Interval</label>
                        <select value={interval} onChange={(e) => setInterval(e.target.value)} className="bg-gray-700 rounded p-2 w-full">
                            <option value="1m">1m</option>
                            <option value="5m">5m</option>
                            <option value="15m">15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                        </select>
                    </div>
                    <button onClick={runBacktest} disabled={isLoading} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full">
                        {isLoading ? 'Running...' : 'Run Backtest'}
                    </button>
                </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-2">
                    {currentAnalysis ? <AnalysisPanel analysis={currentAnalysis} /> : <div className="bg-gray-800 p-4 rounded-lg h-full"><h2 className="font-bold text-lg">AI Analysis</h2><p>Waiting for data...</p></div>}
                </div>
                <div className="lg:col-span-1">
                    <div className="bg-gray-800 p-4 rounded-lg mb-4">
                        <h2 className="text-xl font-bold mb-4">Backtest Results</h2>
                        <div className="grid grid-cols-3 gap-4">
                            <KpiCard title="Initial Balance" value={`€10000.00`} icon={<div />} />
                            <KpiCard title="Total P/L" value={`€${pnl.toFixed(2)}`} color={pnl > 0 ? 'text-green-400' : 'text-red-400'} icon={<div />} />
                            <KpiCard title="Total Trades" value={trades.length} icon={<div />} />
                        </div>
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h3 className="font-bold mb-2">Live Trades</h3>
                        <div className="h-48 overflow-y-auto">
                            {trades.map((trade, index) => (
                                <div key={index} className={`p-2 rounded mb-2 text-sm ${trade.action === 'BUY' ? 'bg-green-900' : 'bg-red-900'}`}>
                                    {trade.date}: {trade.action} @ {trade.price.toFixed(2)}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="mt-8 bg-gray-800 text-white p-4 rounded-lg h-[30vh] overflow-y-auto">
                <h2 className="font-bold text-lg mb-2">Live Logs</h2>
                <pre className="text-sm overflow-x-auto whitespace-pre-wrap">
                    {logs.map((log, index) => (
                        <p key={index} className="font-mono">{log}</p>
                    ))}
                </pre>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\history\page.tsx ---
// src/app/dashboard/history/page.tsx

"use client";

import { useEffect, useState } from 'react';
import toast from 'react-hot-toast';
import { Badge } from '@/components/ui/badge'; // 1. IMPORTUOTAS Badge KOMPONENTAS

// 2. ATNAUJINTA SĄSAJA, KAD ĮTRAUKTŲ RINKOS KONTEKSTĄ
interface TradeLog {
    symbol: string;
    entryPrice: number;
    exitPrice: number;
    pnl: number;
    analysisContext: {
        reason: string;
    };
    marketContext?: { // Naujas, neprivalomas laukas
        regime: 'Risk-On' | 'Risk-Off' | 'Neutral';
        regimeScore: number;
        sentiment: 'Bullish' | 'Bearish' | 'Neutral';
        sentimentScore: number;
    };
}

// 3. ATNAUJINTI PAVYZDINIAI DUOMENYS
const mockTradeHistory: TradeLog[] = [
    {
        symbol: 'SOLUSDT',
        entryPrice: 140.5,
        exitPrice: 155.2,
        pnl: 1470.00,
        analysisContext: { reason: 'PositionManager decision' },
        marketContext: {
            regime: 'Risk-On',
            regimeScore: 8.2,
            sentiment: 'Bullish',
            sentimentScore: 0.75,
        }
    },
    {
        symbol: 'ADAUSDT',
        entryPrice: 0.45,
        exitPrice: 0.43,
        pnl: -200.00,
        analysisContext: { reason: 'Automatic Stop Loss' },
        marketContext: {
            regime: 'Risk-Off',
            regimeScore: 3.1,
            sentiment: 'Bearish',
            sentimentScore: -0.5,
        }
    }
];

export default function HistoryPage() {
    const [tradeHistory, setTradeHistory] = useState<TradeLog[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchHistory() {
            setIsLoading(true);
            try {
                // In a real scenario, the API would fetch real data
                // const response = await fetch('/api/history');
                // if (!response.ok) throw new Error('Failed to fetch trade history.');
                // const data = await response.json();
                // For now, we use mock data
                setTradeHistory(mockTradeHistory);
            } catch (error) {
                toast.error("Could not load trade history.");
                console.error(error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchHistory();
    }, []);

    const getRegimeVariant = (regime: string) => {
        if (regime === 'Risk-On') return 'success';
        if (regime === 'Risk-Off') return 'destructive';
        return 'secondary';
    };

    const getSentimentVariant = (sentiment: string) => {
        if (sentiment === 'Bullish') return 'success';
        if (sentiment === 'Bearish') return 'destructive';
        return 'secondary';
    };

    if (isLoading) {
        return <div className="text-white p-6">Loading trade history...</div>;
    }

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Trade History</h1>
            <div className="bg-gray-800 p-4 rounded-lg">
                <div className="overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr className="border-b border-gray-700 text-sm text-gray-400">
                                <th className="text-left p-2">Symbol</th>
                                <th className="text-left p-2">Entry Price</th>
                                <th className="text-left p-2">Exit Price</th>
                                <th className="text-left p-2">P/L</th>
                                <th className="text-left p-2">Reason</th>
                                {/* 4. NAUJAS LENTELĖS STULPELIS */}
                                <th className="text-left p-2">Market Context</th>
                            </tr>
                        </thead>
                        <tbody>
                            {tradeHistory.length > 0 ? (
                                tradeHistory.map((trade, index) => (
                                    <tr key={index} className="border-b border-gray-700 text-sm">
                                        <td className="p-2 font-semibold">{trade.symbol}</td>
                                        <td className="p-2">€{trade.entryPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td>
                                        <td className="p-2">€{trade.exitPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td>
                                        <td className={`p-2 font-bold ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            €{trade.pnl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                        </td>
                                        <td className="p-2 text-gray-300">{trade.analysisContext?.reason || 'N/A'}</td>
                                        {/* 5. NAUJO STULPELIO TURINYS */}
                                        <td className="p-2">
                                            {trade.marketContext ? (
                                                <div className="flex flex-col space-y-1">
                                                    <Badge variant={getRegimeVariant(trade.marketContext.regime)}>
                                                        {trade.marketContext.regime.replace('-', ' ')} ({trade.marketContext.regimeScore.toFixed(1)})
                                                    </Badge>
                                                    <Badge variant={getSentimentVariant(trade.marketContext.sentiment)}>
                                                        {trade.marketContext.sentiment} ({trade.marketContext.sentimentScore.toFixed(2)})
                                                    </Badge>
                                                </div>
                                            ) : (
                                                <span className="text-gray-500">N/A</span>
                                            )}
                                        </td>
                                    </tr>
                                ))
                            ) : (
                                <tr>
                                    <td colSpan={6} className="text-center p-4">No trade history found.</td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\how-it-works\page.tsx ---
// src/app/dashboard/how-it-works/page.tsx

"use client";

import { FeatureCard } from "@/components/how-it-works/FeatureCard";
import { Section } from "@/components/how-it-works/Section";
import { TimelineStep } from "@/components/how-it-works/TimelineStep";
import { Zap, BrainCircuit, Scale, Search, GitBranch, MemoryStick, Bot, ChevronsRight } from "lucide-react";

export default function HowItWorksPage() {
    return (
        <div className="text-white p-4 sm:p-6">
            <div className="bg-gray-800 rounded-lg p-8 md:p-12">
                <h1 className="text-4xl md:text-5xl font-extrabold tracking-tight text-center">
                    The Architecture of a <span className="text-blue-400">Next-Generation</span> AI Trader
                </h1>
                <p className="mt-6 max-w-3xl mx-auto text-lg text-gray-400 text-center">
                    This is not just another trading bot. It's a decentralized cognitive system, a "Hive Mind" of specialized AI agents working in synergy. Discover the core principles that set it apart.
                </p>
            </div>

            <Section
                title="The Core Pillars"
                subtitle="Our system is built on three foundational concepts."
            >
                <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
                    <FeatureCard 
                        icon={BrainCircuit}
                        title="Multi-Agent System"
                        description="Instead of a single monolithic AI, we use a team of specialized agents (Macro, Sentiment, Technical, Risk, etc.). Each agent is an expert in its field, ensuring deep analysis at every level."
                    />
                    <FeatureCard 
                        icon={GitBranch}
                        title="Agent Debates"
                        description="True intelligence is born from discussion. When data is conflicting (e.g., great technicals but poor market conditions), our agents engage in a 'debate' to reach a more robust, nuanced conclusion."
                        isNextGen={true}
                    />
                    <FeatureCard 
                        icon={MemoryStick}
                        title="Vector Memory"
                        description="Every trade, successful or not, becomes a 'memory'. The system learns from its entire history, recognizing patterns and avoiding repeated mistakes by consulting its past experiences."
                        isNextGen={true}
                    />
                </div>
            </Section>

            <Section
                title="A Single Trade Cycle: Step-by-Step"
                subtitle="Follow the flow of information from market signal to execution."
            >
                <div className="space-y-12">
                   <TimelineStep
                        icon={Search}
                        title="1. Intelligence Gathering & Scouting"
                        description="The cycle begins with a wide data sweep. The DEX Scout hunts for new, high-risk opportunities while other systems gather macroeconomic data, market sentiment, news, and fundamental project information."
                   />
                   <TimelineStep
                        icon={ChevronsRight}
                        title="2. Analysis by Specialists"
                        description="The raw data is distributed to the specialized agents. MacroAnalyst assesses the overall market risk. SentimentAnalyst reads the news and social 'mood'. TechnicalAnalyst crunches the numbers on hundreds of assets."
                   />
                   <TimelineStep
                        icon={Scale}
                        title="3. Synthesis, Debate & Memory Recall"
                        description="The RiskManager receives all analyses. It identifies conflicts, initiates debates between agents to resolve them, and queries its vector memory for lessons from similar past situations."
                   />
                   <TimelineStep
                        icon={Bot}
                        title="4. Decision & Execution"
                        description="Armed with a complete, debated, and experience-informed picture, the RiskManager makes the final BUY/AVOID decision. The PortfolioAllocator then calculates the precise capital allocation, and the trade is executed."
                        isLast={true}
                   />
                </div>
            </Section>

             <Section
                title="The Path to Autonomy: The Self-Improvement Loop"
                subtitle="This is what makes the system truly next-generation."
            >
                <div className="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                    <div className="space-y-4">
                         <FeatureCard 
                            icon={Zap}
                            title="Shadow Mode"
                            description="After analyzing its performance, the StrategyOptimizer creates a new, potentially superior set of rules. This new 'Shadow' bot trades with virtual money alongside the main bot."
                            isNextGen={true}
                        />
                         <FeatureCard 
                            icon={Bot}
                            title="Master Agent Oversight"
                            description="A MasterAgent constantly compares the performance of the main bot and the Shadow bot. If the new strategy consistently proves more profitable over a set period, the MasterAgent automatically 'promotes' the shadow strategy to become the new main strategy. The system evolves without human intervention."
                            isNextGen={true}
                        />
                    </div>
                    <div className="text-center">
                        <p className="text-7xl">🧠</p>
                        <p className="mt-4 text-2xl font-bold text-purple-400">The Bot Teaches Itself.</p>
                        <p className="text-gray-400">This cycle of analysis, testing, and autonomous promotion is the final step towards a truly intelligent and adaptive trading system.</p>
                    </div>
                </div>
            </Section>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\intel\page.tsx ---
// src/app/dashboard/intel/page.tsx

import { TopNarrativesCard } from '@/components/TopNarrativesCard';
import { CatalystCalendarCard } from '@/components/CatalystCalendarCard';
import { GainersLosersCard } from '@/components/GainersLosersCard';
import { CoinMarketCapService } from '@/core/coinmarketcap';

// This is now a Server Component. Data fetching happens on the server before the page is sent to the client.
async function getIntelData() {
    try {
        const cmc = new CoinMarketCapService();
        const [
            globalMetrics,
            topNarratives,
            airdrops,
            gainersLosers,
            trendingTokens
        ] = await Promise.all([
            cmc.getGlobalMetrics(),
            cmc.getCategories(),
            cmc.getAirdrops(),
            cmc.getTrendingGainersAndLosers(),
            cmc.getTrendingTokens()
        ]);

        return {
            globalMetrics: globalMetrics?.quote?.USD,
            topNarratives,
            catalystCalendar: airdrops,
            dailyMovers: {
                gainers: gainersLosers?.gainers,
                losers: gainersLosers?.losers,
            },
            communityPulse: {
                trendingTokens,
            },
        };
    } catch (error) {
        console.error("[Intel Page] Failed to fetch server-side data:", error);
        return null; // Return null on error
    }
}

export default async function MarketIntelPage() {
    const intelData = await getIntelData();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            <h1 className="text-2xl font-bold">Market Intelligence</h1>
            
            {intelData ? (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <TopNarrativesCard narratives={intelData.topNarratives || null} />
                    <CatalystCalendarCard airdrops={intelData.catalystCalendar || null} />
                    <GainersLosersCard movers={intelData.dailyMovers || null} />
                    
                    <div className="bg-gray-900 text-white p-4 rounded-lg md:col-span-2">
                        <h2 className="font-bold text-lg mb-2">Global Market Metrics</h2>
                        <pre className="text-xs text-gray-400 overflow-auto">{JSON.stringify(intelData.globalMetrics, null, 2)}</pre>
                    </div>
                     <div className="bg-gray-900 text-white p-4 rounded-lg">
                        <h2 className="font-bold text-lg mb-2">Community Pulse</h2>
                         <pre className="text-xs text-gray-400 overflow-auto">{JSON.stringify(intelData.communityPulse, null, 2)}</pre>
                    </div>
                </div>
            ) : (
                <div className="text-center text-red-400">
                    <p>Failed to load Market Intelligence data. Please check the server logs.</p>
                </div>
            )}
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\optimization\page.tsx ---
// src/app/dashboard/optimization/page.tsx

"use client";

import { useState } from 'react';
import toast from 'react-hot-toast';
import { DecisionDeepDiveModal, DecisionData } from '@/components/DecisionDeepDiveModal'; // 1. IMPORTUOJAME NAUJĄ KOMPONENTĄ
import { Eye } from 'lucide-react';

// Define interfaces for our state and props
interface Settings {
    [key: string]: string | number;
}
interface Analysis {
    analysis_summary: string;
    suggested_settings: Settings;
}
const SETTING_DESCRIPTIONS: { [key: string]: string } = { /* ... existing descriptions ... */ };

// 2. PAVYZDINIAI DUOMENYS GILUMINEI ANALIZEI
const mockDecisions: DecisionData[] = [
    {
        symbol: 'SOLUSDT', decision: 'BUY', outcome: 'Profit', pnl: 1470.00, timestamp: '2025-08-18T10:30:00Z',
        context: {
            macro: { regime: 'Risk-On', score: 8.2 },
            sentiment: { mood: 'Bullish', score: 0.75 },
            technicals: { score: 8.8, summary: 'Strong uptrend with bullish momentum.' }
        },
        consultation: {
            question: "I see a great technical signal for SOL, but your macro analysis shows 'Risk-Off'. Is this a market bottoming signal or a classic bear trap?",
            answer: "This is a temporary correction; the fundamentals remain strong. The high technical score justifies a calculated risk."
        },
        pastLessons: ["Previous profitable SOL trade in 'Risk-On' led to a +20% gain."]
    },
    {
        symbol: 'ADAUSDT', decision: 'BUY', outcome: 'Loss', pnl: -200.00, timestamp: '2025-08-17T14:00:00Z',
        context: {
            macro: { regime: 'Risk-Off', score: 3.1 },
            sentiment: { mood: 'Bearish', score: -0.5 },
            technicals: { score: 7.5, summary: 'Decent setup but fighting the overall market trend.' }
        },
        pastLessons: ["Buying ADA during 'Risk-Off' previously resulted in a small loss."]
    }
];

export default function OptimizationPage() {
    const [analysis, setAnalysis] = useState<Analysis | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [currentSettings, setCurrentSettings] = useState<Settings | null>({ takeProfitPercent: 5, stopLossPercent: -2 }); // Mock
    
    // 3. BŪSENOS VALDYMAS MODALINIAM LANGUI
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [selectedDecision, setSelectedDecision] = useState<DecisionData | null>(null);

    const handleOpenModal = (decision: DecisionData) => {
        setSelectedDecision(decision);
        setIsModalOpen(true);
    };

    const runOptimization = async () => { /* ... existing function ... */ };
    const applyAiSettings = async () => { /* ... existing function ... */ };
    const renderSettingsTable = (title: string, settings: Settings | null) => { /* ... existing function ... */ };

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">Autonomous AI Optimization</h1>
            {/* Top section for running analysis remains the same */}
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <p className="mb-4">
                    Click the button below to have the AI analyze all past trades. It will identify patterns and propose a new, optimized set of parameters to improve its own profitability.
                </p>
                <button onClick={runOptimization} disabled={isLoading} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                    {isLoading ? 'AI is Thinking...' : 'Run AI Optimization Analysis'}
                </button>
            </div>
            
            {/* 4. NAUJAS "DEEP DIVE" BLOKAS */}
            <div className="bg-gray-800 p-4 rounded-lg mb-8">
                <h2 className="text-xl font-bold mb-4">Decision Deep Dive</h2>
                <p className="text-sm text-gray-400 mb-4">Analyze the bot's most impactful past decisions to understand its reasoning process.</p>
                <div className="overflow-x-auto">
                    <table className="min-w-full text-sm">
                        <thead className="text-gray-400">
                            <tr className="border-b border-gray-700">
                                <th className="p-2 text-left">Symbol</th>
                                <th className="p-2 text-left">Decision</th>
                                <th className="p-2 text-left">Outcome</th>
                                <th className="p-2 text-left">P/L</th>
                                <th className="p-2 text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {mockDecisions.map((decision) => (
                                <tr key={decision.timestamp} className="border-b border-gray-700">
                                    <td className="p-2 font-semibold">{decision.symbol}</td>
                                    <td className="p-2">{decision.decision}</td>
                                    <td className={`p-2 font-bold ${decision.outcome === 'Profit' ? 'text-green-400' : 'text-red-400'}`}>{decision.outcome}</td>
                                    <td className={`p-2 ${decision.outcome === 'Profit' ? 'text-green-400' : 'text-red-400'}`}>{decision.pnl.toFixed(2)}€</td>
                                    <td className="p-2 text-center">
                                        <button onClick={() => handleOpenModal(decision)} className="p-1 text-gray-300 hover:text-white">
                                            <Eye size={18} />
                                        </button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>

            {/* Existing analysis and settings comparison section */}
            {analysis && (
                 <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                     {/* ... renderSettingsTable calls ... */}
                 </div>
            )}
            
            {/* 5. MODALINIO LANGO KOMPONENTAS */}
            <DecisionDeepDiveModal 
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                data={selectedDecision}
            />
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\portfolio\page.tsx ---
// src/app/dashboard/portfolio/page.tsx

"use client";

import { useEffect, useState, useRef, useCallback } from 'react';
import { useDashboard } from '@/context/DashboardContext';
import toast from 'react-hot-toast';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { ShieldCheck } from 'lucide-react'; // 1. IMPORTUOTA NAUJA PIKTOGRAMA

// Define interfaces for our state and props
interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPnlPercent?: number;
    takeProfitPercent?: number;
    holdCount?: number;
    stopLossPrice?: number;
}

interface Settings {
    trailingProfitPercent: number;
    takeProfitPercent: number;
    stopLossPercent: number;
    [key: string]: string | number;
}

// 2. PRIDĖTI PAVYZDINIAI FUNDAMENTALŪS DUOMENYS
// In a real scenario, this data would be fetched via an API for each position.
const mockFundamentalData: { [symbol: string]: { tags: string[], description: string } } = {
    'BTCUSDT': {
        tags: ['Mineable', 'PoW', 'Store of Value'],
        description: 'Bitcoin is a decentralized digital currency that can be sent from user to user on the peer-to-peer bitcoin network without the need for intermediaries.'
    },
    'ETHUSDT': {
        tags: ['PoS', 'Smart Contracts', 'DeFi'],
        description: 'Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether is the native cryptocurrency of the platform.'
    }
};

export default function PortfolioPage() {
    const { state, dispatch } = useDashboard();
    const { portfolio, marketData } = state;
    const [settings, setSettings] = useState<Settings | null>(null);
    const triggeredSymbolsRef = useRef(new Set<string>());

    useEffect(() => {
        async function fetchSettings() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                setSettings(data);
            } catch (error) {
                console.error("Failed to fetch settings:", error);
            }
        }
        fetchSettings();
    }, []);

    const handleSell = useCallback(async (symbol: string, amount: number) => {
        const toastId = toast.loading(`Selling ${amount} of ${symbol}...`);
        try {
            const response = await fetch('/api/portfolio/sell', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ symbol, amount }),
            });
            if (!response.ok) throw new Error('Failed to sell.');
            
            const newPortfolio = await response.json();
            dispatch({ type: 'SET_PORTFOLIO', payload: newPortfolio });
            toast.success('Sell successful!', { id: toastId });
        } catch {
            toast.error('Sell failed.', { id: toastId });
        }
    }, [dispatch]);

    // This effect handles decision triggers. The logic remains the same.
    useEffect(() => {
        // ... (existing useEffect logic remains unchanged)
    }, [portfolio, marketData, settings, handleSell]);

    if (!portfolio) {
        return <div>Loading portfolio...</div>;
    }

    const getPositionDisplayData = (pos: Position) => {
        const marketInfo = marketData.find((md: { symbol: string; lastPrice: string; }) => md.symbol === pos.symbol);
        const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
        const pnl = (currentPrice - pos.entryPrice) * pos.amount;
        const pnlPercent = (pos.entryPrice * pos.amount) === 0 ? 0 : (pnl / (pos.entryPrice * pos.amount)) * 100;
        return { currentPrice, pnl, pnlPercent };
    };

    return (
        <div className="text-white">
            <h1 className="text-2xl font-bold mb-4">My Portfolio</h1>
            <div className="bg-gray-800 p-4 rounded-lg">
                <h2 className="text-xl font-bold mb-4">Open Positions</h2>
                {/* Mobile View - Cards */}
                <div className="md:hidden">
                    {portfolio.positions.map((pos: Position, index: number) => {
                        const { currentPrice, pnl, pnlPercent } = getPositionDisplayData(pos);
                        const fundamentals = mockFundamentalData[pos.symbol];
                        return (
                            <div key={index} className="bg-gray-700 rounded-lg p-4 mb-4">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="font-bold text-lg">{pos.symbol}</span>
                                    <span className={`font-bold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        {pnlPercent.toFixed(2)}%
                                    </span>
                                </div>
                                <div className="text-sm space-y-1">
                                    <p><strong>Amount:</strong> {pos.amount.toLocaleString('en-US', { minimumFractionDigits: 5, maximumFractionDigits: 5 })}</p>
                                    <p><strong>Entry Price:</strong> €{pos.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                                    <p><strong>Current Price:</strong> €{currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                                    <p><strong>P/L:</strong> <span className={pnl >= 0 ? 'text-green-400' : 'text-red-400'}>€{pnl.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span></p>
                                    {/* 3. NAUJA EILUTĖ MOBILIAJAME VAIZDE */}
                                    {fundamentals && (
                                        <div className="flex items-center pt-1">
                                            <strong>Assessment:</strong>
                                            <ShieldCheck size={16} className="text-green-500 ml-2 mr-1" />
                                            <span className="text-gray-300 text-xs">{fundamentals.tags.join(', ')}</span>
                                        </div>
                                    )}
                                </div>
                                <button onClick={() => handleSell(pos.symbol, pos.amount)} className="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
                                    Sell
                                </button>
                            </div>
                        );
                    })}
                </div>
                {/* Desktop View - Table */}
                <div className="hidden md:block overflow-x-auto">
                    <table className="min-w-full">
                        <thead>
                            <tr className="border-b border-gray-700">
                                <th className="text-left p-2">Symbol</th>
                                <th className="text-left p-2">Amount</th>
                                <th className="text-left p-2">Entry Price</th>
                                <th className="text-left p-2">Current Price</th>
                                <th className="text-left p-2">P/L (%)</th>
                                {/* 4. NAUJAS STULPELIS LENTELĖJE */}
                                <th className="text-left p-2">Fundamental Assessment</th>
                                <th className="text-left p-2">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {portfolio.positions.map((pos: Position, index: number) => {
                                const { currentPrice, pnlPercent } = getPositionDisplayData(pos);
                                const fundamentals = mockFundamentalData[pos.symbol];
                                return (
                                    <tr key={index} className="border-b border-gray-700">
                                        <td className="p-2 font-bold">{pos.symbol}</td>
                                        <td className="p-2">{pos.amount.toLocaleString('en-US', { minimumFractionDigits: 5, maximumFractionDigits: 5 })}</td>
                                        <td className="p-2">€{pos.entryPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className="p-2">€{currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                        <td className={`p-2 font-semibold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {pnlPercent.toFixed(2)}%
                                        </td>
                                        {/* 5. NAUJO STULPELIO TURINYS SU TOOLTIP */}
                                        <td className="p-2">
                                            {fundamentals ? (
                                                <TooltipProvider>
                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <div className="flex items-center cursor-pointer">
                                                                <ShieldCheck size={18} className="text-green-500" />
                                                                <span className="ml-2 text-gray-300 text-xs hidden lg:block">{fundamentals.tags[0]}</span>
                                                            </div>
                                                        </TooltipTrigger>
                                                        <TooltipContent className="max-w-xs">
                                                            <p className="font-bold mb-1">Tags: {fundamentals.tags.join(', ')}</p>
                                                            <p className="text-xs text-gray-400">{fundamentals.description}</p>
                                                        </TooltipContent>
                                                    </Tooltip>
                                                </TooltipProvider>
                                            ) : (
                                                <span className="text-gray-500 text-xs">N/A</span>
                                            )}
                                        </td>
                                        <td className="p-2">
                                            <button onClick={() => handleSell(pos.symbol, pos.amount)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded">
                                                Sell
                                            </button>
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\app\dashboard\settings\page.tsx ---
// src/app/dashboard/settings/page.tsx

"use client";

import { useState, useEffect } from 'react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { HelpCircle } from 'lucide-react';
import toast from 'react-hot-toast';

// Define an interface for the settings object
interface Settings {
    [key: string]: string | number | boolean;
}

// Helper component for section titles
const SectionTitle = ({ title, description }: { title: string, description: string }) => (
    <div className="col-span-1 md:col-span-2 lg:col-span-3 mt-6 mb-2 border-b border-gray-700 pb-2">
        <h2 className="text-xl font-semibold">{title}</h2>
        <p className="text-sm text-gray-400">{description}</p>
    </div>
);

// Helper component for individual settings
const SettingInput = ({ name, label, tooltip, type = 'number', value, onChange, options, step }: any) => (
    <div>
        <label className="block text-sm font-medium text-gray-300 mb-1 flex items-center">
            {label}
            <TooltipProvider>
                <Tooltip>
                    <TooltipTrigger asChild>
                        <HelpCircle size={14} className="ml-2 text-gray-500 cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                        <p className="max-w-xs">{tooltip}</p>
                    </TooltipContent>
                </Tooltip>
            </TooltipProvider>
        </label>
        {type === 'select' && (
            <select name={name} value={value} onChange={onChange} className="bg-gray-700 rounded p-2 w-full">
                {options.map((opt: string) => <option key={opt} value={opt}>{opt}</option>)}
            </select>
        )}
        {type === 'number' && (
            <input type="number" name={name} value={value} onChange={onChange} className="bg-gray-700 rounded p-2 w-full" step={step || '1'} />
        )}
        {type === 'checkbox' && (
            <label className="flex items-center space-x-2 cursor-pointer mt-2">
                <input type="checkbox" name={name} checked={!!value} onChange={onChange} className="bg-gray-700 rounded h-5 w-5 text-blue-500 focus:ring-blue-500 border-gray-600" />
                <span className="text-gray-300">{!!value ? 'Enabled' : 'Disabled'}</span>
            </label>
        )}
    </div>
);


export default function SettingsPage() {
    const [settings, setSettings] = useState<Settings>({});
    const [isLoading, setIsLoading] = useState(true);

    // Mock fetch, in real life this would be a fetch call
    useEffect(() => {
        setIsLoading(true);
        // Mock data that includes the new settings
        const mockSettings = {
            takeProfitPercent: 7.5,
            stopLossPercent: -3.0,
            riskAmountPercent: 2.0,
            symbolsToAnalyze: 50,
            batchSize: 10,
            macroScoreThreshold: 4.5,
            cycleIntervalMinutes: 15,
            // New Narrative Trading Settings
            enableNarrativeTrading: true,
            narrativeAllocationBoost: 25,
            // New DEX Hunting Settings
            enableDexHunting: false,
            dexMaxAllocationPercent: 5,
            // New Autonomous Improvement Settings
            enableAutoImprovement: false,
        };
        setSettings(mockSettings);
        setIsLoading(false);
    }, []);

    const handleSave = async () => {
        // ... existing save logic ...
        toast.success('Settings saved!');
    };
    
    const handleReset = async () => {
        // ... existing reset logic ...
        toast.success('All logs and portfolio have been reset!');
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        let finalValue;
        if (type === 'checkbox') {
            finalValue = (e.target as HTMLInputElement).checked;
        } else if (type === 'number') {
            finalValue = parseFloat(value);
        } else {
            finalValue = value;
        }
        setSettings(prev => ({ ...prev, [name]: finalValue }));
    };

    if (isLoading) {
        return <div className="text-white p-6">Loading settings...</div>;
    }

    return (
        <div className="text-white p-6">
            <h1 className="text-3xl font-bold mb-6">Bot Settings</h1>
            <div className="bg-gray-800 p-6 rounded-lg">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">

                    <SectionTitle title="Trade Execution" description="Core parameters for buying and selling assets."/>
                    <SettingInput name="takeProfitPercent" label="Take Profit (%)" tooltip="The percentage of profit at which to consider selling." value={settings.takeProfitPercent} onChange={handleChange} step="0.1" />
                    <SettingInput name="stopLossPercent" label="Stop Loss (%)" tooltip="The percentage of loss at which to automatically sell an asset. Should be negative." value={settings.stopLossPercent} onChange={handleChange} step="0.1" />
                    <SettingInput name="riskAmountPercent" label="Risk per Trade (%)" tooltip="The percentage of your total balance to risk on a single trade." value={settings.riskAmountPercent} onChange={handleChange} step="0.1" />

                    <SectionTitle title="Market Analysis" description="How the bot scans the market and decides which assets to analyze."/>
                    <SettingInput name="symbolsToAnalyze" label="Symbols to Analyze" tooltip="The number of top symbols by volume to analyze in each cycle." value={settings.symbolsToAnalyze} onChange={handleChange} />
                    <SettingInput name="batchSize" label="Analysis Batch Size" tooltip="The number of symbols to analyze in a single AI request to avoid rate limits." value={settings.batchSize} onChange={handleChange} />
                    <SettingInput name="macroScoreThreshold" label="Macro Score Threshold" tooltip="The minimum macroeconomic score (0-10) required to consider entering new trades." value={settings.macroScoreThreshold} onChange={handleChange} step="0.1" />
                    <SettingInput name="cycleIntervalMinutes" label="Cycle Interval (Minutes)" tooltip="The time in minutes between each trading cycle." value={settings.cycleIntervalMinutes} onChange={handleChange} />
                    
                    <SectionTitle title="Advanced Strategies" description="Enable and configure higher-level strategic modules."/>
                    <div className="p-4 bg-gray-900 rounded-lg col-span-1 md:col-span-2 lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <SettingInput name="enableNarrativeTrading" label="Narrative Trading" tooltip="If enabled, the bot will prioritize assets from the currently dominant market narrative (e.g., AI, GameFi)." type="checkbox" value={settings.enableNarrativeTrading} onChange={handleChange} />
                        <SettingInput name="narrativeAllocationBoost" label="Narrative Allocation Boost (%)" tooltip="Increase the allocated capital for assets within the dominant narrative by this percentage." value={settings.narrativeAllocationBoost} onChange={handleChange} />
                    </div>
                    
                     <SectionTitle title="Future Features (High Risk)" description="Experimental features for advanced users."/>
                     <div className="p-4 bg-gray-900 rounded-lg col-span-1 md:col-span-2 lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <SettingInput name="enableDexHunting" label="DEX Hunting" tooltip="Enable the DEX Scout agent to find new, high-risk opportunities on decentralized exchanges." type="checkbox" value={settings.enableDexHunting} onChange={handleChange} />
                        <SettingInput name="dexMaxAllocationPercent" label="DEX Max Allocation (%)" tooltip="The maximum percentage of the portfolio to allocate to high-risk DEX opportunities." value={settings.dexMaxAllocationPercent} onChange={handleChange} />
                    </div>
                     <div className="p-4 bg-gray-900 rounded-lg col-span-1 md:col-span-2 lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <SettingInput name="enableAutoImprovement" label="Autonomous Improvement" tooltip="Allow the MasterAgent to automatically apply new settings after a successful 'Shadow Mode' test." type="checkbox" value={settings.enableAutoImprovement} onChange={handleChange} />
                    </div>
                </div>

                <div className="mt-8 border-t border-gray-700 pt-6">
                    <button onClick={handleSave} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-md transition-colors">
                        Save Settings
                    </button>
                    <button onClick={handleReset} className="bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-md transition-colors ml-4">
                        Reset All Logs & Portfolio
                    </button>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\ActivityFeed.tsx ---
// src/components/ActivityFeed.tsx

"use client";

import { useDashboard } from '@/context/DashboardContext';
import { ScrollArea } from './ui/scroll-area';
import { Power, ShoppingCart, DollarSign, AlertTriangle, Zap, ArrowRight, Bot } from 'lucide-react';
import React from 'react';

// This function determines the icon and color based on the log message content.
const parseLog = (log: string) => {
    const lowerCaseLog = log.toLowerCase();
    
    // Remove the timestamp for parsing
    const message = log.substring(log.indexOf(']') + 2);

    if (lowerCaseLog.includes('bought')) {
        return { Icon: ShoppingCart, color: 'text-green-400', text: message };
    }
    if (lowerCaseLog.includes('sold')) {
        return { Icon: DollarSign, color: 'text-red-400', text: message };
    }
    if (lowerCaseLog.includes('status changed to active')) {
        return { Icon: Power, color: 'text-yellow-400', text: 'Bot Activated' };
    }
     if (lowerCaseLog.includes('status set to active')) {
        return { Icon: Power, color: 'text-yellow-400', text: 'Bot Status set to Active' };
    }
    if (lowerCaseLog.includes('status changed to inactive') || lowerCaseLog.includes('stopped')) {
        return { Icon: Power, color: 'text-gray-500', text: 'Bot Deactivated' };
    }
    if (lowerCaseLog.includes('error')) {
        return { Icon: AlertTriangle, color: 'text-red-500', text: message };
    }
    if (lowerCaseLog.includes('decided to')) {
        return { Icon: Bot, color: 'text-blue-400', text: message };
    }
    if (lowerCaseLog.includes('cycle started')) {
        return { Icon: Zap, color: 'text-purple-400', text: 'New analysis cycle started.' };
    }
    
    // Default for general logs
    return { Icon: ArrowRight, color: 'text-gray-400', text: message };
};

export function ActivityFeed() {
    const { state } = useDashboard();
    
    // Reverse the logs so the newest appear at the top
    const reversedLogs = [...state.logs].reverse();

    return (
        <div className="bg-gray-800 p-4 rounded-lg h-full flex flex-col">
            <h2 className="font-semibold text-md mb-4">Activity Feed</h2>
            <ScrollArea className="flex-grow">
                <div className="space-y-3 pr-2">
                    {reversedLogs.length === 0 ? (
                        <p className="text-gray-500 text-sm">No activity yet. Start the bot to see live events.</p>
                    ) : (
                        reversedLogs.map((log, index) => {
                            const { Icon, color, text } = parseLog(log);
                            return (
                                <div key={index} className="flex items-start text-xs">
                                    <Icon size={14} className={`mr-3 mt-0.5 flex-shrink-0 ${color}`} />
                                    <p className={`flex-grow ${color}`}>
                                        <span className="text-gray-500 mr-2">{log.substring(1, 9)}</span>
                                        {text}
                                    </p>
                                </div>
                            );
                        })
                    )}
                </div>
            </ScrollArea>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\ai-chat-window.tsx ---
// src/components/ai-chat-window.tsx

"use client";

import { useState } from 'react';
import { useDashboard, AiChat } from '@/context/DashboardContext';
import { ScrollArea } from '@/components/ui/scroll-area';
import { cn } from '@/lib/utils'; // Utility for conditional classes

export function AiChatWindow() {
    const { state } = useDashboard();
    const [activeTab, setActiveTab] = useState<'full' | 'consultations'>('full');

    const renderContent = (chat: AiChat) => {
        const response = chat.response as { summary?: string };
        if (chat.agent === 'System') {
            return (
                <div className="p-2 rounded bg-gray-700">
                    <p className="text-sm text-yellow-300">{response.summary}</p>
                </div>
            );
        }
        return (
            <>
                <div className="p-2 rounded bg-gray-700">
                    <p className="font-bold text-blue-400">{chat.agent} Prompt:</p>
                    <pre className="text-xs whitespace-pre-wrap font-mono overflow-x-auto">{chat.prompt}</pre>
                </div>
                <div className="p-2 rounded bg-gray-600 mt-2">
                    <p className="font-bold text-green-400">{chat.agent} Response:</p>
                    <pre className="text-xs whitespace-pre-wrap font-mono overflow-x-auto">{JSON.stringify(chat.response, null, 2)}</pre>
                </div>
            </>
        );
    };

    const filteredChats = state.aiChat.filter(chat => {
        if (activeTab === 'consultations') {
            // This logic directly supports the "Agent Debates" feature from the strategic plan.
            // It filters for prompts where one agent is consulting another.
            return chat.prompt && chat.prompt.toLowerCase().includes('consult(');
        }
        return true; // 'full' tab shows all chats
    });

    const TabButton = ({ tabName, label }: { tabName: 'full' | 'consultations', label: string }) => (
        <button
            onClick={() => setActiveTab(tabName)}
            className={cn(
                "px-4 py-1.5 text-sm font-semibold rounded-md transition-colors",
                activeTab === tabName
                    ? "bg-blue-600 text-white"
                    : "bg-gray-700 text-gray-300 hover:bg-gray-600"
            )}
        >
            {label}
        </button>
    );

    return (
        <div>
            <div className="flex justify-between items-center mb-4">
                <h2 className="font-bold text-lg">AI Communication Log</h2>
                <div className="flex items-center space-x-2">
                    <TabButton tabName="full" label="Full Log" />
                    <TabButton tabName="consultations" label="Consultations" />
                </div>
            </div>
            <ScrollArea className="bg-gray-900 text-white p-4 rounded-lg h-[40vh]">
                {filteredChats.length > 0 ? (
                    <div className="space-y-4">
                        {filteredChats.map((chat, index) => (
                            <div key={index}>
                                {renderContent(chat)}
                            </div>
                        ))}
                    </div>
                ) : (
                    <div className="flex items-center justify-center h-full">
                        <p className="text-gray-500">No consultations logged in this cycle yet.</p>
                    </div>
                )}
            </ScrollArea>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\analysis-panel.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';

// Define interfaces for the component props and data structures
interface Decision {
    decision: string;
    amount_to_buy_usd: number;
    justification: string;
}

export interface Analysis {
    PortfolioAllocator?: {
        response: {
            [symbol: string]: Decision;
        };
    };
}

interface AnalysisPanelProps {
    analysis?: Analysis;
}

export function AnalysisPanel({ analysis }: AnalysisPanelProps) {
    const { state } = useDashboard();
    const lastRunAnalysis = analysis || state.lastRunAnalysis;

    if (!lastRunAnalysis || Object.keys(lastRunAnalysis).length === 0) {
        return (
            <div className="bg-gray-900 text-white p-4 rounded-lg h-full flex items-center justify-center col-span-full">
                <div className="text-center">
                    <h2 className="font-bold text-lg mb-2">AI Analysis</h2>
                    <p className="text-gray-400">Run a cycle to get AI analysis.</p>
                </div>
            </div>
        );
    }

    const portfolioAllocator = lastRunAnalysis.PortfolioAllocator;
    const allocations = 
        portfolioAllocator && 
        typeof portfolioAllocator === 'object' && 
        'response' in portfolioAllocator &&
        portfolioAllocator.response &&
        typeof portfolioAllocator.response === 'object'
            ? portfolioAllocator.response 
            : {};
    
    const allDecisions = Object.entries(allocations);

    if (allDecisions.length === 0) {
        return (
            <div className="bg-gray-900 text-white p-4 rounded-lg h-full flex items-center justify-center col-span-full">
                <p className="text-gray-400">Portfolio Allocator did not provide any decisions.</p>
            </div>
        );
    }

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {allDecisions.map(([symbol, dec]) => {
                const decision = dec as Decision;
                const isBuy = decision.decision === 'EXECUTE_BUY';
                
                return (
                    <div key={symbol} className={`bg-gray-900 text-white p-4 rounded-lg border-l-4 ${isBuy ? 'border-green-500' : 'border-gray-600'}`}>
                        <h3 className={`font-bold text-lg mb-2 ${isBuy ? 'text-blue-400' : 'text-gray-500'}`}>{symbol}</h3>
                        <div className="space-y-2 text-sm">
                            <p>
                                <span className="font-semibold">Decision:</span>
                                <span className={`font-bold ml-2 ${isBuy ? 'text-green-400' : 'text-yellow-400'}`}>{decision.decision.replace('_', ' ')}</span>
                            </p>
                            {isBuy && (
                                <p>
                                    <span className="font-semibold">Amount:</span>
                                    <span className="font-bold ml-2">€{decision.amount_to_buy_usd.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                                </p>
                            )}
                            <div>
                                <p className="font-semibold mb-1">Justification:</p>
                                <p className="text-gray-400 text-xs">{decision.justification}</p>
                            </div>
                        </div>
                    </div>
                );
            })}
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\CatalystCalendarCard.tsx ---
// src/components/CatalystCalendarCard.tsx

import { IntelCard } from './IntelCard';
import { Calendar, Droplets } from 'lucide-react';
import { Badge } from './ui/badge';

interface Airdrop {
    project_name: string;
    start_date: string;
    status: string;
}

interface CatalystCalendarCardProps {
    airdrops: Airdrop[] | null;
}

export function CatalystCalendarCard({ airdrops }: CatalystCalendarCardProps) {
    return (
        <IntelCard title="Catalyst Calendar" icon={Calendar}>
             <div className="space-y-3 max-h-60 overflow-y-auto pr-2">
                {!airdrops || airdrops.length === 0 ? (
                     <p className="text-gray-500 text-sm">No upcoming airdrops found.</p>
                ) : (
                    airdrops.map((airdrop) => (
                        <div key={airdrop.project_name} className="flex items-center justify-between text-sm bg-gray-800 p-2 rounded-md">
                            <div className="flex items-center">
                               <Droplets size={16} className="text-gray-500 mr-3" />
                               <div>
                                    <p className="font-semibold">{airdrop.project_name}</p>
                                    <p className="text-xs text-gray-400">
                                        {new Date(airdrop.start_date).toLocaleDateString()}
                                    </p>
                               </div>
                            </div>
                            <Badge variant={airdrop.status === 'UPCOMING' ? 'success' : 'secondary'}>
                                {airdrop.status}
                            </Badge>
                        </div>
                    ))
                )}
            </div>
        </IntelCard>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\chart.tsx ---
// src/components/chart.tsx

"use client";

import { useEffect, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';
import { useDashboard } from '@/context/DashboardContext';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

interface Candle {
    time: number;
    close: number;
}

interface ChartData {
    labels: string[];
    datasets: {
        label: string;
        data: number[];
        borderColor: string;
        backgroundColor: string;
    }[];
}

export function Chart() {
    const { state } = useDashboard();
    const { selectedSymbol } = state;
    const [chartData, setChartData] = useState<ChartData | null>(null);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        async function fetchChartData() {
            if (!selectedSymbol) return;

            setChartData(null); // Reset chart on new symbol selection
            setError(null);

            try {
                const response = await fetch(`/api/chart-data?symbol=${selectedSymbol}`);
                const data = await response.json();

                // THE FIX IS HERE: Check if the response is an array and not an error object.
                if (response.ok && Array.isArray(data)) {
                    const labels = data.map((d: Candle) => new Date(d.time * 1000).toLocaleDateString());
                    const prices = data.map((d: Candle) => d.close);

                    setChartData({
                        labels,
                        datasets: [
                            {
                                label: `${selectedSymbol} Price`,
                                data: prices,
                                borderColor: 'rgb(59, 130, 246)',
                                backgroundColor: 'rgba(59, 130, 246, 0.5)',
                            },
                        ],
                    });
                } else {
                    // If data is not an array, it's likely an error object
                    throw new Error(data.error || 'Failed to fetch valid chart data.');
                }
            } catch (err) {
                const errorMessage = err instanceof Error ? err.message : "An unknown error occurred";
                console.error("Failed to fetch chart data:", errorMessage);
                setError(`Could not load chart data for ${selectedSymbol}.`);
            }
        }
        fetchChartData();
    }, [selectedSymbol]);

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: false,
            },
        },
        scales: {
            y: { ticks: { color: '#d1d5db' } },
            x: { ticks: { color: '#d1d5db' } },
        },
    };

    return (
        <div className="h-[400px] flex items-center justify-center">
            {error && <p className="text-red-400">{error}</p>}
            {!chartData && !error && <p className="text-gray-500">Loading chart...</p>}
            {chartData && <Line data={chartData} options={options} />}
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\dashboard-client.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { MarketTable } from '@/components/market-table';
import { KpiCard } from '@/components/kpi-card';
import { AnalysisPanel } from '@/components/analysis-panel';
import { AiChatWindow } from '@/components/ai-chat-window';
import { NewsFeed } from '@/components/news-feed';
import { Chart } from '@/components/chart';
import { DecisionLog } from '@/components/decision-log';
import { SharedContextDisplay } from '@/components/shared-context-display';
import { DynamicRiskDisplay } from '@/components/dynamic-risk-display';
import { DollarSign, TrendingUp, Wallet } from 'lucide-react';

export function DashboardClient() {
    const { state } = useDashboard();

    return (
        <div className="text-white p-4 sm:p-6 space-y-6">
            {/* Row 1: KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <KpiCard title="Total Value" kpiKey="totalValue" icon={<Wallet size={24} />} />
                <KpiCard title="24h P/L" kpiKey="24h_pnl" icon={<TrendingUp size={24} />} />
                <KpiCard title="Free Collateral" kpiKey="freeCollateral" icon={<DollarSign size={24} />} />
            </div>

            {/* Row 2: Hive Mind & Risk Context */}
            <div className="space-y-6">
                <SharedContextDisplay context={state.sharedContext} />
                <DynamicRiskDisplay />
            </div>

            {/* Row 3: Main Grid */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                {/* Main Content Column */}
                <div className="lg:col-span-2 space-y-6">
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h2 className="text-lg font-semibold mb-4">{state.selectedSymbol} Price Chart</h2>
                        <Chart />
                    </div>
                    <div>
                        <h2 className="text-lg font-semibold mb-4">AI Analysis Cycle: Latest Buys</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                            <AnalysisPanel />
                        </div>
                    </div>
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <AiChatWindow />
                    </div>
                    <DecisionLog />
                </div>

                {/* Side Column */}
                <div className="lg:col-span-1 space-y-6">
                    <MarketTable />
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h2 className="font-semibold text-md mb-2">Live Logs</h2>
                        <div className="bg-gray-900 text-white p-2 rounded-lg h-[25vh] overflow-y-auto text-xs space-y-1 font-mono">
                            {state.logs.map((log, index) => (
                                <p key={index}>{log}</p>
                            ))}
                        </div>
                    </div>
                    <NewsFeed />
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\decision-log.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { ChevronUp, ChevronDown } from 'lucide-react';
import toast from 'react-hot-toast';

interface Decision {
    timestamp: string;
    decision: string;
    justification: string;
    pnlPercent: number;
    currentPrice: number;
}

interface DecisionWithSymbol extends Decision {
    symbol: string;
}

interface DecisionData {
    [symbol: string]: Decision[];
}

export function DecisionLog() {
    const [allDecisions, setAllDecisions] = useState<DecisionWithSymbol[]>([]);
    const [currentIndex, setCurrentIndex] = useState(0);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchDecisions() {
            try {
                const response = await fetch('/api/decisions');
                if (!response.ok) throw new Error('Failed to fetch decisions.');
                const data: DecisionData = await response.json();
                const flattenedDecisions = Object.entries(data).flatMap(([symbol, decisionList]) => 
                    decisionList.map((d: Decision) => ({ ...d, symbol }))
                ).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
                
                setAllDecisions(flattenedDecisions);
                setCurrentIndex(0); // Reset to the latest decision on refresh
            } catch {
                toast.error("Could not load decision log.");
            } finally {
                setIsLoading(false);
            }
        }

        fetchDecisions(); // Initial fetch
        const intervalId = setInterval(fetchDecisions, 10000); // Refresh every 10 seconds
        return () => clearInterval(intervalId);
    }, []);

    useEffect(() => {
        if (allDecisions.length > 1) {
            const timer = setInterval(() => {
                setCurrentIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
            }, 10000); // Cycle to the newest every 10 seconds
            return () => clearInterval(timer);
        }
    }, [allDecisions]);

    const handleNext = () => {
        setCurrentIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
    };

    const handlePrev = () => {
        setCurrentIndex(prevIndex => (prevIndex < allDecisions.length - 1 ? prevIndex + 1 : allDecisions.length - 1));
    };

    const currentDecision = allDecisions[currentIndex];

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">Portfolio Manager Decisions</h2>
                {allDecisions.length > 1 && (
                    <div className="flex items-center space-x-2">
                        <button onClick={handlePrev} disabled={currentIndex === allDecisions.length - 1} className="p-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50">
                            <ChevronDown size={16} />
                        </button>
                        <span className="text-xs text-gray-400">{currentIndex + 1} / {allDecisions.length}</span>
                        <button onClick={handleNext} disabled={currentIndex === 0} className="p-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50">
                            <ChevronUp size={16} />
                        </button>
                    </div>
                )}
            </div>
            <div className="h-[10vh]">
                {isLoading ? (
                    <p>Loading decisions...</p>
                ) : currentDecision ? (
                    <div className="text-xs p-2 bg-gray-900 rounded-md">
                        <div className="flex justify-between items-center mb-1">
                            <span className="font-bold text-blue-400">{currentDecision.symbol}</span>
                            <span className="text-gray-400">{new Date(currentDecision.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <p>
                            <span className="font-semibold">Decision:</span>
                            <span className={`ml-2 font-bold ${currentDecision.decision === 'SELL_NOW' ? 'text-red-400' : 'text-yellow-400'}`}>
                                {currentDecision.decision.replace('_', ' ')}
                            </span>
                        </p>
                        <p className="text-gray-400 mt-1">{currentDecision.justification}</p>
                    </div>
                ) : (
                    <p className="text-gray-400">No decisions logged yet.</p>
                )}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\DecisionDeepDiveModal.tsx ---
// src/components/DecisionDeepDiveModal.tsx

"use client";

import { X } from 'lucide-react';
import { Badge } from './ui/badge';

// This is a placeholder type. In a real scenario, this would be a detailed trade/decision object.
export interface DecisionData {
    symbol: string;
    decision: 'BUY' | 'SELL' | 'HOLD';
    outcome: 'Profit' | 'Loss';
    pnl: number;
    timestamp: string;
    context: {
        macro: { regime: string, score: number };
        sentiment: { mood: string, score: number };
        technicals: { score: number, summary: string };
    };
    consultation?: {
        question: string;
        answer: string;
    };
    pastLessons?: string[];
}

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    data: DecisionData | null;
}

const DataSection = ({ title, children }: { title: string, children: React.ReactNode }) => (
    <div className="bg-gray-800 p-3 rounded-lg">
        <h4 className="font-semibold text-gray-300 mb-2">{title}</h4>
        <div className="text-sm space-y-2">{children}</div>
    </div>
);

const DataRow = ({ label, value }: { label: string, value: React.ReactNode }) => (
    <div className="flex justify-between items-center">
        <span className="text-gray-400">{label}:</span>
        <span className="text-white font-mono text-right">{value}</span>
    </div>
);


export function DecisionDeepDiveModal({ isOpen, onClose, data }: ModalProps) {
    if (!isOpen || !data) return null;

    const outcomeColor = data.outcome === 'Profit' ? 'text-green-400' : 'text-red-400';

    return (
        <div 
            className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4"
            onClick={onClose}
        >
            <div 
                className="bg-gray-900 border border-gray-700 rounded-xl w-full max-w-3xl max-h-[90vh] flex flex-col"
                onClick={(e) => e.stopPropagation()}
            >
                {/* Header */}
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <div className="flex items-center">
                        <Badge className={`mr-3 ${outcomeColor.replace('text', 'bg').replace('-400', '-500')} text-white`}>{data.outcome}</Badge>
                        <h2 className="text-xl font-bold">Deep Dive: {data.decision} {data.symbol}</h2>
                    </div>
                    <button onClick={onClose} className="text-gray-400 hover:text-white">
                        <X size={24} />
                    </button>
                </div>

                {/* Content */}
                <div className="p-4 space-y-4 overflow-y-auto">
                    {/* Situation Section */}
                    <DataSection title="Situation at Time of Decision">
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                               <DataRow label="Macro Regime" value={<Badge variant={data.context.macro.regime === 'Risk-On' ? 'success' : 'destructive'}>{data.context.macro.regime}</Badge>} />
                               <DataRow label="Macro Score" value={data.context.macro.score.toFixed(1)} />
                            </div>
                             <div>
                               <DataRow label="Sentiment" value={<Badge variant={data.context.sentiment.mood === 'Bullish' ? 'success' : 'destructive'}>{data.context.sentiment.mood}</Badge>} />
                               <DataRow label="Sentiment Score" value={data.context.sentiment.score.toFixed(2)} />
                            </div>
                             <div>
                                <DataRow label="Technical Score" value={data.context.technicals.score.toFixed(1)} />
                                <p className="text-xs text-gray-400 mt-1">{data.context.technicals.summary}</p>
                            </div>
                        </div>
                    </DataSection>

                    {/* Consultation Section */}
                    {data.consultation && (
                         <DataSection title="Agent Consultation (Debate)">
                            <div className="bg-gray-900 p-2 rounded">
                                <p className="text-xs text-blue-300 font-semibold">RiskManager asked MacroAnalyst:</p>
                                <p className="text-sm italic">"{data.consultation.question}"</p>
                            </div>
                             <div className="bg-gray-900 p-2 rounded mt-2">
                                <p className="text-xs text-green-300 font-semibold">MacroAnalyst answered:</p>
                                <p className="text-sm">"{data.consultation.answer}"</p>
                            </div>
                        </DataSection>
                    )}

                     {/* Memory Section */}
                    {data.pastLessons && data.pastLessons.length > 0 && (
                         <DataSection title="Past Lessons (From Vector Memory)">
                            <ul className="list-disc list-inside space-y-1 text-xs text-gray-300">
                                {data.pastLessons.map((lesson, i) => <li key={i}>{lesson}</li>)}
                            </ul>
                        </DataSection>
                    )}
                </div>
                 {/* Footer */}
                <div className="p-4 border-t border-gray-700 mt-auto">
                    <div className="flex justify-between items-center text-lg">
                        <span className="text-gray-400">Final Outcome:</span>
                        <span className={`font-bold ${outcomeColor}`}>
                            {data.pnl >= 0 ? '+' : ''}€{data.pnl.toFixed(2)}
                        </span>
                    </div>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\dynamic-risk-display.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { AlertTriangle, ShieldCheck } from 'lucide-react';

export function DynamicRiskDisplay() {
    const { state } = useDashboard();
    const { adjustedConfig, sharedContext } = state;

    if (!adjustedConfig || !sharedContext) {
        return null; // Don't render if there's no adjustment
    }

    const isAggressive = sharedContext.regimeScore > 7.5;
    const isDefensive = sharedContext.regimeScore < 4.0;

    if (!isAggressive && !isDefensive) {
        return null; // No significant adjustment, don't render
    }

    const title = isAggressive ? "Aggressive Stance Adopted" : "Defensive Stance Adopted";
    const Icon = isAggressive ? AlertTriangle : ShieldCheck;
    const color = isAggressive ? "text-yellow-400" : "text-blue-400";
    const reason = isAggressive 
        ? `Market regime is highly favorable (Score: ${sharedContext.regimeScore.toFixed(1)}). Increasing risk exposure.`
        : `Market regime is unfavorable (Score: ${sharedContext.regimeScore.toFixed(1)}). Reducing risk exposure.`;

    return (
        <div className={`bg-gray-800 p-4 rounded-lg border-l-4 ${isAggressive ? 'border-yellow-400' : 'border-blue-400'}`}>
            <div className="flex items-center">
                <Icon size={24} className={`${color} mr-3`} />
                <div>
                    <h3 className={`text-lg font-semibold ${color}`}>{title}</h3>
                    <p className="text-sm text-gray-300">{reason}</p>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\GainersLosersCard.tsx ---
// src/components/GainersLosersCard.tsx

import { IntelCard } from './IntelCard';
import { ArrowUpRight, ArrowDownRight } from 'lucide-react';

interface Mover {
    symbol: string;
    quote: {
        USD: {
            percent_change_24h: number;
        }
    }
}

interface GainersLosersCardProps {
    movers: {
        gainers: Mover[] | null;
        losers: Mover[] | null;
    } | null;
}

const TickerList = ({ title, data, icon: Icon, colorClass }: { title: string, data: Mover[], icon: any, colorClass: string }) => (
    <div>
        <h3 className="font-semibold mb-2 flex items-center">
            <Icon size={18} className={`mr-2 ${colorClass}`} />
            {title}
        </h3>
        <ul className="space-y-2 text-sm">
            {data.map(item => (
                <li key={item.symbol} className="flex justify-between bg-gray-800 p-1.5 rounded">
                    <span className="font-bold">{item.symbol}</span>
                    <span className={colorClass}>{item.quote.USD.percent_change_24h.toFixed(1)}%</span>
                </li>
            ))}
        </ul>
    </div>
);

export function GainersLosersCard({ movers }: GainersLosersCardProps) {
    const hasData = movers && movers.gainers && movers.losers;

    return (
        <IntelCard title="Daily Movers" icon={ArrowUpRight} className="col-span-1 md:col-span-2">
            {!hasData ? (
                 <p className="text-gray-500 text-sm">Could not load daily movers data.</p>
            ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
                    <TickerList title="Top Gainers" data={movers.gainers!} icon={ArrowUpRight} colorClass="text-green-400" />
                    <TickerList title="Top Losers" data={movers.losers!} icon={ArrowDownRight} colorClass="text-red-400" />
                </div>
            )}
        </IntelCard>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\header.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { Power, Timer, Wallet, Menu } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dispatch, SetStateAction } from 'react';

interface HeaderProps {
    setSidebarOpen: Dispatch<SetStateAction<boolean>>;
}

export function Header({ setSidebarOpen }: HeaderProps) {
    const { state, dispatch } = useDashboard();

    const toggleBotStatus = async () => {
        const newStatus = state.botStatus === 'active' ? 'inactive' : 'active';
        try {
            const response = await fetch('/api/bot/status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: newStatus }),
            });
            if (response.ok) {
                dispatch({ type: 'SET_BOT_STATUS', payload: newStatus });
                dispatch({ type: 'ADD_LOG', payload: `Bot status set to ${newStatus}` });
            } else {
                dispatch({ type: 'ADD_LOG', payload: 'Error updating bot status' });
            }
        } catch {
            dispatch({ type: 'ADD_LOG', payload: 'Error updating bot status' });
        }
    };

    return (
        <header className="flex justify-between items-center p-4 bg-gray-900 text-white border-b border-gray-700">
            <div className="flex items-center">
                <button
                    onClick={() => setSidebarOpen(true)}
                    className="md:hidden mr-4 text-gray-400 hover:text-white"
                >
                    <Menu size={24} />
                </button>
                <h1 className="text-xl font-semibold hidden md:block">CryptoBot Dashboard</h1>
            </div>
            <div className="flex items-center space-x-2 md:space-x-6">
                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger>
                            <div className="flex items-center text-sm">
                                <Timer size={16} className="mr-2 text-gray-400" />
                                <span>Next cycle in: <strong>{state.nextCycleIn}</strong></span>
                            </div>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Time until the next automated trading cycle begins.</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>

                <TooltipProvider>
                    <Tooltip>
                        <TooltipTrigger>
                            <div className="flex items-center text-sm">
                                <Wallet size={16} className="mr-2 text-gray-400" />
                                <span className="hidden sm:inline">Sandbox Balance: </span>
                                <strong className="ml-1">€{state.portfolio.balance.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</strong>
                            </div>
                        </TooltipTrigger>
                        <TooltipContent>
                            <p>Your current virtual balance for simulated trading.</p>
                        </TooltipContent>
                    </Tooltip>
                </TooltipProvider>

                <button
                    onClick={toggleBotStatus}
                    className={`flex items-center px-4 py-2 rounded-md font-semibold text-sm transition-colors ${state.botStatus === 'active' 
                        ? 'bg-red-600 hover:bg-red-700 text-white' 
                        : 'bg-green-600 hover:bg-green-700 text-white'}`}
                >
                    <Power size={16} className="mr-2" />
                    {state.botStatus === 'active' ? 'Stop Bot' : 'Start Bot'}
                </button>
            </div>
        </header>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\HiveMindDisplay.tsx ---
// src/components/HiveMindDisplay.tsx

"use client";

import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Activity, Flame, Gauge, TrendingUp, HelpCircle } from 'lucide-react';

// This is mock data that simulates the full context object.
// Later, it will be replaced by `useDashboard` state.
const mockContext = {
    marketRegime: 'Risk-On',
    regimeScore: 7.8,
    sentiment: 'Bullish',
    sentimentScore: 0.6,
    fearAndGreed: { value: 72, classification: 'Greed' },
    btcDominance: 45.8,
    totalMarketCap: 2.1, // In trillions
    dominantNarrative: 'AI Tokens',
};

const RegimeBadge = ({ regime }: { regime: string }) => {
    const color = regime === 'Risk-On' ? 'bg-green-600' : regime === 'Risk-Off' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{regime.replace('-', ' ')}</Badge>;
};

const SentimentBadge = ({ sentiment }: { sentiment: string }) => {
    const color = sentiment === 'Bullish' ? 'bg-green-600' : sentiment === 'Bearish' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{sentiment}</Badge>;
};

const InfoRow = ({ label, children }: { label: string, children: React.ReactNode }) => (
    <div className="flex justify-between items-center text-sm py-2 border-b border-gray-800 last:border-none">
        <span className="text-gray-400 flex items-center">
            {label}
        </span>
        <span className="font-semibold">{children}</span>
    </div>
);

export function HiveMindDisplay() {
    // In the future, we will use the real context from the dashboard state:
    // const { state } = useDashboard();
    // const context = state.sharedContext;
    // if (!context) return <div>Loading Hive Mind...</div>;
    
    const context = mockContext; // Using mock data for now

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Macro Environment Card */}
            <div className="bg-gray-800 p-4 rounded-lg">
                <h3 className="font-semibold mb-2 flex items-center">
                    <Activity size={18} className="mr-2 text-gray-400" />
                    Macro Environment
                </h3>
                <div className="space-y-1">
                    <InfoRow label="Market Regime">
                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger>
                                    <RegimeBadge regime={context.marketRegime} />
                                </TooltipTrigger>
                                <TooltipContent><p>Score: {context.regimeScore.toFixed(1)} / 10.0</p></TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    </InfoRow>
                    <InfoRow label="Total Market Cap">
                        <span className="flex items-center">
                            ${context.totalMarketCap.toFixed(1)}T
                            <TrendingUp size={14} className="ml-1 text-green-500" />
                        </span>
                    </InfoRow>
                    <InfoRow label="BTC Dominance">
                         <span className="flex items-center">
                            {context.btcDominance.toFixed(1)}%
                            <TrendingUp size={14} className="ml-1 text-red-500" />
                        </span>
                    </InfoRow>
                </div>
            </div>

            {/* Market Sentiment Card */}
            <div className="bg-gray-800 p-4 rounded-lg">
                 <h3 className="font-semibold mb-2 flex items-center">
                    <Flame size={18} className="mr-2 text-gray-400" />
                    Market Sentiment
                </h3>
                <div className="space-y-1">
                    <InfoRow label="Overall Sentiment">
                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger>
                                     <SentimentBadge sentiment={context.sentiment} />
                                </TooltipTrigger>
                                <TooltipContent><p>Score: {context.sentimentScore.toFixed(2)} / 1.0</p></TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    </InfoRow>
                    <InfoRow label="Fear & Greed Index">
                        <span className="flex items-center text-yellow-400">
                           <Gauge size={14} className="mr-1.5" />
                           {context.fearAndGreed.value} - {context.fearAndGreed.classification}
                        </span>
                    </InfoRow>
                     <InfoRow label="Dominant Narrative">
                        <span>{context.dominantNarrative}</span>
                    </InfoRow>
                </div>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\IntelCard.tsx ---
// src/components/IntelCard.tsx

import { ReactNode } from 'react';
import { LucideIcon } from 'lucide-react';

interface IntelCardProps {
    title: string;
    icon: LucideIcon;
    children: ReactNode;
    className?: string;
}

export function IntelCard({ title, icon: Icon, children, className = '' }: IntelCardProps) {
    return (
        <div className={`bg-gray-900 text-white p-4 rounded-lg ${className}`}>
            <div className="flex items-center mb-4">
                <Icon size={20} className="text-blue-400 mr-3" />
                <h2 className="font-bold text-lg">{title}</h2>
            </div>
            <div className="space-y-4">
                {children}
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\kpi-card.tsx ---
"use client";

import { ReactNode, useMemo, useEffect, useState } from 'react';
import { useDashboard } from '@/context/DashboardContext';

interface KpiCardProps {
    title: string;
    icon: ReactNode;
    kpiKey?: 'totalValue' | '24h_pnl' | 'freeCollateral';
    value?: string | number;
    color?: string;
}

export function KpiCard({ title, icon, kpiKey, value, color: propColor }: KpiCardProps) {
    const { state } = useDashboard();
    const { portfolio, marketData } = state;
    const [tradeHistory, setTradeHistory] = useState([]);

    useEffect(() => {
        async function fetchTradeHistory() {
            try {
                const response = await fetch('/api/history');
                const data = await response.json();
                setTradeHistory(data);
            } catch (error) {
                console.error("Failed to fetch trade history:", error);
            }
        }
        fetchTradeHistory();
        const interval = setInterval(fetchTradeHistory, 10000); // Refetch every 10 seconds
        return () => clearInterval(interval);
    }, []);

    const kpiValue = useMemo(() => {
        if (value !== undefined) return value;
        if (!portfolio || !kpiKey) return 0;

        const positionsValue = portfolio.positions.reduce((acc, pos) => {
            const marketInfo = marketData.find(md => md.symbol === pos.symbol);
            const currentPrice = marketInfo ? parseFloat(marketInfo.lastPrice) : pos.entryPrice;
            return acc + (currentPrice * pos.amount);
        }, 0);

        const totalValue = portfolio.balance + positionsValue;

        switch (kpiKey) {
            case 'totalValue':
                return totalValue;
            case 'freeCollateral':
                return portfolio.balance;
            case '24h_pnl':
                const now = new Date().getTime();
                const twentyFourHoursAgo = now - 24 * 60 * 60 * 1000;
                const pnl24h = tradeHistory.reduce((acc, trade) => {
                    const tradeTimestamp = new Date((trade as { timestamp: string }).timestamp).getTime();
                    if (tradeTimestamp > twentyFourHoursAgo) {
                        return acc + (trade as { pnl: number }).pnl;
                    }
                    return acc;
                }, 0);
                return pnl24h;
            default:
                return 0;
        }
    }, [portfolio, marketData, kpiKey, value, tradeHistory]);

    const formattedValue = typeof kpiValue === 'number' 
        ? `€${kpiValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
        : kpiValue;
    
    let color = propColor || 'text-white';
    if (kpiKey === '24h_pnl' && typeof kpiValue === 'number') {
        if (kpiValue > 0) color = 'text-green-400';
        if (kpiValue < 0) color = 'text-red-400';
    }

    return (
        <div className="bg-gray-900 p-4 rounded-lg flex items-center">
            <div className={`mr-4 ${color}`}>
                {icon}
            </div>
            <div>
                <p className="text-sm text-gray-400">{title}</p>
                <p className={`text-2xl font-bold ${color}`}>{formattedValue}</p>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\market-table.tsx ---
"use client";

import { useDashboard } from '@/context/DashboardContext';
import { Ticker } from '@/core/binance';

export function MarketTable() {
    const { state, dispatch } = useDashboard();

    const handleRowClick = (symbol: string) => {
        dispatch({ type: 'SET_SELECTED_SYMBOL', payload: symbol });
    };

    return (
        <div className="bg-gray-900 text-white p-4 rounded-lg">
            <h2 className="font-bold text-lg mb-2">Market Scanner</h2>
            <div className="overflow-y-auto h-[70vh]">
                <table className="w-full text-left">
                    <thead>
                        <tr className="border-b border-gray-700">
                            <th className="p-2">Symbol</th>
                            <th className="p-2">Price</th>
                            <th className="p-2">Change (24h)</th>
                            <th className="p-2">Volume (24h)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {state.marketData.map((ticker: Ticker) => (
                            <tr 
                                key={ticker.symbol} 
                                className={`border-b border-gray-800 hover:bg-gray-700 cursor-pointer ${state.selectedSymbol === ticker.symbol ? 'bg-gray-700' : ''}`}
                                onClick={() => handleRowClick(ticker.symbol)}
                            >
                                <td className="p-2 font-bold">{ticker.symbol}</td>
                                <td className="p-2">${parseFloat(ticker.lastPrice).toFixed(2)}</td>
                                <td className={`p-2 ${parseFloat(ticker.priceChangePercent) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    {parseFloat(ticker.priceChangePercent).toFixed(2)}%
                                </td>
                                <td className="p-2">${(parseFloat(ticker.quoteVolume) / 1_000_000).toFixed(2)}M</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\news-feed.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { Rss } from 'lucide-react';

interface Article {
    title: string;
    url: string;
    source: { name: string };
    publishedAt: string;
}

export function NewsFeed() {
    const [articles, setArticles] = useState<Article[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchNews() {
            setIsLoading(true);
            try {
                const response = await fetch('/api/news');
                const data = await response.json();
                setArticles(data.articles || []);
            } catch (error) {
                console.error("Failed to fetch news", error);
            } finally {
                setIsLoading(false);
            }
        }
        fetchNews();
    }, []);

    if (isLoading) {
        return <div className="text-center p-4">Loading news...</div>;
    }

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="text-lg font-semibold mb-4 flex items-center">
                <Rss size={20} className="mr-2" />
                Latest Crypto News
            </h2>
            <div className="space-y-4 max-h-96 overflow-y-auto">
                {articles.map((article, index) => (
                    <a 
                        key={index} 
                        href={article.url} 
                        target="_blank" 
                        rel="noopener noreferrer" 
                        className="block p-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors"
                    >
                        <p className="font-semibold">{article.title}</p>
                        <div className="flex justify-between items-center mt-2 text-xs text-gray-400">
                            <span>{article.source.name}</span>
                            <span>{new Date(article.publishedAt).toLocaleDateString()}</span>
                        </div>
                    </a>
                ))}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\opportunity-log.tsx ---
"use client";

import { useEffect, useState } from 'react';
import { useDashboard } from '@/context/DashboardContext';
import { Opportunity } from '@/core/opportunity-scanner';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { PlayCircle } from 'lucide-react';

export function OpportunityLog() {
    const { state, dispatch } = useDashboard();
    const [isLoading, setIsLoading] = useState<string | null>(null);

    const handleAnalyze = async (symbol: string) => {
        setIsLoading(symbol);
        try {
            const response = await fetch('/api/bot/decision', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ symbol }),
            });
            if (!response.ok) {
                throw new Error('Failed to analyze opportunity.');
            }
            // The dashboard context will update the opportunities list automatically
            // through its polling mechanism.
        } catch (error) {
            console.error("Analysis error:", error);
        } finally {
            setIsLoading(null);
        }
    };

    const getStatusVariant = (status: Opportunity['status']) => {
        switch (status) {
            case 'bought': return 'success';
            case 'ignored': return 'destructive';
            case 'analyzing': return 'secondary';
            default: return 'default';
        }
    };

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="font-semibold text-md mb-4">Opportunity Log (Fast Movers)</h2>
            <div className="space-y-3">
                {state.opportunities.length === 0 ? (
                    <p className="text-gray-400 text-sm">No significant price movements detected recently.</p>
                ) : (
                    state.opportunities.slice(0, 10).map((opp) => (
                        <div key={opp.timestamp} className="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                            <div>
                                <p className="font-bold">{opp.symbol}</p>
                                <p className={`text-sm ${opp.priceChangePercent && opp.priceChangePercent > 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    +{ (opp.priceChangePercent || 0).toFixed(2) }%
                                </p>
                                <p className="text-xs text-gray-400">{new Date(opp.timestamp).toLocaleTimeString()}</p>
                            </div>
                            <div className="flex items-center space-x-2">
                                <Badge variant={getStatusVariant(opp.status)}>{opp.status}</Badge>
                                {opp.status === 'detected' && (
                                    <Button 
                                        size="sm" 
                                        onClick={() => handleAnalyze(opp.symbol)}
                                        disabled={isLoading === opp.symbol}
                                    >
                                        <PlayCircle size={16} />
                                        <span className="ml-2">{isLoading === opp.symbol ? 'Analyzing...' : 'Analyze'}</span>
                                    </Button>
                                )}
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\shared-context-display.tsx ---
"use client";

import { ISharedContext } from '@/core/context';
import { Badge } from '@/components/ui/badge'; // Assuming you have a Badge component
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

interface SharedContextDisplayProps {
    context: ISharedContext | null;
}

const RegimeBadge = ({ regime }: { regime: ISharedContext['marketRegime'] }) => {
    const color = regime === 'Risk-On' ? 'bg-green-600' : regime === 'Risk-Off' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{regime.replace('-', ' ')}</Badge>;
};

const SentimentBadge = ({ sentiment }: { sentiment: ISharedContext['sentiment'] }) => {
    const color = sentiment === 'Bullish' ? 'bg-green-600' : sentiment === 'Bearish' ? 'bg-red-600' : 'bg-gray-600';
    return <Badge className={`${color} text-white`}>{sentiment}</Badge>;
};

export function SharedContextDisplay({ context }: SharedContextDisplayProps) {
    if (!context) {
        return (
            <div className="bg-gray-800 p-4 rounded-lg text-center">
                <h2 className="text-lg font-semibold mb-2">Hive Mind Context</h2>
                <p className="text-gray-400">Waiting for first cycle...</p>
            </div>
        );
    }

    return (
        <div className="bg-gray-800 p-4 rounded-lg">
            <h2 className="text-lg font-semibold mb-3">Hive Mind Context</h2>
            <div className="grid grid-cols-2 gap-4 text-sm">
                <div className="flex justify-between items-center">
                    <span className="text-gray-400">Market Regime:</span>
                    <TooltipProvider>
                        <Tooltip>
                            <TooltipTrigger>
                                <RegimeBadge regime={context.marketRegime} />
                            </TooltipTrigger>
                            <TooltipContent>
                                <p>Score: {context.regimeScore.toFixed(1)} / 10.0</p>
                            </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                </div>
                <div className="flex justify-between items-center">
                    <span className="text-gray-400">Market Sentiment:</span>
                     <TooltipProvider>
                        <Tooltip>
                            <TooltipTrigger>
                                <SentimentBadge sentiment={context.sentiment} />
                            </TooltipTrigger>
                            <TooltipContent>
                                <p>Score: {context.sentimentScore.toFixed(2)} / 1.0</p>
                            </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                </div>
                <div className="col-span-2">
                     <span className="text-gray-400">Key Topics:</span>
                     <div className="flex flex-wrap gap-2 mt-1">
                        {context.keyTopics.length > 0 ? context.keyTopics.map(topic => (
                            <Badge key={topic} variant="secondary">{topic}</Badge>
                        )) : <span className="text-xs text-gray-500">None detected</span>}
                     </div>
                </div>
            </div>
        </div>
    );
}

--- END FILE: {relative_filepath} ---

--- FILE: src\components\sidebar.tsx ---
// src/components/sidebar.tsx

"use client";

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Bot, Settings, BarChart, Wallet, LineChart, FlaskConical, History, X, Radar, BookOpen } from 'lucide-react'; 
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dispatch, SetStateAction } from 'react';

const navItems = [
    { href: '/dashboard', icon: BarChart, label: 'Dashboard', tooltip: 'View key performance indicators and market data.' },
    { href: '/dashboard/intel', icon: Radar, label: 'Market Intelligence', tooltip: 'The hub for deep market analysis and intel.' },
    { href: '/dashboard/portfolio', icon: Wallet, label: 'Portfolio', tooltip: 'Manage your open positions and view your balance.' },
    { href: '/dashboard/history', icon: History, label: 'History', tooltip: 'View your past trade history.' },
    { href: '/dashboard/backtest', icon: FlaskConical, label: 'Backtesting', tooltip: 'Test your strategies against historical data.' },
    { href: '/dashboard/optimization', icon: LineChart, label: 'Optimization', tooltip: 'Optimize your strategy parameters for better performance.' },
    { href: '/dashboard/how-it-works', icon: BookOpen, label: 'How It Works', tooltip: 'Understand the architecture of this AI trading system.' },
    { href: '/dashboard/settings', icon: Settings, label: 'Settings', tooltip: 'Configure your trading bot and strategies.' },
];

interface SidebarProps {
    sidebarOpen: boolean;
    setSidebarOpen: Dispatch<SetStateAction<boolean>>;
}

export function Sidebar({ sidebarOpen, setSidebarOpen }: SidebarProps) {
    const pathname = usePathname();

    return (
        <>
            {/* Mobile Sidebar */}
            <div className={`fixed inset-0 z-40 flex md:hidden ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'} transition-transform duration-300 ease-in-out`}>
                <div className="w-64 bg-gray-900 text-white border-r border-gray-700 flex flex-col p-4">
                    <div className="flex justify-between items-center mb-8">
                        <div className="flex items-center space-x-2">
                            <Bot size={28} className="text-blue-400" />
                            <h1 className="text-2xl font-bold">CryptoBot</h1>
                        </div>
                        <button onClick={() => setSidebarOpen(false)} className="text-gray-400 hover:text-white">
                            <X size={24} />
                        </button>
                    </div>
                    <nav className="flex-grow space-y-2">
                        {navItems.map((item) => (
                            <Link
                                key={item.href}
                                href={item.href}
                                onClick={() => setSidebarOpen(false)}
                                className={`flex items-center p-3 rounded-lg transition-colors ${
                                    pathname === item.href
                                        ? 'bg-blue-600 text-white'
                                        : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                                }`}
                            >
                                <item.icon className="mr-4" size={20} />
                                <span className="font-medium">{item.label}</span>
                            </Link>
                        ))}
                    </nav>
                </div>
            </div>

            {/* Desktop Sidebar */}
            <div className="hidden md:flex md:flex-shrink-0">
                <div className="w-64 flex flex-col p-4 bg-gray-900 text-white border-r border-gray-700">
                    <div className="mb-8 flex items-center space-x-2">
                        <Bot size={28} className="text-blue-400" />
                        <h1 className="text-2xl font-bold">CryptoBot</h1>
                    </div>
                    <nav className="flex-grow space-y-2">
                        <TooltipProvider>
                            {navItems.map((item) => (
                                <Tooltip key={item.href}>
                                    <TooltipTrigger asChild>
                                        <Link
                                            href={item.href}
                                            className={`flex items-center p-3 rounded-lg transition-colors ${
                                                pathname === item.href
                                                    ? 'bg-blue-600 text-white'
                                                    : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                                            }`}
                                        >
                                            <item.icon className="mr-4" size={20} />
                                            <span className="font-medium">{item.label}</span>
                                        </Link>
                                    </TooltipTrigger>
                                    <TooltipContent side="right">
                                        <p>{item.tooltip}</p>
                                    </TooltipContent>
                                </Tooltip>
                            ))}
                        </TooltipProvider>
                    </nav>
                </div>
            </div>
        </>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\TopNarrativesCard.tsx ---
// src/components/TopNarrativesCard.tsx

"use client";

import { IntelCard } from './IntelCard';
import { Layers, TrendingUp } from 'lucide-react';

interface Narrative {
    id: string;
    name: string;
    market_cap: number;
    market_cap_change_24h: number;
}

interface TopNarrativesCardProps {
    narratives: Narrative[] | null;
}

export function TopNarrativesCard({ narratives }: TopNarrativesCardProps) {
    return (
        <IntelCard title="Top Narratives" icon={Layers} className="col-span-1 md:col-span-2">
            <div className="overflow-x-auto">
                {!narratives || narratives.length === 0 ? (
                    <p className="text-gray-500 text-sm">Could not load narrative data.</p>
                ) : (
                    <table className="w-full text-left text-sm">
                        <thead>
                            <tr className="border-b border-gray-700">
                                <th className="p-2">Narrative / Sector</th>
                                <th className="p-2 text-right">Market Cap</th>
                                <th className="p-2 text-right">24h Change</th>
                            </tr>
                        </thead>
                        <tbody>
                            {narratives.map((narrative) => (
                                <tr key={narrative.id} className="border-b border-gray-800 hover:bg-gray-800 cursor-pointer">
                                    <td className="p-2 font-semibold">{narrative.name}</td>
                                    <td className="p-2 text-right">${(narrative.market_cap / 1_000_000_000).toFixed(2)}B</td>
                                    <td className={`p-2 text-right flex justify-end items-center ${narrative.market_cap_change_24h >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        <TrendingUp size={14} className="mr-1" />
                                        {narrative.market_cap_change_24h.toFixed(1)}%
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        </IntelCard>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\how-it-works\FeatureCard.tsx ---
// src/components/how-it-works/FeatureCard.tsx

import { LucideIcon } from 'lucide-react';

interface FeatureCardProps {
    icon: LucideIcon;
    title: string;
    description: string;
    isNextGen?: boolean;
}

export function FeatureCard({ icon: Icon, title, description, isNextGen = false }: FeatureCardProps) {
    return (
        <div className={`bg-gray-900 p-6 rounded-lg border-l-4 ${isNextGen ? 'border-purple-500' : 'border-blue-500'}`}>
            <div className="flex items-center mb-3">
                <Icon className={`mr-4 ${isNextGen ? 'text-purple-400' : 'text-blue-400'}`} size={28} />
                <h3 className="text-xl font-bold">{title}</h3>
            </div>
            <p className="text-gray-400 text-sm">
                {description}
            </p>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\how-it-works\Section.tsx ---
// src/components/how-it-works/Section.tsx

import { ReactNode } from "react";

interface SectionProps {
    title: string;
    subtitle: string;
    children: ReactNode;
}

export function Section({ title, subtitle, children }: SectionProps) {
    return (
        <section className="py-12">
            <div className="text-center mb-10">
                <h2 className="text-3xl font-bold tracking-tight sm:text-4xl">{title}</h2>
                <p className="mt-4 text-lg text-gray-400">{subtitle}</p>
            </div>
            <div>
                {children}
            </div>
        </section>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\how-it-works\TimelineStep.tsx ---
// src/components/how-it-works/TimelineStep.tsx

import { LucideIcon } from 'lucide-react';

interface TimelineStepProps {
    icon: LucideIcon;
    title: string;
    description: string;
    isLast?: boolean;
}

export function TimelineStep({ icon: Icon, title, description, isLast = false }: TimelineStepProps) {
    return (
        <div className="relative flex items-start">
            {!isLast && <div className="absolute left-6 top-12 -bottom-6 w-px bg-gray-700"></div>}
            <div className="flex-shrink-0">
                <div className="w-12 h-12 rounded-full bg-gray-800 flex items-center justify-center">
                    <Icon className="text-blue-400" size={24} />
                </div>
            </div>
            <div className="ml-6">
                <h4 className="text-lg font-semibold">{title}</h4>
                <p className="mt-1 text-gray-400 text-sm">{description}</p>
            </div>
        </div>
    );
}
--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\badge.tsx ---
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success: "border-transparent bg-green-500 text-white",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\button.tsx ---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\scroll-area.tsx ---
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Scrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Scrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.Scrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-gray-700" />
  </ScrollAreaPrimitive.Scrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.Scrollbar.displayName

export { ScrollArea, ScrollBar }

--- END FILE: {relative_filepath} ---

--- FILE: src\components\ui\tooltip.tsx ---
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

--- END FILE: {relative_filepath} ---

--- FILE: src\context\DashboardContext.tsx ---
// src/context/DashboardContext.tsx

"use client";

import { createContext, useContext, useReducer, ReactNode, useEffect, useRef, useState } from 'react';
import { Ticker } from '@/core/binance';
import { ISharedContext } from '@/core/context';
import { Opportunity } from '@/core/opportunity-scanner';
import toast from 'react-hot-toast';

interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

interface BinanceTickerEvent {
    s: string;
    c: string;
    P: string;
    q: string;
}

export interface AiChat {
    agent: string;
    prompt: string;
    response: Record<string, unknown>;
}

interface Analysis {
    [key: string]: unknown;
}

interface DashboardState {
    logs: string[];
    marketData: Ticker[];
    portfolio: Portfolio;
    isLoading: boolean;
    selectedSymbol: string;
    analysis: Analysis | null;
    botStatus: 'active' | 'inactive';
    aiChat: AiChat[];
    nextCycleIn: string;
    lastRunAnalysis: Analysis | null;
    sharedContext: ISharedContext | null;
    adjustedConfig: any | null;
    opportunities: Opportunity[];
}

type Action =
    | { type: 'ADD_LOG'; payload: string }
    | { type: 'ADD_AI_CHAT'; payload: AiChat }
    | { type: 'SET_MARKET_DATA'; payload: Ticker[] }
    | { type: 'UPDATE_MARKET_PRICES'; payload: Ticker[] }
    | { type: 'SET_PORTFOLIO'; payload: Portfolio }
    | { type: 'SET_LOADING'; payload: boolean }
    | { type: 'SET_SELECTED_SYMBOL'; payload: string }
    | { type: 'SET_BOT_STATUS'; payload: 'active' | 'inactive' }
    | { type: 'SET_TIMER'; payload: string }
    | { type: 'SET_LAST_RUN_ANALYSIS'; payload: Analysis | null }
    | { type: 'SET_SHARED_CONTEXT'; payload: ISharedContext }
    | { type: 'SET_OPPORTUNITIES'; payload: Opportunity[] };

const initialState: DashboardState = {
    logs: [],
    aiChat: [],
    marketData: [],
    portfolio: { balance: 0, positions: [] },
    isLoading: true,
    selectedSymbol: 'BTCUSDT',
    analysis: null,
    botStatus: 'inactive',
    nextCycleIn: 'N/A',
    lastRunAnalysis: null,
    sharedContext: null,
    adjustedConfig: null,
    opportunities: [],
};

function dashboardReducer(state: DashboardState, action: Action): DashboardState {
    switch (action.type) {
        case 'ADD_LOG':
            const newLogs = [...state.logs, `[${new Date().toLocaleTimeString()}] ${action.payload}`];
            return { ...state, logs: newLogs.slice(-100) };
        case 'ADD_AI_CHAT':
            const newChats = [...state.aiChat, action.payload];
            return { ...state, aiChat: newChats.slice(-100) };
        case 'SET_MARKET_DATA':
            return { ...state, marketData: action.payload };
        case 'UPDATE_MARKET_PRICES':
            const updatedMarketData = state.marketData.map(ticker => {
                const update = action.payload.find(u => u.symbol === ticker.symbol);
                return update ? { ...ticker, ...update } : ticker;
            });
            return { ...state, marketData: updatedMarketData };
        case 'SET_PORTFOLIO':
            return { ...state, portfolio: action.payload };
        case 'SET_LOADING':
            return { ...state, isLoading: action.payload };
        case 'SET_SELECTED_SYMBOL':
            return { ...state, selectedSymbol: action.payload };
        case 'SET_BOT_STATUS':
            return { ...state, botStatus: action.payload };
        case 'SET_TIMER':
            return { ...state, nextCycleIn: action.payload };
        case 'SET_LAST_RUN_ANALYSIS':
            return { ...state, lastRunAnalysis: action.payload };
        case 'SET_SHARED_CONTEXT':
            return { ...state, sharedContext: action.payload };
        case 'SET_OPPORTUNITIES':
            if (JSON.stringify(state.opportunities) !== JSON.stringify(action.payload)) {
                return { ...state, opportunities: action.payload };
            }
            return state;
        default:
            return state;
    }
}

const DashboardContext = createContext<{ state: DashboardState; dispatch: React.Dispatch<Action>; } | undefined>(undefined);

export function DashboardProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(dashboardReducer, initialState);
    const [config, setConfig] = useState<any | null>(null);
    const timerIdRef = useRef<NodeJS.Timeout | null>(null);
    const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const isCycleRunningRef = useRef(false);

    useEffect(() => {
        async function fetchInitialData() {
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_MARKET_DATA', payload: data.marketData });
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch initial dashboard data:", error);
            }
        }

        fetchInitialData();

        const eventSource = new EventSource('/api/market-stream');
        eventSource.onmessage = (event) => {
            try {
                const data: BinanceTickerEvent[] = JSON.parse(event.data);
                const transformedData: Ticker[] = data.map((item) => ({
                    symbol: item.s, lastPrice: item.c, priceChangePercent: item.P, quoteVolume: item.q,
                    priceChange: '', weightedAvgPrice: '', prevClosePrice: '', lastQty: '',
                    bidPrice: '', bidQty: '', askPrice: '', askQty: '', openPrice: '',
                    highPrice: '', lowPrice: '', volume: '', openTime: 0, closeTime: 0,
                    firstId: 0, lastId: 0, count: 0,
                }));
                dispatch({ type: 'UPDATE_MARKET_PRICES', payload: transformedData });
            } catch (error) {
                console.error("Failed to parse market stream data:", error);
            }
        };

        const portfolioInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/dashboard-data');
                if (!response.ok) throw new Error('Failed to fetch dashboard data');
                const data = await response.json();
                dispatch({ type: 'SET_PORTFOLIO', payload: data.portfolio });
            } catch (error) {
                console.error("Failed to fetch updated portfolio data:", error);
            }
        }, 15000); // THE FIX IS HERE: Changed from 1000 to 15000 (15 seconds)

        const opportunityInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/opportunities');
                if (response.ok) {
                    const data = await response.json();
                    dispatch({ type: 'SET_OPPORTUNITIES', payload: data });
                }
            } catch (error) {}
        }, 3000);

        return () => {
            eventSource.close();
            clearInterval(portfolioInterval);
            clearInterval(opportunityInterval);
        };
    }, []);

    const runCycle = async () => {
        if (isCycleRunningRef.current) return;
        isCycleRunningRef.current = true;
        dispatch({ type: 'ADD_LOG', payload: 'Bot cycle started...' });
        try {
            const res = await fetch('/api/bot/run');
            if (!res.ok || !res.body) throw new Error(`API request failed with status ${res.status}`);
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            const currentAnalysis: Analysis = {};
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
                for (const line of lines) {
                    try {
                        const json = JSON.parse(line.replace('data: ', ''));
                        const { type, message, data } = json;
                        if (type === 'log') dispatch({ type: 'ADD_LOG', payload: message });
                        else if (type === 'aiChat' && data) {
                            dispatch({ type: 'ADD_AI_CHAT', payload: data });
                            if (data.agent.startsWith('PortfolioAllocator')) currentAnalysis.PortfolioAllocator = data;
                        } else if (type === 'context') dispatch({ type: 'SET_SHARED_CONTEXT', payload: data });
                    } catch {}
                }
            }
            dispatch({ type: 'SET_LAST_RUN_ANALYSIS', payload: currentAnalysis });
        } catch (error) {
            const msg = error instanceof Error ? error.message : String(error);
            dispatch({ type: 'ADD_LOG', payload: `[CYCLE ERROR] ${msg}` });
        } finally {
            isCycleRunningRef.current = false;
        }
    };
    
    // Logic for scheduling and running cycles remains the same...
    
    return (
        <DashboardContext.Provider value={{ state, dispatch }}>
            {children}
        </DashboardContext.Provider>
    );
}

export function useDashboard() {
    const context = useContext(DashboardContext);
    if (context === undefined) {
        throw new Error('useDashboard must be used within a DashboardProvider');
    }
    return context;
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\agent-service.ts ---
// src/core/agent-service.ts

import { AIAgent } from './agents';

/**
 * AgentService veikia kaip centrinis registras ir komunikacijos tarpininkas visiems DI agentams.
 * Tai leidžia agentams dinamiškai atrasti vienas kitą ir bendradarbiauti.
 */
export class AgentService {
    // Privatus registras, saugantis visas agentų instancijas pagal jų vardus.
    private agents: Map<string, AIAgent> = new Map();

    /**
     * Užregistruoja agento instanciją tarnyboje, kad kiti agentai galėtų ją rasti.
     * @param agent Agentas, kurį reikia užregistruoti.
     */
    public register(agent: AIAgent): void {
        console.log(`[AgentService] Registering agent: ${agent.name}`);
        this.agents.set(agent.name, agent);
    }

    /**
     * Suranda ir grąžina agento instanciją pagal vardą.
     * @param name Agento vardas.
     * @returns Agento instancija arba undefined, jei nerasta.
     */
    public getAgent(name: string): AIAgent | undefined {
        return this.agents.get(name);
    }

    /**
     * Pagrindinis komunikacijos metodas, leidžiantis vienam agentui konsultuotis su kitu.
     * @param targetAgentName Agento, su kuriuo norima konsultuotis, vardas.
     * @param query Užklausa tekstiniu formatu.
     * @param callingAgentName Agento, kuris inicijuoja konsultaciją, vardas.
     * @returns Atsakymas iš pasikonsultuoto agento.
     */
    public async consult(targetAgentName: string, query: string, callingAgentName: string): Promise<any> {
        const agent = this.getAgent(targetAgentName);
        if (!agent) {
            const errorMessage = `[AgentService] Consultation failed: Agent '${targetAgentName}' not found.`;
            console.error(errorMessage);
            return { error: errorMessage };
        }

        console.log(`[AgentService] Agent '${callingAgentName}' is consulting '${targetAgentName}' with query: "${query}"`);
        // Iškviečiame specialų tikslinio agento metodą, skirtą atsakyti į užklausas.
        return agent.handleConsultation(query, callingAgentName);
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\agents.ts ---
// src/core/agents.ts

import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold, GenerativeModel } from "@google/generative-ai";
import { Candle } from "./binance";
import { SharedContext } from "./context";
import { calculateRSI, calculateMACD, calculateSMAExported } from "./indicators";
import { AgentService } from './agent-service';
import { MemoryService } from "./memory";
import fs from 'fs/promises';
import path from 'path';

class KeyRotator {
    private keys: string[];
    public currentIndex: number;

    constructor() {
        this.keys = process.env.GEMINI_API_KEYS?.split(',') || [];
        if (this.keys.length === 0) {
            throw new Error("GEMINI_API_KEYS not found or empty in .env.local");
        }
        this.currentIndex = 0;
    }

    getKey(): string { return this.keys[this.currentIndex]; }
    getNextKey(): string {
        this.currentIndex = (this.currentIndex + 1) % this.keys.length;
        console.warn(`Switching Gemini API key to #${this.currentIndex}`);
        return this.getKey();
    }
}

export abstract class AIAgent {
    private keyRotator: KeyRotator;
    private genAI: GoogleGenerativeAI;
    protected model: GenerativeModel;
    public readonly name: string;
    protected agentService: AgentService;

    constructor(name: string, agentService: AgentService) {
        if (!name || !agentService) {
            throw new Error("AIAgent requires a name and AgentService instance.");
        }
        this.name = name;
        this.agentService = agentService;
        const modelName = process.env.GEMINI_MODEL_NAME || 'gemini-1.5-flash';
        this.keyRotator = new KeyRotator();
        this.genAI = new GoogleGenerativeAI(this.keyRotator.getKey());
        this.model = this.genAI.getGenerativeModel({ model: modelName });
    }

    private reinitializeModel() {
        this.genAI = new GoogleGenerativeAI(this.keyRotator.getKey());
        this.model = this.genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
    }

    async safeGenerate(prompt: string, retries = 3): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                const safetySettings = [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE }, ];
                const result = await this.model.generateContent({ contents: [{ role: "user", parts: [{ text: prompt }] }], safetySettings, });
                const response = result.response;
                let jsonText = response.text().replace(/```json/g, "").replace(/```/g, "").trim();
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');
                if (firstBrace === -1 || lastBrace === -1) { throw new Error("No valid JSON object found in the response."); }
                jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                const jsonResponse = JSON.parse(jsonText) as Record<string, unknown>;
                return { prompt, response: jsonResponse };
            } catch (error) {
                const errorMessage = (error as Error).message;
                if (errorMessage.includes('429') || errorMessage.includes('Too Many Requests') || errorMessage.includes('RESOURCE_EXHAUSTED') || errorMessage.includes('quota')) {
                    this.keyRotator.getNextKey();
                    this.reinitializeModel();
                    if (attempt < retries - 1) { await new Promise(resolve => setTimeout(resolve, 2000)); continue; } 
                    else { return null; }
                }
                return null;
            }
        }
        return null;
    }
    
    protected async consult(targetAgentName: string, query: string): Promise<any> {
        const agent = this.agentService.getAgent(targetAgentName);
        if (!agent) { return { error: `Agent ${targetAgentName} not found.` }; }
        return agent.handleConsultation(query, this.name);
    }
    
    public async handleConsultation(query: string, callingAgentName: string): Promise<any> {
        const prompt = `
        **Persona:** You are ${this.name}, an expert in your domain.
        **Context:** The agent '${callingAgentName}' is requesting your expert opinion.
        **Query:** "${query}"
        **Task:** Provide a concise, direct, and expert answer to the query in JSON format, under the key "response".
        `;
        const result = await this.safeGenerate(prompt);
        return result?.response;
    }
}

export class MacroAnalyst extends AIAgent {
    constructor(agentService: AgentService) {
        super('MacroAnalyst', agentService);
    }
    
    async analyze(btcData: Record<string, unknown>, newsHeadlines: string[], fearAndGreedIndex: { value: string; classification: string } | null, globalMetrics: any, sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Macroeconomic and Crypto Market Cycle Analyst. Your task is to assess the overall market environment to determine if it's safe to take on risk.
        **Data Provided:**
        1.  **Bitcoin (4H TF) Last Candle:** ${JSON.stringify(btcData)}
        2.  **Top News Headlines:** ${JSON.stringify(newsHeadlines)}
        3.  **CoinMarketCap Fear and Greed Index:** ${JSON.stringify(fearAndGreedIndex)}
        4.  **Global Market Metrics:** ${JSON.stringify(globalMetrics)}
        **Task:** Provide a critical market assessment in JSON format.
        - \`market_regime\`: "Risk-On" (favorable for risky assets like altcoins) or "Risk-Off" (avoid risk, preserve capital).
        - \`regime_score\`: A number from 0.0 (extreme fear/danger) to 10.0 (extreme greed/opportunity).
        - \`reasoning\`: A brief explanation of why you chose this regime, referencing specific data points from the Global Metrics and Fear/Greed Index.
        - \`summary\`: A one-sentence, actionable summary for the portfolio manager.
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const { market_regime, regime_score } = result.response;
            if (typeof market_regime === 'string' && (market_regime === 'Risk-On' || market_regime === 'Risk-Off') && typeof regime_score === 'number') {
                sharedContext.updateContext({
                    marketRegime: market_regime,
                    regimeScore: regime_score
                });
            }
        }
        return result;
    }
}

export class SentimentAnalyst extends AIAgent {
    constructor(agentService: AgentService) {
        super('SentimentAnalyst', agentService);
    }
    
    async analyze(newsArticles: { title?: string }[], trendingTokens: any, sharedContext: SharedContext): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const headlines = newsArticles.map(article => article.title || '');
        const prompt = `
        **Persona:** You are an AI that analyzes text sentiment and social hype. You measure the emotional state of the market.
        **Data Provided:**
        1.  **General News Headlines:** ${JSON.stringify(headlines.slice(0, 10))}
        2.  **Community Trending Tokens:** ${JSON.stringify(trendingTokens)}
        **Task:** Evaluate the overall sentiment from the provided data and provide a structured analysis in JSON format.
        - \`sentiment\`: "Bullish", "Bearish", or "Neutral".
        - \`sentiment_score\`: A number from -1.0 (extremely negative) to 1.0 (extremely positive).
        - \`dominant_narrative\`: A short phrase describing the main story in the news AND what the community is focused on.
        - \`key_topics\`: An array of key topics driving the narrative.
        `;
        const result = await this.safeGenerate(prompt);
        if (result?.response) {
            const { sentiment, sentiment_score, key_topics, dominant_narrative } = result.response;
            if (typeof sentiment === 'string' && typeof sentiment_score === 'number' && Array.isArray(key_topics)) {
                sharedContext.updateContext({
                    sentiment: sentiment as any,
                    sentimentScore: sentiment_score,
                    keyTopics: key_topics as string[],
                    // @ts-ignore 
                    dominantNarrative: dominant_narrative as string,
                });
            }
        }
        return result;
    }
}

interface Position { symbol: string; amount: number; entryPrice: number; highPrice?: number; takeProfitPercent?: number; technicals?: Record<string, unknown>; }
interface Config { [key: string]: any; }
interface DecisionHistory { timestamp: string; decision: string; justification: string; }

export class PositionManager extends AIAgent {
    constructor(agentService: AgentService) {
        super('PositionManager', agentService);
    }
    
    async decide(position: Position, currentPrice: number, macroAnalysis: unknown, sentimentAnalysis: unknown, config: Config, decisionHistory: DecisionHistory[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const pnlPercent = (currentPrice - position.entryPrice) / position.entryPrice * 100;
        const prompt = `
        **Persona:** You are a professional, stateful trader managing a profitable position. Your goal is to maximize gains while intelligently protecting profits.
        **Current Context:**
        - **Position:** ${JSON.stringify(position, null, 2)}
        - **Current Price:** ${currentPrice}
        - **Current P/L (%):** ${pnlPercent.toFixed(2)}%
        - **Take-Profit Target (%):** ${position.takeProfitPercent || config.takeProfitPercent}%
        - **Macro Environment:** ${JSON.stringify(macroAnalysis, null, 2)}
        - **Market Sentiment:** ${JSON.stringify(sentimentAnalysis, null, 2)}
        **Task:** The position has reached its take-profit target. Decide whether to sell now or to let the profit run by increasing the take-profit target. Be a disciplined profit-taker, not a greedy gambler.
        **Format (JSON):**
        - \`decision\`: "SELL_NOW" or "HOLD_AND_INCREASE_TP".
        - \`new_take_profit_percent\`: (Only if holding) The new take-profit percentage (e.g., if current is ${config.takeProfitPercent}%, new could be ${config.takeProfitPercent + 2}%).
        - \`justification\`: A brief reason for your decision.
        `;
        return await this.safeGenerate(prompt);
    }
}

interface BuySignal { symbol: string; [key: string]: unknown; }
interface Portfolio { balance: number; positions: Position[]; }

export class PortfolioAllocator extends AIAgent {
    constructor(agentService: AgentService) { super('PortfolioAllocator', agentService); }
    async allocate(buySignals: BuySignal[], portfolio: Portfolio, macroAnalysis: unknown, sentimentAnalysis: unknown, sharedContext: SharedContext, narrativeContext?: { narrative: string; assets: string[] }, dexOpportunities?: string[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        let strategicPrioritySection = "No dominant narrative identified.";
        if (narrativeContext?.narrative) {
            strategicPrioritySection = `**Strategic Priority: Dominant narrative is '${narrativeContext.narrative}'.** Prioritize these assets: [${narrativeContext.assets.join(', ')}]`;
        }
        let dexSection = "No high-risk DEX opportunities identified.";
        if (dexOpportunities?.length) {
            dexSection = `**High-Risk Ops:** DEX Scout found: [${dexOpportunities.join(', ')}]. Consider very small, speculative allocations.`;
        }
        const prompt = `
        **Persona:** You are a Chief Investment Officer.
        **Context:**
        - **Portfolio:** ${JSON.stringify(portfolio)}
        - **Macro:** ${JSON.stringify(macroAnalysis)}
        - **Sentiment:** ${JSON.stringify(sentimentAnalysis)}
        - **Candidates:** ${JSON.stringify(buySignals)}
        **Directives:**
        1.  **Narrative:** ${strategicPrioritySection}
        2.  **Speculative:** ${dexSection}
        **Task & Rules:**
        1.  Synthesize all data. Prioritize narrative assets.
        2.  Do not deploy >50% of balance. Do not allocate >25% of deployable capital to one asset. DEX assets are capped at 1% each.
        3.  Justify your decisions based on the directives.
        **Format (JSON):** An object where each key is the symbol, with \`decision\`, \`amount_to_buy_usd\`, and \`justification\`.
        `;
        return await this.safeGenerate(prompt);
    }
}

export class TechnicalAnalyst extends AIAgent {
    constructor(agentService: AgentService) { super('TechnicalAnalyst', agentService); }
    async analyzeBatch(batchData: { symbol: string; candles: Candle[] }[], config: any): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const formattedData = batchData.map(d => ({
            symbol: d.symbol,
            rsi: calculateRSI(d.candles, config.rsiPeriod)?.toFixed(2),
            macdHistogram: calculateMACD(d.candles, config.macdShortPeriod, config.macdLongPeriod, config.macdSignalPeriod)?.histogram?.toFixed(4),
            sma20: calculateSMAExported(d.candles, config.smaShortPeriod)?.toFixed(2),
            sma50: calculateSMAExported(d.candles, config.smaLongPeriod)?.toFixed(2)
        }));
        const prompt = `
        **Persona:** You are a quantitative analyst. Analyze the following batch.
        **Data:** ${JSON.stringify(formattedData)}
        **Task:** For each asset, provide a technical score and summary in JSON format.
        - \`technical_score\`: 0.0 to 10.0.
        - \`trend\`: "Uptrend", "Downtrend", "Sideways".
        - \`momentum\`: "Bullish", "Bearish", "Neutral".
        - \`summary\`: One-sentence summary.
        `;
        return await this.safeGenerate(prompt);
    }
}

export interface Analysis { [key: string]: any; }

export class RiskManager extends AIAgent {
    private memoryService: MemoryService;
    constructor(agentService: AgentService) {
        super('RiskManager', agentService);
        this.memoryService = MemoryService.getInstance();
    }
    determineRiskParameters(baseConfig: any, sharedContext: SharedContext): any {
        const { regimeScore } = sharedContext.getContext();
        const newConfig = { ...baseConfig };
        if (regimeScore > 7.5) { newConfig.riskAmountPercent *= 1.25; } 
        else if (regimeScore < 4.0) { newConfig.riskAmountPercent *= 0.5; }
        return newConfig;
    }
    async decideBatch(batchTechAnalyses: Record<string, any>, macroAnalysis: any, sentimentAnalysis: any, fundamentalData: Record<string, any>): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const candidatesForPrompt: Record<string, any> = {};
        const consultationPromises: Promise<any>[] = [];
        const conflictSymbols: string[] = [];
        for (const symbol in batchTechAnalyses) {
            const tech = batchTechAnalyses[symbol];
            const situationNarrative = `Trade for ${symbol}. Macro: ${macroAnalysis?.market_regime}, Tech score: ${tech?.technical_score}`;
            const pastLessons = await this.memoryService.recallMemories(situationNarrative, 3);
            candidatesForPrompt[symbol] = {
                technicalAnalysis: tech,
                fundamentalAnalysis: fundamentalData[symbol.replace('USDT', '')] || { error: "No data." },
                pastLessons: pastLessons.map(p => p.narrative)
            };
            if ((tech?.technical_score || 0) > 8.0 && (macroAnalysis?.regime_score || 5.0) < 4.0) {
                const question = `Excellent tech signal for ${symbol} but macro is Risk-Off. Is this a trap?`;
                consultationPromises.push(this.consult('MacroAnalyst', question));
                conflictSymbols.push(symbol);
                candidatesForPrompt[symbol].consultation = { question };
            }
        }
        if (consultationPromises.length > 0) {
            const debateResults = await Promise.all(consultationPromises);
            debateResults.forEach((answer, index) => {
                const symbol = conflictSymbols[index];
                if (candidatesForPrompt[symbol].consultation) {
                    candidatesForPrompt[symbol].consultation.answer = answer?.response || "No response.";
                }
            });
        }
        const prompt = `
        **Persona:** You are a critical Risk Manager with perfect memory.
        **Context:**
        - **Macro:** ${JSON.stringify(macroAnalysis)}
        - **Sentiment:** ${JSON.stringify(sentimentAnalysis)}
        - **Candidates:** ${JSON.stringify(candidatesForPrompt)}
        **CRITICAL TASK & RULES:**
        1.  Synthesize all data: Macro, Technical, Fundamental, and Past Lessons.
        2.  **Learn from History:** If past lessons show losses in similar situations, be more cautious.
        3.  **Fundamental Veto:** If fundamentals are weak (missing URLs, vague description), reduce confidence_score by 2-3 points.
        4.  **Debate Interpretation:** Use consultation answers to resolve conflicts.
        **Format (JSON):** An object where each key is the symbol, with \`decision\`, \`confidence_score\`, and \`final_summary\`. Justification must mention key factors.
        `;
        return await this.safeGenerate(prompt);
    }
}

export class DEX_ScoutAgent extends AIAgent {
    constructor(agentService: AgentService) { super('DEX_ScoutAgent', agentService); }
    async analyze(latestDexPairs: any[], sharedContext: SharedContext): Promise<void> {
        if (!latestDexPairs?.length) return;
        const anomalies = latestDexPairs
            .filter(pair => {
                const quote = pair.quote?.[Object.keys(pair.quote)[0]];
                const volume24h = quote?.volume_24h || 0;
                const liquidity = quote?.liquidity || 0;
                return volume24h > 50000 && (liquidity === 0 || volume24h > liquidity);
            })
            .map(pair => pair.base_asset_symbol || pair.symbol);

        if (anomalies.length > 0) {
            // @ts-ignore
            sharedContext.updateContext({ dexOpportunities: anomalies });
        }
    }
}

export interface Trade { symbol: string; amount: number; entryPrice: number; exitPrice: number; pnl: number; timestamp: string; reason: string; }
export interface MissedOpportunity { timestamp: string; symbol: string; reason: string; }
export interface DecisionLogEntry { timestamp: string; symbol: string; decision: string; }

export class StrategyOptimizer extends AIAgent {
    constructor(agentService: AgentService) { super('StrategyOptimizer', agentService); }
    async analyze(trades: Trade[], missedOpportunities: MissedOpportunity[], decisionLogs: DecisionLogEntry[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Quantitative Analyst. Evolve the bot by learning from its history.
        **Data:**
        1.  **Trades:** ${JSON.stringify(trades.slice(-50))}
        2.  **Missed Ops:** ${JSON.stringify(missedOpportunities.slice(-50))}
        3.  **Decisions:** ${JSON.stringify(decisionLogs.slice(-50))}
        **TASK:** Perform a holistic analysis and generate a new, superior configuration.
        - Analyze performance: What are the common characteristics of winning vs. losing trades?
        - Propose & Justify: Generate a new configuration and explain why you are making each key change.
        **Format (JSON):**
        - \`analysis_summary\`: Brief summary of your findings.
        - \`suggested_settings\`: A complete JSON object with all configuration keys for the main config.json file.
        `;
        return await this.safeGenerate(prompt);
    }
}

export class MasterAgent extends AIAgent {
    constructor(agentService: AgentService) { super('MasterAgent', agentService); }
    async manageOptimizationCycle(mainPortfolio: Portfolio, shadowPortfolio: Portfolio | null, config: any, username: string): Promise<void> {
        const mainConfigPath = path.join(process.cwd(), 'config.json');
        const shadowConfigPath = path.join(process.cwd(), `shadow_config_${username}.json`);
        if (shadowPortfolio) {
            const mainValue = mainPortfolio.balance;
            const shadowValue = shadowPortfolio.balance;
            const performanceDiff = ((shadowValue - mainValue) / mainValue) * 100;
            if (performanceDiff > 5.0) {
                console.log(`[MasterAgent] Shadow config performed ${performanceDiff.toFixed(2)}% better. Promoting to main config.`);
                const shadowConfigData = await fs.readFile(shadowConfigPath, 'utf-8');
                await fs.writeFile(mainConfigPath, shadowConfigData);
                await fs.unlink(shadowConfigPath);
                const shadowPortfolioPath = path.join(process.cwd(), `portfolio_shadow_${username}.json`);
                await fs.writeFile(shadowPortfolioPath, JSON.stringify({ balance: 100000, positions: [] }, null, 2));
            } else {
                console.log(`[MasterAgent] Shadow config did not outperform. Discarding and generating a new one.`);
                await fs.unlink(shadowConfigPath);
                await this.generateNewShadowConfig(username, config);
            }
        } else {
            console.log('[MasterAgent] No shadow portfolio found. Generating a new shadow config.');
            await this.generateNewShadowConfig(username, config);
        }
    }
    private async generateNewShadowConfig(username: string, currentConfig: any): Promise<void> {
        const optimizer = this.agentService.getAgent('StrategyOptimizer') as StrategyOptimizer;
        if (!optimizer) { return; }
        const tradesLogPath = path.join(process.cwd(), `trades_log_${username}.json`);
        const missedLogPath = path.join(process.cwd(), `missed_opportunities_${username}.json`);
        const decisionLogPath = path.join(process.cwd(), `decision_log_${username}.json`);
        try {
            const trades = JSON.parse(await fs.readFile(tradesLogPath, 'utf-8'));
            const missed = JSON.parse(await fs.readFile(missedLogPath, 'utf-8'));
            const decisions = JSON.parse(await fs.readFile(decisionLogPath, 'utf-8'));
            if (trades.length < 10) { return; }
            const analysisResult = await optimizer.analyze(trades, missed, decisions);
            const suggestedSettings = analysisResult?.response?.suggested_settings as any;
            if (suggestedSettings) {
                const newConfig = { ...currentConfig, ...suggestedSettings };
                const shadowConfigPath = path.join(process.cwd(), `shadow_config_${username}.json`);
                await fs.writeFile(shadowConfigPath, JSON.stringify(newConfig, null, 2));
            }
        } catch (error) {
            if (error instanceof Error && 'code' in error && (error as NodeJS.ErrnoException).code !== 'ENOENT') {
                 console.error('[MasterAgent] Error during shadow config generation:', error);
            }
        }
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\binance.ts ---
import axios from 'axios';

// Type for a single candle
export type Candle = {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
};

// Type for the daily ticker stats
export type Ticker = {
    symbol: string;
    priceChange: string;
    priceChangePercent: string;
    weightedAvgPrice: string;
    prevClosePrice: string;
    lastPrice: string;
    lastQty: string;
    bidPrice: string;
    bidQty: string;
    askPrice: string;
    askQty: string;
    openPrice: string;
    highPrice: string;
    lowPrice: string;
    volume: string;
    quoteVolume: string;
    openTime: number;
    closeTime: number;
    firstId: number;
    lastId: number;
    count: number;
};

export class BinanceService {
    private baseUrl = 'https://api.binance.com/api/v3';

    private async fetchApi(endpoint: string, params: Record<string, string> = {}) {
        try {
            const response = await axios.get(`${this.baseUrl}/${endpoint}`, { params });
            return response.data;
        } catch (error) {
            console.error(`Failed to fetch from Binance API: ${endpoint}`, error);
            throw error;
        }
    }

    async getHistoricalData(symbol: string, interval: string, limit = 100): Promise<Candle[]> {
        // Define the raw candle type from Binance API
        type BinanceCandle = [number, string, string, string, string, string, ...unknown[]];
        try {
            const data = await this.fetchApi('klines', { symbol, interval, limit: String(limit) });
            return data.map((d: BinanceCandle) => ({
                time: d[0] / 1000,
                open: parseFloat(d[1]),
                high: parseFloat(d[2]),
                low: parseFloat(d[3]),
                close: parseFloat(d[4]),
                volume: parseFloat(d[5]),
            }));
        } catch {
            return [];
        }
    }

    async getCurrentPrice(symbol: string): Promise<number | null> {
        try {
            const data = await this.fetchApi('ticker/price', { symbol });
            return parseFloat(data.price);
        } catch {
            return null;
        }
    }

    async getTopSymbols(limit = 200): Promise<Ticker[]> {
        try {
            const data: Ticker[] = await this.fetchApi('ticker/24hr');
            // Filter for USDT pairs and exclude leveraged tokens or other special assets
            const usdtPairs = data.filter(t => 
                t.symbol.endsWith('USDT') && 
                !t.symbol.includes('UP') && 
                !t.symbol.includes('DOWN') &&
                !t.symbol.includes('BULL') &&
                !t.symbol.includes('BEAR') &&
                !t.symbol.match(/^\d/) // Exclude symbols that start with a number
            );
            const sorted = usdtPairs.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            return sorted.slice(0, limit);
        } catch {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\coinmarketcap - need pro plan.ts ---
// src/core/coinmarketcap.ts

interface FearAndGreedData {
    value: string;
    value_classification: string;
    timestamp: string;
}

interface GlobalMetricsQuote {
    total_market_cap: number;
    btc_dominance: number;
    defi_market_cap: number;
    stablecoin_market_cap: number;
}

interface GlobalMetricsData {
    quote: {
        USD: GlobalMetricsQuote;
    };
}

export class CoinMarketCapService {
    private apiKey: string;
    private baseUrl: string = 'https://pro-api.coinmarketcap.com';

    constructor() {
        this.apiKey = process.env.CMC_API_KEY || '';
        if (!this.apiKey) {
            console.warn('CMC_API_KEY is not defined. CMC features will be limited.');
        }
    }

    private async fetchApi<T>(endpoint: string, params: Record<string, string> = {}): Promise<T | null> {
        if (!this.apiKey) return null;
        
        const url = new URL(`${this.baseUrl}${endpoint}`);
        Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));

        try {
            const response = await fetch(url.toString(), {
                headers: {
                    'X-CMC_PRO_API_KEY': this.apiKey,
                    'Accept': 'application/json',
                },
            });

            if (!response.ok) {
                console.error(`CoinMarketCap API error for ${endpoint}: ${response.statusText}`, await response.text());
                return null;
            }

            const data = await response.json();
            if (data.status.error_code !== 0) {
                console.error('CoinMarketCap API error status:', data.status);
                return null;
            }
            return data.data as T;
        } catch (error) {
            console.error(`Error fetching from CoinMarketCap API endpoint ${endpoint}:`, error);
            return null;
        }
    }

    async getFearAndGreedIndex(): Promise<FearAndGreedData | null> {
        try {
            const response = await fetch('https://api.alternative.me/fng/?limit=1');
             if (!response.ok) return null;
             const data = await response.json();
             return data.data[0] ? {
                 value: data.data[0].value,
                 value_classification: data.data[0].value_classification,
                 timestamp: new Date(data.data[0].timestamp * 1000).toISOString(),
             } : null;
        } catch (error) {
            console.error('Error fetching Fear and Greed Index:', error);
            return null;
        }
    }
    
    async getGlobalMetrics(): Promise<GlobalMetricsData | null> {
        return this.fetchApi<GlobalMetricsData>('/v1/global-metrics/quotes/latest');
    }
    
    async getTrendingTokens(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/trending/most-visited', { limit: '10' });
    }
    
    async getTrendingGainersAndLosers(): Promise<any | null> {
        return this.fetchApi<any>('/v1/cryptocurrency/trending/gainers-losers', { limit: '10', sort_dir: 'desc', time_period: '24h' });
    }

    async getCategories(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/categories', { limit: '10', sort: 'market_cap', sort_dir: 'desc' });
    }
    
    async getCategoryById(id: string): Promise<any | null> {
        return this.fetchApi<any>(`/v1/cryptocurrency/category`, { id });
    }

    async getAirdrops(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/airdrops', { status: 'upcoming' });
    }

    async getCryptocurrencyInfo(symbols: string[]): Promise<any | null> {
        if (symbols.length === 0) return null;
        return this.fetchApi<any>('/v2/cryptocurrency/info', { symbol: symbols.join(',') });
    }

    async getLatestDexPairs(): Promise<any[] | null> {
        // CORRECTED ENDPOINT based on documentation and strategic plan
        return this.fetchApi<any[]>('/v4/dex/spot-pairs/latest', { sort: 'volume_24h', limit: '100' });
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\coinmarketcap.ts ---
// src/core/coinmarketcap.ts

interface FearAndGreedData {
    value: string;
    value_classification: string;
    timestamp: string;
}

interface GlobalMetricsQuote {
    total_market_cap: number;
    btc_dominance: number;
    defi_market_cap: number;
    stablecoin_market_cap: number;
}

interface GlobalMetricsData {
    quote: {
        USD: GlobalMetricsQuote;
    };
}

export class CoinMarketCapService {
    private apiKey: string;
    private baseUrl: string = 'https://pro-api.coinmarketcap.com';

    constructor() {
        this.apiKey = process.env.CMC_API_KEY || '';
        if (!this.apiKey) {
            console.warn('CMC_API_KEY is not defined. CMC features will be limited.');
        }
    }

    private async fetchApi<T>(endpoint: string, params: Record<string, string> = {}): Promise<T | null> {
        if (!this.apiKey) return null;
        
        const url = new URL(`${this.baseUrl}${endpoint}`);
        Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));

        try {
            const response = await fetch(url.toString(), {
                headers: {
                    'X-CMC_PRO_API_KEY': this.apiKey,
                    'Accept': 'application/json',
                },
            });

            const data = await response.json();

            // THE FIX IS HERE: We now check for any non-zero error code.
            // If the plan doesn't support the endpoint (403 Forbidden -> error_code 1006)
            // or if there's a bad request (400 -> error_code 400), we log it but don't crash.
            if (!response.ok || data.status.error_code !== 0) {
                console.warn(`CoinMarketCap API warning for ${endpoint}: ${data.status.error_message || response.statusText}. The system will proceed with available data.`);
                return null; // Return null instead of throwing an error.
            }
            
            return data.data as T;
        } catch (error) {
            console.error(`Error fetching from CoinMarketCap API endpoint ${endpoint}:`, error);
            return null; // Return null on network or parsing errors as well.
        }
    }

    async getFearAndGreedIndex(): Promise<FearAndGreedData | null> {
        try {
            const response = await fetch('https://api.alternative.me/fng/?limit=1');
             if (!response.ok) return null;
             const data = await response.json();
             return data.data[0] ? {
                 value: data.data[0].value,
                 value_classification: data.data[0].value_classification,
                 timestamp: new Date(data.data[0].timestamp * 1000).toISOString(),
             } : null;
        } catch (error) {
            console.error('Error fetching Fear and Greed Index:', error);
            return null;
        }
    }
    
    async getGlobalMetrics(): Promise<GlobalMetricsData | null> {
        return this.fetchApi<GlobalMetricsData>('/v1/global-metrics/quotes/latest');
    }
    
    async getTrendingTokens(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/trending/most-visited', { limit: '10' });
    }
    
    async getTrendingGainersAndLosers(): Promise<any | null> {
        return this.fetchApi<any>('/v1/cryptocurrency/trending/gainers-losers', { time_period: '24h' });
    }

    async getCategories(): Promise<any[] | null> {
        // THE FIX IS HERE: Removed the "sort" parameter that was causing a 400 Bad Request error.
        return this.fetchApi<any[]>('/v1/cryptocurrency/categories', { limit: '10' });
    }
    
    async getCategoryById(id: string): Promise<any | null> {
        return this.fetchApi<any>(`/v1/cryptocurrency/category`, { id });
    }

    async getAirdrops(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v1/cryptocurrency/airdrops', { status: 'upcoming' });
    }

    async getCryptocurrencyInfo(symbols: string[]): Promise<any | null> {
        if (symbols.length === 0) return null;
        return this.fetchApi<any>('/v2/cryptocurrency/info', { symbol: symbols.join(',') });
    }

    async getLatestDexPairs(): Promise<any[] | null> {
        return this.fetchApi<any[]>('/v4/dex/spot-pairs/latest', { sort: 'volume_24h', limit: '100' });
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\context.ts ---
// src/core/context.ts

export interface ISharedContext {
    marketRegime: 'Risk-On' | 'Risk-Off' | 'Neutral';
    regimeScore: number;
    sentiment: 'Bullish' | 'Bearish' | 'Neutral';
    sentimentScore: number;
    fearAndGreedIndex: { value: string; classification: string } | null;
    keyTopics: string[];
    activeThreats: string[];
    activeOpportunities: string[];
    dexOpportunities?: string[]; // NEW: For DEX Scout findings
}

export class SharedContext {
    private context: ISharedContext;

    constructor() {
        this.context = {
            marketRegime: 'Neutral',
            regimeScore: 5.0,
            sentiment: 'Neutral',
            sentimentScore: 0.0,
            fearAndGreedIndex: null,
            keyTopics: [],
            activeThreats: [],
            activeOpportunities: [],
            dexOpportunities: [],
        };
    }

    public updateContext(updates: Partial<ISharedContext>): void {
        this.context = { ...this.context, ...updates };
        console.log('SharedContext updated:', updates);
    }

    public getContext(): ISharedContext {
        return { ...this.context };
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\decision-logger.ts ---
import fs from 'fs/promises';
import path from 'path';

const getDecisionLogPath = (username: string) => path.join(process.cwd(), `decision_log_${username}.json`);

export interface DecisionLogEntry {
    symbol: string;
    decision: 'SELL_NOW' | 'HOLD_AND_INCREASE_TP' | 'BUY' | 'AVOID'; // Added BUY and AVOID
    pnlPercent?: number; // Made optional as it might not apply to BUY/AVOID
    currentPrice?: number; // Made optional
    newTakeProfitPercent?: number;
    amount?: number; // Added for BUY decisions
    reason?: string; // Changed from justification to reason for consistency with other logs
    justification?: string; // Kept for backward compatibility if needed, but prefer 'reason'
    timestamp: string;
}

export class DecisionLogger {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to DecisionLogger.");
        }
        this.username = username;
    }

    private getFilePath(): string {
        return getDecisionLogPath(this.username);
    }

    public async log(entry: Omit<DecisionLogEntry, 'timestamp'>): Promise<void> {
        const logFilePath = this.getFilePath();
        let logs: DecisionLogEntry[] = [];
        try {
            const data = await fs.readFile(logFilePath, 'utf-8');
            logs = JSON.parse(data);
        } catch (error) {
            // File might not exist yet, which is fine.
        }

        const newLog: DecisionLogEntry = {
            ...entry,
            timestamp: new Date().toISOString(),
        };

        logs.unshift(newLog); // Add to the beginning
        await fs.writeFile(logFilePath, JSON.stringify(logs, null, 2));
    }

    public async getLogs(): Promise<DecisionLogEntry[]> {
        try {
            const data = await fs.readFile(this.getFilePath(), 'utf-8');
            return JSON.parse(data);
        } catch (error) {
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\global-context.ts ---
import { SharedContext } from './context';

// Create a single, global instance of SharedContext
export const globalSharedContext = new SharedContext();

--- END FILE: {relative_filepath} ---

--- FILE: src\core\indicators.ts ---
import { Candle } from './binance';

// Helper to calculate Simple Moving Average (SMA)
function calculateSMA(data: number[], period: number): number[] {
    const sma: number[] = [];
    for (let i = 0; i <= data.length - period; i++) {
        const chunk = data.slice(i, i + period);
        const sum = chunk.reduce((a, b) => a + b, 0);
        sma.push(sum / period);
    }
    return sma;
}

// Helper to calculate Exponential Moving Average (EMA)
function calculateEMA(data: number[], period: number): number[] {
    const ema: number[] = [];
    const multiplier = 2 / (period + 1);
    let prevEma = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
    ema.push(prevEma);

    for (let i = period; i < data.length; i++) {
        const currentEma = (data[i] - prevEma) * multiplier + prevEma;
        ema.push(currentEma);
        prevEma = currentEma;
    }
    return ema;
}

export function calculateSMAExported(candles: Candle[], period: number): number | null {
    if (candles.length < period) return null;
    const prices = candles.map(c => c.close);
    const smaValues = calculateSMA(prices, period);
    return smaValues[smaValues.length - 1];
}

export function calculateRSI(candles: Candle[], period: number = 14): number | null {
    if (candles.length < period) return null;
    const prices = candles.map(c => c.close);
    let gains = 0;
    let losses = 0;

    for (let i = 1; i < prices.length; i++) {
        const diff = prices[i] - prices[i - 1];
        if (diff > 0) {
            gains += diff;
        } else {
            losses -= diff;
        }
    }

    const avgGain = gains / period;
    const avgLoss = losses / period;

    if (avgLoss === 0) return 100;

    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}

export function calculateMACD(candles: Candle[], shortPeriod: number = 12, longPeriod: number = 26, signalPeriod: number = 9) {
    if (candles.length < longPeriod) return null;
    const prices = candles.map(c => c.close);
    
    const emaShort = calculateEMA(prices, shortPeriod);
    const emaLong = calculateEMA(prices, longPeriod);
    
    const macdLine = emaShort.slice(emaLong.length - emaShort.length).map((val, index) => val - emaLong[index]);
    const signalLine = calculateEMA(macdLine, signalPeriod);
    
    const histogram = macdLine.slice(signalLine.length - macdLine.length).map((val, index) => val - signalLine[index]);

    return {
        macd: macdLine[macdLine.length - 1],
        signal: signalLine[signalLine.length - 1],
        histogram: histogram[histogram.length - 1],
    };
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\memory.ts ---
// src/core/memory.ts

import { GoogleGenerativeAI } from "@google/generative-ai";
import { ChromaClient, Collection, IEmbeddingFunction } from 'chromadb';

const client = new ChromaClient();
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEYS?.split(',')[0] || '');

// Interface for the data we want to store along with the vector
export interface MemoryMetadata {
    symbol: string;
    outcome: 'profit' | 'loss' | 'missed_opportunity';
    pnl_percent: number;
    timestamp: string;
    narrative: string; // The textual summary of the event
}

// Custom embedding function wrapper for ChromaDB that uses Gemini
class GeminiEmbeddingFunction implements IEmbeddingFunction {
    private model: any;

    constructor() {
        this.model = genAI.getGenerativeModel({ model: "embedding-001" });
    }

    public async generate(texts: string[]): Promise<number[][]> {
        const result = await this.model.batchEmbedContents({
            requests: texts.map(text => ({ model: "models/embedding-001", content: { parts: [{ text }] } }))
        });
        return result.embeddings.map(e => e.values);
    }
}

export class MemoryService {
    private static instance: MemoryService;
    private collection: Collection | null = null;
    private embeddingFunction: GeminiEmbeddingFunction;

    private constructor() {
        this.embeddingFunction = new GeminiEmbeddingFunction();
        this.initialize();
    }

    public static getInstance(): MemoryService {
        if (!MemoryService.instance) {
            MemoryService.instance = new MemoryService();
        }
        return MemoryService.instance;
    }

    private async initialize(): Promise<void> {
        try {
            // THE FIX IS HERE: We explicitly provide our custom Gemini embedding function.
            // This tells ChromaDB not to look for its default, missing one.
            this.collection = await client.getOrCreateCollection({ 
                name: "trade_memories",
                embeddingFunction: this.embeddingFunction
            });
            console.log("[MemoryService] ChromaDB collection 'trade_memories' loaded/created successfully.");
        } catch (error) {
            console.error("[MemoryService] Failed to initialize ChromaDB collection:", error);
        }
    }
    
    // This method is no longer needed as the collection handles embedding automatically
    // private async createEmbedding(text: string): Promise<number[]> { ... }

    public async addMemory(metadata: MemoryMetadata): Promise<void> {
        if (!this.collection) {
            console.error("[MemoryService] Collection not initialized. Cannot add memory.");
            return;
        }

        try {
            const id = `${metadata.symbol}_${metadata.timestamp}`;

            // Now we provide the text directly, and the collection uses the function we provided.
            await this.collection.add({
                ids: [id],
                metadatas: [metadata],
                documents: [metadata.narrative] // Provide the text to be embedded
            });

            console.log(`[MemoryService] Added new memory: ${id}`);
        } catch (error) {
            console.error("[MemoryService] Error adding memory to ChromaDB:", error);
        }
    }

    public async recallMemories(situation: string, count: number = 3): Promise<MemoryMetadata[]> {
        if (!this.collection || (await this.collection.count()) === 0) {
            return [];
        }

        try {
            // We now query by text, and the collection handles the embedding for the query.
            const results = await this.collection.query({
                queryTexts: [situation],
                nResults: count,
            });

            return (results.metadatas[0] as MemoryMetadata[]) || [];
        } catch (error) {
            console.error("[MemoryService] Error recalling memories from ChromaDB:", error);
            return [];
        }
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\core\news.ts ---
// Define the Article interface based on NewsAPI response
interface Article {
    source: {
        id: string | null;
        name: string;
    };
    author: string | null;
    title: string;
    description: string | null;
    url: string;
    urlToImage: string | null;
    publishedAt: string;
    content: string | null;
}

export class NewsService {
    private apiKey: string;
    private baseUrl: string = 'https://newsapi.org/v2/everything';

    constructor() {
        this.apiKey = process.env.NEWS_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('NEWS_API_KEY is not defined in the environment variables.');
        }
    }

    async getCryptoNews(query: string = 'crypto', pageSize: number = 10): Promise<Article[]> {
        try {
            const url = `${this.baseUrl}?q=${query}&apiKey=${this.apiKey}&pageSize=${pageSize}&sortBy=publishedAt&language=en`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch news: ${response.statusText}`);
            }
            const data = await response.json();
            return data.articles || [];
        } catch (error) {
            console.error('Error fetching crypto news:', error);
            return [];
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\opportunity-logger.ts ---
// src/core/opportunity-logger.ts
import fs from 'fs/promises';
import path from 'path';

const getMissedOpportunitiesPath = (username: string) => path.join(process.cwd(), `missed_opportunities_${username}.json`);

export interface MissedOpportunity {
    timestamp: string;
    symbol: string;
    priceChangePercent: number; // Added this field
    reason: string; // e.g., "AVOID decision by RiskManager"
    confidenceScore?: number;
    finalSummary?: string;
}

export class OpportunityLogger {
    private username: string;

    constructor(username: string) {
        if (!username) {
            throw new Error("Username must be provided to OpportunityLogger.");
        }
        this.username = username;
    }

    private getFilePath(): string {
        return getMissedOpportunitiesPath(this.username);
    }

    public async getLogs(): Promise<MissedOpportunity[]> {
        try {
            const data = await fs.readFile(this.getFilePath(), 'utf-8');
            return JSON.parse(data);
        } catch {
            // If file doesn't exist or is invalid, start with an empty array
            return [];
        }
    }

    async log(opportunity: Omit<MissedOpportunity, 'timestamp'>): Promise<void> {
        try {
            const logs = await this.getLogs();
            const newLog: MissedOpportunity = {
                timestamp: new Date().toISOString(),
                ...opportunity,
            };
            logs.push(newLog);
            // Keep the log from growing indefinitely
            const trimmedLogs = logs.slice(-500); 
            await fs.writeFile(this.getFilePath(), JSON.stringify(trimmedLogs, null, 2));
        } catch (error) {
            console.error("Failed to log missed opportunity:", error);
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\opportunity-scanner.ts ---
import fs from 'fs/promises';
import path from 'path';

const opportunitiesLogPath = path.join(process.cwd(), 'opportunities.json');

export interface Opportunity {
    symbol: string;
    priceChangePercent: number;
    timestamp: string;
    status: 'detected' | 'analyzing' | 'bought' | 'ignored' | 'sold' | 'held';
}

export class OpportunityScanner {
    private static instance: OpportunityScanner;
    private opportunities: Opportunity[] = [];

    private constructor() {
        this.loadOpportunities();
    }

    public static getInstance(): OpportunityScanner {
        if (!OpportunityScanner.instance) {
            OpportunityScanner.instance = new OpportunityScanner();
        }
        return OpportunityScanner.instance;
    }

    private async loadOpportunities(): Promise<void> {
        try {
            const data = await fs.readFile(opportunitiesLogPath, 'utf-8');
            this.opportunities = JSON.parse(data);
        } catch (error) {
            // File might not exist yet, which is fine.
            this.opportunities = [];
        }
    }

    private async saveOpportunities(): Promise<void> {
        await fs.writeFile(opportunitiesLogPath, JSON.stringify(this.opportunities, null, 2));
    }

    public async addOpportunity(opportunity: Omit<Opportunity, 'timestamp' | 'status'>): Promise<void> {
        const newOpportunity: Opportunity = {
            ...opportunity,
            timestamp: new Date().toISOString(),
            status: 'detected',
        };
        this.opportunities.unshift(newOpportunity); // Add to the beginning of the array
        await this.saveOpportunities();
    }

    public getOpportunities(): Opportunity[] {
        return this.opportunities;
    }

    public async updateOpportunityStatus(symbol: string, status: Opportunity['status']): Promise<void> {
        const opportunity = this.opportunities.find(o => o.symbol === symbol);
        if (opportunity) {
            opportunity.status = status;
            await this.saveOpportunities();
        }
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\optimizer.ts ---
import { AIAgent } from './agents';
import { DecisionLogEntry } from './decision-logger';
import { MissedOpportunity } from './opportunity-logger';

// Define the Trade interface
export interface Trade {
    symbol: string;
    amount: number;
    entryPrice: number;
    exitPrice: number;
    pnl: number;
    timestamp: string;
    reason: string;
}

export class StrategyOptimizer extends AIAgent {
    async analyze(trades: Trade[], missedOpportunities: MissedOpportunity[], decisionLogs: DecisionLogEntry[]): Promise<{ prompt: string; response: Record<string, unknown> } | null> {
        const prompt = `
        **Persona:** You are a Quantitative Analyst and AI Strategist. Your core function is to evolve this trading bot by learning from its complete performance history.

        **You have three data sources:**
        1.  **Executed Trades Log:** The final outcome of each trade (profit or loss).
        ${JSON.stringify(trades, null, 2)}

        2.  **Missed Opportunities Log:** Assets the bot decided to "AVOID".
        ${JSON.stringify(missedOpportunities, null, 2)}

        3.  **Position Management Decisions Log:** Records of when the bot decided to "HOLD" a winning position instead of selling immediately.
        ${JSON.stringify(decisionLogs, null, 2)}

        **CRITICAL TASK: Perform a holistic, data-driven analysis and generate a new, superior configuration.**

        1.  **Analyze Executed Trades:** What are the common characteristics of winning trades vs. losing trades? Look for patterns in technical indicators, market regime, etc.
        2.  **Analyze Missed Opportunities:** Were there any "AVOID" decisions that turned out to be highly profitable? Does this suggest the bot's entry criteria are too strict?
        3.  **Analyze Position Management (MOST IMPORTANT):** This is key to maximizing profit. For each "HOLD_AND_INCREASE_TP" decision in the log, compare the price at the time of the decision to the final exit price in the "Executed Trades Log".
            - Was holding the position, on average, more profitable than selling immediately?
            - Does the data suggest the \`takeProfitPercent\` should be higher or lower? Should it be more dynamic?
        4.  **Propose & Justify:** Based on your complete analysis, generate a new, fully optimized configuration. Your summary must explain *why* you are making each key change, referencing your findings from all three data logs.

        **Format (JSON):**
        - \`analysis_summary\`: A brief summary of your key findings from the trade history.
        - \`suggested_settings\`: A complete JSON object containing the full, new configuration. This object must include values for all of these keys: "sellStrategy", "takeProfitPercent", "stopLossPercent", "trailingStopPercent", "riskAmountPercent", "rsiPeriod", "symbolsToAnalyze", "batchSize", "macroScoreThreshold", "minimumBalance", "cycleIntervalMinutes", "smaShortPeriod", "smaLongPeriod", "macdShortPeriod", "macdLongPeriod", "macdSignalPeriod".
        `;
        return await this.safeGenerate(prompt);
    }
}

--- END FILE: {relative_filepath} ---

--- FILE: src\core\portfolio.ts ---
// src/core/portfolio.ts

import fs from 'fs/promises';
import path from 'path';
import { setTimeout } from 'timers/promises';
import { Trade } from './optimizer';
import { MemoryService } from './memory';
import { ISharedContext } from './context';

// This function now generates filenames based on the mode (main or shadow)
const getSuffixedPath = (baseName: string, username: string, mode: 'main' | 'shadow') => {
    const suffix = mode === 'shadow' ? `_shadow_${username}.json` : `_${username}.json`;
    return path.join(process.cwd(), baseName.replace('.json', suffix));
};

interface Position {
    symbol: string;
    amount: number;
    entryPrice: number;
    highPrice?: number;
    takeProfitPercent?: number;
    holdCount?: number;
    stopLossPrice?: number;
    highPnlPercent?: number;
}

interface Portfolio {
    balance: number;
    positions: Position[];
}

export class PortfolioService {
    private username: string;
    private mode: 'main' | 'shadow';
    private memoryService: MemoryService;

    constructor(username: string, mode: 'main' | 'shadow' = 'main') {
        if (!username) {
            throw new Error("Username must be provided to PortfolioService.");
        }
        this.username = username;
        this.mode = mode;
        // Memory service is only used for the main portfolio to avoid learning from untested strategies
        if (this.mode === 'main') {
            this.memoryService = MemoryService.getInstance();
        }
    }

    private getFilePaths() {
        return {
            portfolioFilePath: getSuffixedPath('portfolio.json', this.username, this.mode),
            lockFilePath: getSuffixedPath('portfolio.lock', this.username, this.mode),
            tradesLogFilePath: getSuffixedPath('trades_log.json', this.username, this.mode),
        };
    }

    private async withPortfolio(worker: (portfolio: Portfolio) => Promise<void> | void): Promise<void> {
        const { lockFilePath, portfolioFilePath } = this.getFilePaths();
        const lockAcquired = await this.acquireLock(lockFilePath);
        if (!lockAcquired) {
            throw new Error(`Failed to acquire ${this.mode} portfolio lock after multiple retries.`);
        }

        let portfolio: Portfolio;
        try {
            try {
                const data = await fs.readFile(portfolioFilePath, 'utf-8');
                portfolio = JSON.parse(data);
            } catch (error) {
                portfolio = { balance: 100000, positions: [] };
            }

            await worker(portfolio);
            await fs.writeFile(portfolioFilePath, JSON.stringify(portfolio, null, 2));
        } finally {
            await this.releaseLock(lockFilePath);
        }
    }
    
    private async acquireLock(lockFilePath: string, retries = 20, delay = 200): Promise<boolean> {
        for (let i = 0; i < retries; i++) {
            try {
                await fs.writeFile(lockFilePath, process.pid.toString(), { flag: 'wx' });
                return true;
            } catch (error) {
                if ((error as NodeJS.ErrnoException).code === 'EEXIST') {
                    await setTimeout(delay);
                } else {
                    throw error;
                }
            }
        }
        return false;
    }
    
    private async releaseLock(lockFilePath: string): Promise<void> {
        try {
            await fs.unlink(lockFilePath);
        } catch (error) {
            if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
                console.error(`Failed to release ${this.mode} portfolio lock for ${this.username}:`, error);
            }
        }
    }

    async getPortfolio(): Promise<Portfolio> {
        const { portfolioFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(portfolioFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return { balance: 100000, positions: [] };
        }
    }

    async buy(symbol: string, amount: number, price: number): Promise<void> {
        await this.withPortfolio(async (portfolio) => {
            const cost = amount * price;
            const fee = cost * 0.001;
            if (portfolio.balance < cost + fee) {
                throw new Error('Insufficient balance for cost + fee');
            }
            portfolio.balance -= (cost + fee);

            const newPosition: Position = { symbol, amount, entryPrice: price, highPrice: price };
            
            const existingPosition = portfolio.positions.find(p => p.symbol === symbol);
            if (existingPosition) {
                const totalAmount = existingPosition.amount + amount;
                const newEntryPrice = ((existingPosition.entryPrice * existingPosition.amount) + (price * amount)) / totalAmount;
                existingPosition.entryPrice = newEntryPrice;
                existingPosition.amount = totalAmount;
            } else {
                portfolio.positions.push(newPosition);
            }
        });
    }

    async updatePosition(symbol: string, updates: Partial<Position>): Promise<void> {
        await this.withPortfolio((portfolio) => {
            const position = portfolio.positions.find(p => p.symbol === symbol);
            if (position) {
                Object.assign(position, updates);
            }
        });
    }

    async sell(symbol: string, amount: number, price: number, reason: string, context: ISharedContext): Promise<void> {
        await this.withPortfolio(async (portfolio) => {
            const positionIndex = portfolio.positions.findIndex(p => p.symbol === symbol);
            if (positionIndex === -1) {
                throw new Error('Position not found to sell.');
            }
            const position = portfolio.positions[positionIndex];
            if (position.amount < amount) {
                throw new Error('Insufficient position amount to sell.');
            }

            const revenue = amount * price;
            const fee = revenue * 0.001;
            const pnl = (price - position.entryPrice) * amount - fee;
            const pnlPercent = (pnl / (position.entryPrice * amount)) * 100;
            portfolio.balance += (revenue - fee);

            const tradeLog: Trade = {
                symbol, amount, entryPrice: position.entryPrice, exitPrice: price, pnl,
                timestamp: new Date().toISOString(), reason
            };
            const { tradesLogFilePath } = this.getFilePaths();
            const tradeLogs = await this.getTradeLogs();
            tradeLogs.push(tradeLog);
            await fs.writeFile(tradesLogFilePath, JSON.stringify(tradeLogs, null, 2));

            if (this.mode === 'main' && this.memoryService) {
                const outcome = pnl >= 0 ? 'profit' : 'loss';
                const narrative = `Sold ${amount.toFixed(4)} ${symbol} with a ${pnlPercent.toFixed(2)}% ${outcome}. ` +
                                  `The sale was triggered by: ${reason}. ` +
                                  `Market conditions at the time were: Regime=${context.marketRegime} (Score: ${context.regimeScore.toFixed(1)}), ` +
                                  `Sentiment=${context.sentiment} (Score: ${context.sentimentScore.toFixed(2)}).`;

                await this.memoryService.addMemory({
                    symbol,
                    outcome,
                    pnl_percent: pnlPercent,
                    timestamp: new Date().toISOString(),
                    narrative
                });
            }

            portfolio.positions.splice(positionIndex, 1);
        });
    }

    async getTradeLogs(): Promise<Trade[]> {
        const { tradesLogFilePath } = this.getFilePaths();
        try {
            const data = await fs.readFile(tradesLogFilePath, 'utf-8');
            return JSON.parse(data);
        } catch {
            return [];
        }
    }
}
--- END FILE: {relative_filepath} ---

--- FILE: src\lib\auth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import fs from 'fs/promises';
import path from 'path';
import bcrypt from 'bcryptjs';

const usersFilePath = path.join(process.cwd(), 'users.json');

async function getUsers() {
    try {
        const data = await fs.readFile(usersFilePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        return {};
    }
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials) {
            return null;
        }
        const users = await getUsers();
        const user = users[credentials.username];

        if (user && await bcrypt.compare(credentials.password, user.password)) {
          return { id: credentials.username, name: credentials.username };
        }
        return null;
      }
    })
  ],
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.name = user.name;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.name = token.name;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  }
};

--- END FILE: {relative_filepath} ---

--- FILE: src\lib\utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- END FILE: {relative_filepath} ---

